Signal Name,Input/Output/Inout,Synchronous To,Description
Clocks and Resets,,,
clk_main_a0,input,,Main clock.  This is the clock for all of the interfaces to the SH
clk_extra_a1,input,,Extra clock A1 (phase aligned to "A" clock group)
clk_extra_a2,input,,Extra clock A2 (phase aligned to "A" clock group)
clk_extra_a3,input,,Extra clock A3 (phase aligned to "A" clock group)
clk_extra_b0,input,,Extra clock B0 (phase aligned to "B" clock group)
clk_extra_b1,input,,Extra clock B1 (phase aligned to "B" clock group)
clk_extra_c0,input,,Extra clock C0 (phase aligned to "B" clock group)
clk_extra_c1,input,,Extra clock C1 (phase aligned to "B" clock group)
kernel_rst_n,input,,Kernel reset (for SDA platform)
rst_main_n,input,,Reset sync to main clock.
Miscellaneous,,,
sh_cl_flr_assert,input,,Function level reset assertion.  Level signal that indicates PCIe function level reset is asserted 
cl_sh_flr_done,output,,Function level reset done indication.  Must be asserted by CL when done processing function level reset.
cl_sh_status0[31:0],output,,Functionality TBD
cl_sh_status1[31:0],output,,Functionality TBD
cl_sh_id0[31:0],output,,
cl_sh_id1[31:0],output,,
sh_cl_ctl0[31:0],input,,Functionality TBD
sh_cl_ctl1[31:0],input,,Functionality TBD
sh_cl_status_vdip[15:0],input,,Virtual DIP switches.  Controlled through FPGA management PF and tools.
cl_sh_status_vled[15:0],output,,Virtual LEDs, monitored through FPGA management PF and tools
sh_cl_pwr_state[1:0],input,,Power state  2'b00: Normal 2'b11: Critical
PCIe Master interface from CL,,,
cl_sh_pcim_awid[15:0],output,,
cl_sh_pcim_awaddr[63:0],output,,
cl_sh_pcim_awlen[7:0],output,,
cl_sh_pcim_awsize[2:0],output,,
cl_sh_pcim_awuser[18:0],output,, 10:0 Length in DW of the transaction
                                 14:11 are the byte-enable for the first DW (bit value 1 mean byte is enable, i.e. not masked)
                                 18:15 are the byte-enable for the last DW (bit value 1 mean byte is enable, i.e. not masked)
cl_sh_pcim_awvalid,output,,
sh_cl_pcim_awready,input,,
cl_sh_pcim_wdata[511:0],output,,
cl_sh_pcim_wstrb[63:0],output,,
cl_sh_pcim_wlast,output,,
cl_sh_pcim_wvalid,output,,
sh_cl_pcim_wready,input,,
sh_cl_pcim_bid[15:0],input,,
sh_cl_pcim_bresp[1:0],input,,
sh_cl_pcim_bvalid,input,,
cl_sh_pcim_bready,output,,
cl_sh_pcim_arid[15:0],output,,Note max 32 outstanding txns are supported, width is larger to allow bits for AXI fabrics
cl_sh_pcim_araddr[63:0],output,,
cl_sh_pcim_arlen[7:0],output,,
cl_sh_pcim_arsize[2:0],output,,
cl_sh_pcim_aruser[18:0],output,,10:0 Length in DW of the transaction
cl_sh_pcim_arvalid,output,,
sh_cl_pcim_arready,input,,
sh_cl_pcim_rid[15:0],input,,
sh_cl_pcim_rdata[511:0],input,,
sh_cl_pcim_rresp[1:0],input,,
sh_cl_pcim_rlast,input,,
sh_cl_pcim_rvalid,input,,
cl_sh_pcim_rready,output,,
cfg_max_payload[1:0],input,,Max payload size - 00:128B, 01:256B, 10:512B
cfg_max_read_req[2:0],input,,Max read requst size - 000b:128B, 001b:256B, 010b:512B, 011b:1024B
                             100b-2048B, 101b:4096B
DDR-4 Interface,,,x3 DDR is instantiated in CL.  This is the physical interface (fourth DDR is in SH)
DDR4 x72 RDIMM 2100 Interface A,,,
CLK_300M_DIMM0_DP,input,,
CLK_300M_DIMM0_DN,input,,
M_A_ACT_N,output,,
M_A_MA[16:0],output,,
M_A_BA[1:0],output,,
M_A_BG[1:0],output,,
M_A_CKE,output,,
M_A_ODT,output,,
M_A_CS_N,output,,
M_A_CLK_DN,output,,
M_A_CLK_DP,output,,
M_A_PAR,output,,
M_A_DQ[63:0],inout,,
M_A_ECC[7:0],inout,,
M_A_DQS_DP[17:0],inout,,
M_A_DQS_DN[17:0],inout,,
cl_RST_DIMM_A_N,output,,
DDR4 x72 RDIMM 2100 Interface B,,,
CLK_300M_DIMM1_DP,input,,
CLK_300M_DIMM1_DN,input,,
M_B_ACT_N,output,,
M_B_MA[16:0],output,,
M_B_BA[1:0],output,,
M_B_BG[1:0],output,,
M_B_CKE,output,,
M_B_ODT,output,,
M_B_CS_N,output,,
M_B_CLK_DN,output,,
M_B_CLK_DP,output,,
M_B_PAR,output,,
M_B_DQ[63:0],inout,,
M_B_ECC[7:0],inout,,
M_B_DQS_DP[17:0],inout,,
M_B_DQS_DN[17:0],inout,,
cl_RST_DIMM_B_N,output,,
DDR4 x72 RDIMM 2100 Interface D,,,
CLK_300M_DIMM3_DP,input,,
CLK_300M_DIMM3_DN,input,,
M_D_ACT_N,output,,
M_D_MA[16:0],output,,
M_D_BA[1:0],output,,
M_D_BG[1:0],output,,
M_D_CKE,output,,
M_D_ODT,output,,
M_D_CS_N,output,,
M_D_CLK_DN,output,,
M_D_CLK_DP,output,,
M_D_PAR,output,,
M_D_DQ[63:0],inout,,
M_D_ECC[7:0],inout,,
M_D_DQS_DP[17:0],inout,,
M_D_DQS_DN[17:0],inout,,
cl_RST_DIMM_D_N,output,,
DDR Stats interfaces for DDR controllers in the CL.  This must be hooked up to the sh_ddr.sv for the DDR interfaces to function.,,,
sh_ddr_stat_addr0[7:0],input,,
sh_ddr_stat_wr0,input,,
sh_ddr_stat_rd0,input,,
sh_ddr_stat_wdata0[31:0],input,,
ddr_sh_stat_ack0,output,,
ddr_sh_stat_rdata0[31:0],output,,
ddr_sh_stat_int0[7:0],output,,
sh_ddr_stat_addr1[7:0],input,,
sh_ddr_stat_wr1,input,,
sh_ddr_stat_rd1,input,,
sh_ddr_stat_wdata1[31:0],input,,
ddr_sh_stat_ack1,output,,
ddr_sh_stat_rdata1[31:0],output,,
ddr_sh_stat_int1[7:0],output,,
sh_ddr_stat_addr2[7:0],input,,
sh_ddr_stat_wr2,input,,
sh_ddr_stat_rd2,input,,
sh_ddr_stat_wdata2[31:0],input,,
ddr_sh_stat_ack2,output,,
ddr_sh_stat_rdata2[31:0],output,,
ddr_sh_stat_int2[7:0],output,,

AXI4 Interface for DDR_C This is the DDR controller that is instantiated in the SH.  CL is the AXI-4 master, and the DDR_C controller in the SH is the slave.,,,
cl_sh_ddr_awid[15:0],output,,
cl_sh_ddr_awaddr[63:0],output,,
cl_sh_ddr_awlen[7:0],output,,
cl_sh_ddr_awsize[2:0],output,,
cl_sh_ddr_awvalid,output,,
sh_cl_ddr_awready,input,,
cl_sh_ddr_wid[15:0],output,,
cl_sh_ddr_wdata[511:0],output,,
cl_sh_ddr_wstrb[63:0],output,,
cl_sh_ddr_wlast,output,,
cl_sh_ddr_wvalid,output,,
sh_cl_ddr_wready,input,,
sh_cl_ddr_bid[15:0],input,,
sh_cl_ddr_bresp[1:0],input,,
sh_cl_ddr_bvalid,input,,
cl_sh_ddr_bready,output,,
cl_sh_ddr_arid[15:0],output,,
cl_sh_ddr_araddr[63:0],output,,
cl_sh_ddr_arlen[7:0],output,,
cl_sh_ddr_arsize[2:0],output,,
cl_sh_ddr_arvalid,output,,
sh_cl_ddr_arready,input,,
sh_cl_ddr_rid[15:0],input,,
sh_cl_ddr_rdata[511:0],input,,
sh_cl_ddr_rresp[1:0],input,,
sh_cl_ddr_rlast,input,,
sh_cl_ddr_rvalid,input,,
cl_sh_ddr_rready,output,,
sh_cl_ddr_is_ready,input,,
The user-defined interrupts.  These map to MSI-X vectors through mapping in the SH.,,,
cl_sh_apppf_irq_req[15:0],output,,
sh_cl_apppf_irq_ack[15:0],input,,
PCIS AXI-4 interface to master cycles to CL,,,
sh_cl_dma_pcis_awid[5:0],input,,
sh_cl_dma_pcis_awaddr[63:0],input,,
sh_cl_dma_pcis_awlen[7:0],input,,
sh_cl_dma_pcis_awsize[2:0],input,,
sh_cl_dma_pcis_awvalid,input,,
cl_sh_dma_pcis_awready,output,,
sh_cl_dma_pcis_wdata[511:0],input,,
sh_cl_dma_pcis_wstrb[63:0],input,,
sh_cl_dma_pcis_wlast,input,,
sh_cl_dma_pcis_wvalid,input,,
cl_sh_dma_pcis_wready,output,,
cl_sh_dma_pcis_bid[5:0],output,,
cl_sh_dma_pcis_bresp[1:0],output,,
cl_sh_dma_pcis_bvalid,output,,
sh_cl_dma_pcis_bready,input,,
sh_cl_dma_pcis_arid[5:0],input,,
sh_cl_dma_pcis_araddr[63:0],input,,
sh_cl_dma_pcis_arlen[7:0],input,,
sh_cl_dma_pcis_arsize[2:0],input,,
sh_cl_dma_pcis_arvalid,input,,
cl_sh_dma_pcis_arready,output,,
cl_sh_dma_pcis_rid[5:0],output,,
cl_sh_dma_pcis_rdata[511:0],output,,
cl_sh_dma_pcis_rresp[1:0],output,,
cl_sh_dma_pcis_rlast,output,,
cl_sh_dma_pcis_rvalid,output,,
sh_cl_dma_pcis_rready,input,,
AXI-L maps to any inbound PCIe access through ManagementPF BAR4 for developer's use if the CL is created through  Xilinxâ€™s SDAccel, then this configuration bus would be connected automatically to SDAccel generic logic (SmartConnect, APM etc),,,
sda_cl_awvalid,input,,
sda_cl_awaddr[31:0],input,,
cl_sda_awready,output,,
Write data,,,
sda_cl_wvalid,input,,
sda_cl_wdata[31:0],input,,
sda_cl_wstrb[3:0],input,,
cl_sda_wready,output,,
Write response,,,
cl_sda_bvalid,output,,
cl_sda_bresp[1:0],output,,
sda_cl_bready,input,,
Read address,,,
sda_cl_arvalid,input,,
sda_cl_araddr[31:0],input,,
cl_sda_arready,output,,
Read data/response,,,
cl_sda_rvalid,output,,
cl_sda_rdata[31:0],output,,
cl_sda_rresp[1:0],output,,
sda_cl_rready,input,,

AXI-L maps to any inbound PCIe access through AppPF BAR0 For example, this AXI-L interface can connect to OpenCL Kernels This would connect automatically to the required logic if the CL is created through SDAccel flow,,,
sh_ocl_awvalid,input,,
sh_ocl_awaddr[31:0],input,,
ocl_sh_awready,output,,
Write data,,,
sh_ocl_wvalid,input,,
sh_ocl_wdata[31:0],input,,
sh_ocl_wstrb[3:0],input,,
ocl_sh_wready,output,,
Write response,,,
ocl_sh_bvalid,output,,
ocl_sh_bresp[1:0],output,,
sh_ocl_bready,input,,
Read address,,,
sh_ocl_arvalid,input,,
sh_ocl_araddr[31:0],input,,
ocl_sh_arready,output,,
Read data/response,,,
ocl_sh_rvalid,output,,
ocl_sh_rdata[31:0],output,,
ocl_sh_rresp[1:0],output,,
sh_ocl_rready,input,,
AXI-L maps to any inbound PCIe access through AppPF BAR1 For example,,,
sh_bar1_awvalid,input,,
sh_bar1_awaddr[31:0],input,,
bar1_sh_awready,output,,
Write data,,,
sh_bar1_wvalid,input,,
sh_bar1_wdata[31:0],input,,
sh_bar1_wstrb[3:0],input,,
bar1_sh_wready,output,,
Write response,,,
bar1_sh_bvalid,output,,
bar1_sh_bresp[1:0],output,,
sh_bar1_bready,input,,
Read address,,,
sh_bar1_arvalid,input,,
sh_bar1_araddr[31:0],input,,
bar1_sh_arready,output,,
Read data/response,,,
bar1_sh_rvalid,output,,
bar1_sh_rdata[31:0],output,,
bar1_sh_rresp[1:0],output,,
sh_bar1_rready,input,,
Debug bridge,,,
drck,input,,
shift,input,,
tdi,input,,
update,input,,
sel,input,,
tdo,output,,
tms,input,,
tck,input,,
runtest,input,,
reset,input,,
capture,input,,
bscanid_en,input,,
sh_cl_glcount0[63:0],input,,Global counter 0
sh_cl_glcount1[63:0],input,,Global counter 1





