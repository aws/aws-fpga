--
----  comp_defs - package
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
---- Filename:        comp_defs.vhd
---- Version:         v3.0
--   Description:     Component declarations for all black box netlists generated by
--                    running COREGEN when XST elaborated the client core
----
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

-- synopsys translate_off
--library XilinxCoreLib;
--use XilinxCoreLib.all;
-- synopsys translate_on
--library dist_mem_gen_v6_3;
--    use dist_mem_gen_v6_3.all;
--
--library dist_mem_gen_v6_4;
--    use dist_mem_gen_v6_4.all;

library dist_mem_gen_v8_0_11;
    use dist_mem_gen_v8_0_11.all;

package comp_defs is
--


-- -- component declaration
--    component  dist_mem_gen_v6_3
--    -------------------
--    generic(
--            c_has_clk               : integer := 1;
--            c_read_mif              : integer := 0;
--            c_has_qspo              : integer := 0;
--            c_addr_width            : integer := 8;
--            c_width                 : integer := 15;
--            c_family                : string  := "virtex7"; -- "virtex6";
--            c_sync_enable           : integer := 1;
--            c_depth                 : integer := 256;
--            c_has_qspo_srst         : integer := 1;
--            c_mem_init_file         : string  := "null.mif";
--            c_default_data          : string  := "0";
--            ------------------------
--            c_has_qdpo_clk          : integer := 0;
--            c_has_qdpo_ce           : integer := 0;
--            c_parser_type           : integer := 1;
--            c_has_d                 : integer := 0;
--            c_has_spo               : integer := 0;
--            c_reg_a_d_inputs        : integer := 0;
--            c_has_we                : integer := 0;
--            c_pipeline_stages       : integer := 0;
--            c_has_qdpo_rst          : integer := 0;
--            c_reg_dpra_input        : integer := 0;
--            c_qualify_we            : integer := 0;
--            c_has_qdpo_srst         : integer := 0;
--            c_has_dpra              : integer := 0;
--            c_qce_joined            : integer := 0;
--            c_mem_type              : integer := 0;
--            c_has_i_ce              : integer := 0;
--            c_has_dpo               : integer := 0;
--            c_has_spra              : integer := 0;
--            c_has_qspo_ce           : integer := 0;
--            c_has_qspo_rst          : integer := 0;
--            c_has_qdpo              : integer := 0
--            -------------------------
--           );
--    port(
--            a         : in std_logic_vector(c_addr_width-1-(4*c_has_spra*boolean'pos(c_addr_width > 4)) downto 0) := (others => '0');
--            d         : in  std_logic_vector(c_width-1 downto 0)      := (others => '0');
--            dpra      : in  std_logic_vector(c_addr_width-1 downto 0) := (others => '0');
--            spra      : in  std_logic_vector(c_addr_width-1 downto 0) := (others => '0');
--            clk       : in  std_logic                                 := '0';
--            we        : in  std_logic                                 := '0';
--            i_ce      : in  std_logic                                 := '1';
--            qspo_ce   : in  std_logic                                 := '1';
--            qdpo_ce   : in  std_logic                                 := '1';
--            qdpo_clk  : in  std_logic                                 := '0';
--            qspo_rst  : in  std_logic                                 := '0';
--            qdpo_rst  : in  std_logic                                 := '0';
--            qspo_srst : in  std_logic                                 := '0';
--            qdpo_srst : in  std_logic                                 := '0';
--            spo       : out std_logic_vector(c_width-1 downto 0);
--            dpo       : out std_logic_vector(c_width-1 downto 0);
--            qspo      : out std_logic_vector(c_width-1 downto 0);
--            qdpo      : out std_logic_vector(c_width-1 downto 0)
--         );
--    end component;
-- 
--    -- The following tells XST that dist_mem_gen_v6_2 is a black box which
--    -- should be generated.  The command given by the value of this attribute
--    -- Note the fully qualified SIM (JAVA class) name that forms the
--    -- basis of the core
-- 
--    --xcc exclude
-- 
-- --   attribute box_type          : string;
-- --   attribute GENERATOR_DEFAULT : string;
-- --
-- --   attribute box_type of dist_mem_gen_v6_3          : component is "black_box";
-- --   attribute GENERATOR_DEFAULT of dist_mem_gen_v6_3 : component is "generatecore com.xilinx.ip.dist_mem_gen_v6_3.dist_mem_gen_v6_3";
--    --xcc include
-- 
-- -- component declaration for dist_mem_gen_v6_4
--    component  dist_mem_gen_v6_4
--    -------------------
--    generic(
--            c_has_clk               : integer := 1;
--            c_read_mif              : integer := 0;
--            c_has_qspo              : integer := 0;
--            c_addr_width            : integer := 8;
--            c_width                 : integer := 15;
--            c_family                : string  := "virtex7"; -- "virtex6";
--            c_sync_enable           : integer := 1;
--            c_depth                 : integer := 256;
--            c_has_qspo_srst         : integer := 1;
--            c_mem_init_file         : string  := "null.mif";
--            c_default_data          : string  := "0";
--            ------------------------
--            c_has_qdpo_clk          : integer := 0;
--            c_has_qdpo_ce           : integer := 0;
--            c_parser_type           : integer := 1;
--            c_has_d                 : integer := 0;
--            c_has_spo               : integer := 0;
--            c_reg_a_d_inputs        : integer := 0;
--            c_has_we                : integer := 0;
--            c_pipeline_stages       : integer := 0;
--            c_has_qdpo_rst          : integer := 0;
--            c_reg_dpra_input        : integer := 0;
--            c_qualify_we            : integer := 0;
--            c_has_qdpo_srst         : integer := 0;
--            c_has_dpra              : integer := 0;
--            c_qce_joined            : integer := 0;
--            c_mem_type              : integer := 0;
--            c_has_i_ce              : integer := 0;
--            c_has_dpo               : integer := 0;
--            c_has_spra              : integer := 0;
--            c_has_qspo_ce           : integer := 0;
--            c_has_qspo_rst          : integer := 0;
--            c_has_qdpo              : integer := 0
--            -------------------------
--           );
--    port(
--            a         : in std_logic_vector(c_addr_width-1-(4*c_has_spra*boolean'pos(c_addr_width > 4)) downto 0) := (others => '0');
--            d         : in  std_logic_vector(c_width-1 downto 0)      := (others => '0');
--            dpra      : in  std_logic_vector(c_addr_width-1 downto 0) := (others => '0');
--            spra      : in  std_logic_vector(c_addr_width-1 downto 0) := (others => '0');
--            clk       : in  std_logic                                 := '0';
--            we        : in  std_logic                                 := '0';
--            i_ce      : in  std_logic                                 := '1';
--            qspo_ce   : in  std_logic                                 := '1';
--            qdpo_ce   : in  std_logic                                 := '1';
--            qdpo_clk  : in  std_logic                                 := '0';
--            qspo_rst  : in  std_logic                                 := '0';
--            qdpo_rst  : in  std_logic                                 := '0';
--            qspo_srst : in  std_logic                                 := '0';
--            qdpo_srst : in  std_logic                                 := '0';
--            spo       : out std_logic_vector(c_width-1 downto 0);
--            dpo       : out std_logic_vector(c_width-1 downto 0);
--            qspo      : out std_logic_vector(c_width-1 downto 0);
--            qdpo      : out std_logic_vector(c_width-1 downto 0)
--         );
--    end component;
-- 
--    -- The following tells XST that dist_mem_gen_v6_4 is a black box which
--    -- should be generated.  The command given by the value of this attribute
--    -- Note the fully qualified SIM (JAVA class) name that forms the
--    -- basis of the core
-- 
--    --xcc exclude
-- 
-- --   attribute box_type of dist_mem_gen_v6_4          : component is "black_box";
-- --   attribute GENERATOR_DEFAULT of dist_mem_gen_v6_4 : component is "generatecore com.xilinx.ip.dist_mem_gen_v6_4.dist_mem_gen_v6_4";
-- 
--    --xcc include

-- 1/8/2013 added the latest version of dist_mem_gen_v8_0_11

-- component declaration for dist_mem_gen_v8_0_11
   component  dist_mem_gen_v8_0_11
   -------------------
   generic(
           C_HAS_CLK               : integer := 1;
           C_READ_MIF              : integer := 0;
           C_HAS_QSPO              : integer := 0;
           C_ADDR_WIDTH            : integer := 8;
           C_WIDTH                 : integer := 15;
           C_FAMILY                : string  := "virtex7"; -- "virtex6";
           C_SYNC_ENABLE           : integer := 1;
           C_DEPTH                 : integer := 256;
           C_HAS_QSPO_SRST         : integer := 1;
           C_MEM_INIT_FILE         : string  := "null.mif";
           C_DEFAULT_DATA          : string  := "0";
           ------------------------
           C_HAS_QDPO_CLK          : integer := 0;
           C_HAS_QDPO_CE           : integer := 0;
           C_PARSER_TYPE           : integer := 1;
           C_HAS_D                 : integer := 0;
           C_HAS_SPO               : integer := 0;
           C_REG_A_D_INPUTS        : integer := 0;
           C_HAS_WE                : integer := 0;
           C_PIPELINE_STAGES       : integer := 0;
           C_HAS_QDPO_RST          : integer := 0;
           C_REG_DPRA_INPUT        : integer := 0;
           C_QUALIFY_WE            : integer := 0;
           C_HAS_QDPO_SRST         : integer := 0;
           C_HAS_DPRA              : integer := 0;
           C_QCE_JOINED            : integer := 0;
           C_MEM_TYPE              : integer := 0;
           C_HAS_I_CE              : integer := 0;
           C_HAS_DPO               : integer := 0;
          -- C_HAS_SPRA              : integer := 0; -- removed from dist mem gen core
           C_HAS_QSPO_CE           : integer := 0;
           C_HAS_QSPO_RST          : integer := 0;
           C_HAS_QDPO              : integer := 0
           -------------------------
          );
   port(
           a         : in std_logic_vector(c_addr_width-1 downto 0)  := (others => '0');
           d         : in  std_logic_vector(c_width-1 downto 0)      := (others => '0');
           dpra      : in  std_logic_vector(c_addr_width-1 downto 0) := (others => '0');
          -- spra      : in  std_logic_vector(c_addr_width-1 downto 0) := (others => '0'); -- 2/12/2013
           clk       : in  std_logic                                 := '0';
           we        : in  std_logic                                 := '0';
           i_ce      : in  std_logic                                 := '1';
           qspo_ce   : in  std_logic                                 := '1';
           qdpo_ce   : in  std_logic                                 := '1';
           qdpo_clk  : in  std_logic                                 := '0';
           qspo_rst  : in  std_logic                                 := '0';
           qdpo_rst  : in  std_logic                                 := '0';
           qspo_srst : in  std_logic                                 := '0';
           qdpo_srst : in  std_logic                                 := '0';
           spo       : out std_logic_vector(c_width-1 downto 0);
           dpo       : out std_logic_vector(c_width-1 downto 0);
           qspo      : out std_logic_vector(c_width-1 downto 0);
           qdpo      : out std_logic_vector(c_width-1 downto 0)
        );
   end component;

   -- The following tells XST that dist_mem_gen_v8_0_11 is a black box which
   -- should be generated.  The command given by the value of this attribute
   -- Note the fully qualified SIM (JAVA class) name that forms the
   -- basis of the core

   --xcc exclude

--   attribute box_type of dist_mem_gen_v8_0_11          : component is "black_box";
--   attribute GENERATOR_DEFAULT of dist_mem_gen_v8_0_11 : component is "generatecore com.xilinx.ip.dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11";

   --xcc include

end comp_defs;


-- pselect_f.vhd - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *************************************************************************
-- **                                                                     **
-- ** DISCLAIMER OF LIABILITY                                             **
-- **                                                                     **
-- ** This text/file contains proprietary, confidential                   **
-- ** information of Xilinx, Inc., is distributed under                   **
-- ** license from Xilinx, Inc., and may be used, copied                  **
-- ** and/or disclosed only pursuant to the terms of a valid              **
-- ** license agreement with Xilinx, Inc. Xilinx hereby                   **
-- ** grants you a license to use this text/file solely for               **
-- ** design, simulation, implementation and creation of                  **
-- ** design files limited to Xilinx devices or technologies.             **
-- ** Use with non-Xilinx devices or technologies is expressly            **
-- ** prohibited and immediately terminates your license unless           **
-- ** covered by a separate agreement.                                    **
-- **                                                                     **
-- ** Xilinx is providing this design, code, or information               **
-- ** "as-is" solely for use in developing programs and                   **
-- ** solutions for Xilinx devices, with no obligation on the             **
-- ** part of Xilinx to provide support. By providing this design,        **
-- ** code, or information as one possible implementation of              **
-- ** this feature, application or standard, Xilinx is making no          **
-- ** representation that this implementation is free from any            **
-- ** claims of infringement. You are responsible for obtaining           **
-- ** any rights you may require for your implementation.                 **
-- ** Xilinx expressly disclaims any warranty whatsoever with             **
-- ** respect to the adequacy of the implementation, including            **
-- ** but not limited to any warranties or representations that this      **
-- ** implementation is free from claims of infringement, implied         **
-- ** warranties of merchantability or fitness for a particular           **
-- ** purpose.                                                            **
-- **                                                                     **
-- ** Xilinx products are not intended for use in life support            **
-- ** appliances, devices, or systems. Use in such applications is        **
-- ** expressly prohibited.                                               **
-- **                                                                     **
-- ** Any modifications that are made to the Source Code are              **
-- ** done at the user’s sole risk and will be unsupported.               **
-- ** The Xilinx Support Hotline does not have access to source           **
-- ** code and therefore cannot answer specific questions related         **
-- ** to source HDL. The Xilinx Hotline support of original source        **
-- ** code IP shall only address issues and questions related             **
-- ** to the standard Netlist version of the core (and thus               **
-- ** indirectly, the original core source).                              **
-- **                                                                     **
-- ** Copyright (c) 2008-2010 Xilinx, Inc. All rights reserved.           **
-- **                                                                     **
-- ** This copyright and support notice must be retained as part          **
-- ** of this text at all times.                                          **
-- **                                                                     **
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        pselect_f.vhd
--
-- Description:
--                  (Note: At least as early as I.31, XST implements a carry-
--                   chain structure for most decoders when these are coded in
--                   inferrable VHLD. An example of such code can be seen
--                   below in the "INFERRED_GEN" Generate Statement.
--
--                   ->  New code should not need to instantiate pselect-type
--                       components.
--
--                   ->  Existing code can be ported to Virtex5 and later by
--                       replacing pselect instances by pselect_f instances.
--                       As long as the C_FAMILY parameter is not included
--                       in the Generic Map, an inferred implementation
--                       will result.
--
--                   ->  If the designer wishes to force an explicit carry-
--                       chain implementation, pselect_f can be used with
--                       the C_FAMILY parameter set to the target
--                       Xilinx FPGA family.
--                  )
--
--                  Parameterizeable peripheral select (address decode).
--                  AValid qualifier comes in on Carry In at bottom
--                  of carry chain.
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_com"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

library unisim;
use unisim.all;


-----------------------------------------------------------------------------
-- Entity section
-----------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Definition of Generics:
--          C_AB            -- number of address bits to decode
--          C_AW            -- width of address bus
--          C_BAR           -- base address of peripheral (peripheral select
--                             is asserted when the C_AB most significant
--                             address bits match the C_AB most significant
--                             C_BAR bits
-- Definition of Ports:
--          A               -- address input
--          AValid          -- address qualifier
--          CS              -- peripheral select
-------------------------------------------------------------------------------

entity pselect_f is

  generic (
    C_AB     : integer := 9;
    C_AW     : integer := 32;
    C_BAR    : std_logic_vector;
    C_FAMILY : string := "nofamily"
    );
  port (
    A        : in   std_logic_vector(0 to C_AW-1);
    AValid   : in   std_logic;
    CS       : out  std_logic
    );

end entity pselect_f;

-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of pselect_f is

  component MUXCY is
    port (
      O  : out std_logic;
      CI : in  std_logic;
      DI : in  std_logic;
      S  : in  std_logic
    );
  end component MUXCY;


  -----------------------------------------------------------------------------
  -- C_BAR may not be indexed from 0 and may not be ascending;
  -- BAR recasts C_BAR to have these properties.
  -----------------------------------------------------------------------------
  constant BAR          : std_logic_vector(0 to C_BAR'length-1) := C_BAR;

  type bo2sl_type is array (boolean) of std_logic;
  constant bo2sl  : bo2sl_type := (false => '0', true => '1');
 
  function min(i, j: integer) return integer is
  begin
      if i<j then return i; else return j; end if;
  end;

begin

  ------------------------------------------------------------------------------
  -- Check that the generics are valid.
  ------------------------------------------------------------------------------
  -- synthesis translate_off
     assert (C_AB <= C_BAR'length) and (C_AB <= C_AW)
     report "pselect_f generic error: " &
            "(C_AB <= C_BAR'length) and (C_AB <= C_AW)" &
            " does not hold."
     severity failure;
  -- synthesis translate_on


  ------------------------------------------------------------------------------
  -- Build a behavioral decoder
  ------------------------------------------------------------------------------
  
    XST_WA:if C_AB > 0 generate
      CS  <= AValid when A(0 to C_AB-1) = BAR (0 to C_AB-1) else
             '0' ;
    end generate XST_WA;
    
    PASS_ON_GEN:if C_AB = 0 generate
      CS  <= AValid ;
    end generate PASS_ON_GEN;
    


end imp;




-------------------------------------------------------------------------------
-- counter_f - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *************************************************************************
-- **                                                                     **
-- ** DISCLAIMER OF LIABILITY                                             **
-- **                                                                     **
-- ** This text/file contains proprietary, confidential                   **
-- ** information of Xilinx, Inc., is distributed under                   **
-- ** license from Xilinx, Inc., and may be used, copied                  **
-- ** and/or disclosed only pursuant to the terms of a valid              **
-- ** license agreement with Xilinx, Inc. Xilinx hereby                   **
-- ** grants you a license to use this text/file solely for               **
-- ** design, simulation, implementation and creation of                  **
-- ** design files limited to Xilinx devices or technologies.             **
-- ** Use with non-Xilinx devices or technologies is expressly            **
-- ** prohibited and immediately terminates your license unless           **
-- ** covered by a separate agreement.                                    **
-- **                                                                     **
-- ** Xilinx is providing this design, code, or information               **
-- ** "as-is" solely for use in developing programs and                   **
-- ** solutions for Xilinx devices, with no obligation on the             **
-- ** part of Xilinx to provide support. By providing this design,        **
-- ** code, or information as one possible implementation of              **
-- ** this feature, application or standard, Xilinx is making no          **
-- ** representation that this implementation is free from any            **
-- ** claims of infringement. You are responsible for obtaining           **
-- ** any rights you may require for your implementation.                 **
-- ** Xilinx expressly disclaims any warranty whatsoever with             **
-- ** respect to the adequacy of the implementation, including            **
-- ** but not limited to any warranties or representations that this      **
-- ** implementation is free from claims of infringement, implied         **
-- ** warranties of merchantability or fitness for a particular           **
-- ** purpose.                                                            **
-- **                                                                     **
-- ** Xilinx products are not intended for use in life support            **
-- ** appliances, devices, or systems. Use in such applications is        **
-- ** expressly prohibited.                                               **
-- **                                                                     **
-- ** Any modifications that are made to the Source Code are              **
-- ** done at the user’s sole risk and will be unsupported.               **
-- ** The Xilinx Support Hotline does not have access to source           **
-- ** code and therefore cannot answer specific questions related         **
-- ** to source HDL. The Xilinx Hotline support of original source        **
-- ** code IP shall only address issues and questions related             **
-- ** to the standard Netlist version of the core (and thus               **
-- ** indirectly, the original core source).                              **
-- **                                                                     **
-- ** Copyright (c) 2006-2010 Xilinx, Inc. All rights reserved.           **
-- **                                                                     **
-- ** This copyright and support notice must be retained as part          **
-- ** of this text at all times.                                          **
-- **                                                                     **
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        counter_f.vhd
--
-- Description:     Implements a parameterizable N-bit counter_f
--                      Up/Down Counter
--                      Count Enable
--                      Parallel Load
--                      Synchronous Reset
--                      The structural implementation has incremental cost
--                      of one LUT per bit.
--                      Precedence of operations when simultaneous:
--                        reset, load, count
--
--                  A default inferred-RTL implementation is provided and
--                  is used if the user explicitly specifies C_FAMILY=nofamily
--                  or ommits C_FAMILY (allowing it to default to nofamily).
--                  The default implementation is also used
--                  if needed primitives are not available in FPGAs of the
--                  type given by C_FAMILY.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_com"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.unsigned;
use IEEE.numeric_std."+";
use IEEE.numeric_std."-";

library unisim;
use unisim.all;

-----------------------------------------------------------------------------
-- Entity section
-----------------------------------------------------------------------------

entity counter_f is
    generic(
            C_NUM_BITS : integer := 9;
            C_FAMILY   : string := "nofamily"
           );

    port(
         Clk           : in  std_logic;
         Rst           : in  std_logic;
         Load_In       : in  std_logic_vector(C_NUM_BITS - 1 downto 0);
         Count_Enable  : in  std_logic;
         Count_Load    : in  std_logic;
         Count_Down    : in  std_logic;
         Count_Out     : out std_logic_vector(C_NUM_BITS - 1 downto 0);
         Carry_Out     : out std_logic
        );
end entity counter_f;

-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of counter_f is

    ---------------------------------------------------------------------
    -- Component declarations
    ---------------------------------------------------------------------  
    component MUXCY_L is
      port (
        DI : in  std_logic;
        CI : in  std_logic;
        S  : in  std_logic;
        LO : out std_logic);
    end component MUXCY_L;

    component XORCY is
      port (
        LI : in  std_logic;
        CI : in  std_logic;
        O  : out std_logic);
    end component XORCY;

    component FDRE is
      port (
        Q  : out std_logic;
        C  : in  std_logic;
        CE : in  std_logic;
        D  : in  std_logic;
        R  : in  std_logic
      );
    end component FDRE;
        signal icount_out    : unsigned(C_NUM_BITS downto 0);
        signal icount_out_x  : unsigned(C_NUM_BITS downto 0);
        signal load_in_x     : unsigned(C_NUM_BITS downto 0);

    ---------------------------------------------------------------------
    -- Constant declarations
    ---------------------------------------------------------------------
---------------------------------------------------------------------
-- Begin architecture
---------------------------------------------------------------------
begin
    ---------------------------------------------------------------------
    -- Generate Inferred code
    ---------------------------------------------------------------------
    --INFERRED_GEN : if USE_INFERRED generate



        load_in_x    <= unsigned('0' & Load_In);

        -- Mask out carry position to retain legacy self-clear on next enable.
 --        icount_out_x <= ('0' & icount_out(C_NUM_BITS-1 downto 0)); -- Echeck WA
         icount_out_x <= unsigned('0' & std_logic_vector(icount_out(C_NUM_BITS-1 downto 0)));

        -----------------------------------------------------------------
        -- Process to generate counter with - synchronous reset, load,
        -- counter enable, count down / up features.
        -----------------------------------------------------------------
        CNTR_PROC : process(Clk)
        begin
            if Clk'event and Clk = '1' then
                if Rst = '1' then
                    icount_out <= (others => '0');
                elsif Count_Load = '1' then
                    icount_out <= load_in_x;
                elsif Count_Down = '1'  and Count_Enable = '1' then
                    icount_out <= icount_out_x - 1;
                elsif Count_Enable = '1' then
                    icount_out <= icount_out_x + 1;
                end if;
            end if;
        end process CNTR_PROC;

        Carry_Out <= icount_out(C_NUM_BITS);
        Count_Out <= std_logic_vector(icount_out(C_NUM_BITS-1 downto 0));



end architecture imp;
---------------------------------------------------------------
-- End of file counter_f.vhd
---------------------------------------------------------------


--soft_reset.vhd   v1.01a
-------------------------------------------------------------------------------
--
-- *************************************************************************
-- **                                                                     **
-- ** DISCLAIMER OF LIABILITY                                             **
-- **                                                                     **
-- ** This text/file contains proprietary, confidential                   **
-- ** information of Xilinx, Inc., is distributed under                   **
-- ** license from Xilinx, Inc., and may be used, copied                  **
-- ** and/or disclosed only pursuant to the terms of a valid              **
-- ** license agreement with Xilinx, Inc. Xilinx hereby                   **
-- ** grants you a license to use this text/file solely for               **
-- ** design, simulation, implementation and creation of                  **
-- ** design files limited to Xilinx devices or technologies.             **
-- ** Use with non-Xilinx devices or technologies is expressly            **
-- ** prohibited and immediately terminates your license unless           **
-- ** covered by a separate agreement.                                    **
-- **                                                                     **
-- ** Xilinx is providing this design, code, or information               **
-- ** "as-is" solely for use in developing programs and                   **
-- ** solutions for Xilinx devices, with no obligation on the             **
-- ** part of Xilinx to provide support. By providing this design,        **
-- ** code, or information as one possible implementation of              **
-- ** this feature, application or standard, Xilinx is making no          **
-- ** representation that this implementation is free from any            **
-- ** claims of infringement. You are responsible for obtaining           **
-- ** any rights you may require for your implementation.                 **
-- ** Xilinx expressly disclaims any warranty whatsoever with             **
-- ** respect to the adequacy of the implementation, including            **
-- ** but not limited to any warranties or representations that this      **
-- ** implementation is free from claims of infringement, implied         **
-- ** warranties of merchantability or fitness for a particular           **
-- ** purpose.                                                            **
-- **                                                                     **
-- ** Xilinx products are not intended for use in life support            **
-- ** appliances, devices, or systems. Use in such applications is        **
-- ** expressly prohibited.                                               **
-- **                                                                     **
-- ** Any modifications that are made to the Source Code are              **
-- ** done at the user’s sole risk and will be unsupported.               **
-- ** The Xilinx Support Hotline does not have access to source           **
-- ** code and therefore cannot answer specific questions related         **
-- ** to source HDL. The Xilinx Hotline support of original source        **
-- ** code IP shall only address issues and questions related             **
-- ** to the standard Netlist version of the core (and thus               **
-- ** indirectly, the original core source).                              **
-- **                                                                     **
-- ** Copyright (c) 2006-2010 Xilinx, Inc. All rights reserved.           **
-- **                                                                     **
-- ** This copyright and support notice must be retained as part          **
-- ** of this text at all times.                                          **
-- **                                                                     **
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        soft_reset.vhd
-- Version:         v1_00_a
-- Description:     This VHDL design file is the Soft Reset Service
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
-- Library definitions

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library unisim;
use unisim.vcomponents.all;

-------------------------------------------------------------------------------

entity soft_reset is
    generic (
        C_SIPIF_DWIDTH          : integer := 32;
            -- Width of the write data bus

        C_RESET_WIDTH           : integer := 4     
            -- Width of triggered reset in Bus Clocks
    ); 
    port (
  
        -- Inputs From the IPIF Bus 
        Bus2IP_Reset        : in  std_logic;
        Bus2IP_Clk          : in  std_logic;
        Bus2IP_WrCE         : in  std_logic;
        Bus2IP_Data         : in  std_logic_vector(0 to C_SIPIF_DWIDTH-1);
        Bus2IP_BE           : in  std_logic_vector(0 to (C_SIPIF_DWIDTH/8)-1);

        -- Final Device Reset Output
        Reset2IP_Reset      : out std_logic; 

        -- Status Reply Outputs to the Bus 
        Reset2Bus_WrAck     : out std_logic;
        Reset2Bus_Error     : out std_logic;
        Reset2Bus_ToutSup   : out std_logic
    
    );
  end soft_reset ;
  
  

-------------------------------------------------------------------------------

architecture implementation of soft_reset is

-------------------------------------------------------------------------------
-- Function Declarations 
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Type Declarations
-------------------------------------------------------------------------------
    
-------------------------------------------------------------------------------
-- Constant Declarations
-------------------------------------------------------------------------------

-- Module Software Reset screen value for write data
-- This requires a Hex 'A' to be written to ativate the S/W reset port
constant RESET_MATCH    : std_logic_vector(0 to 3) := "1010"; 
                                                           
-- Required BE index to be active during Reset activation
constant BE_MATCH       : integer := 3; 
                                                            
-------------------------------------------------------------------------------
-- Signal Declarations
-------------------------------------------------------------------------------

signal sm_reset         : std_logic;
signal error_reply      : std_logic;
signal reset_wrack      : std_logic;
signal reset_error      : std_logic;
signal reset_trig       : std_logic;
signal wrack            : std_logic;
signal wrack_ff_chain   : std_logic;
signal flop_q_chain     : std_logic_vector(0 to C_RESET_WIDTH);
--signal bus2ip_wrce_d1   : std_logic;

signal data_is_non_reset_match  : std_logic;
signal sw_rst_cond              : std_logic;
signal sw_rst_cond_d1           : std_logic;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
  
begin
           
-- Misc assignments         
Reset2Bus_WrAck     <= reset_wrack;
Reset2Bus_Error     <= reset_error;
Reset2Bus_ToutSup   <= sm_reset; -- Suppress a data phase timeout when
                                 -- a commanded reset is active.

reset_wrack         <=  (reset_error or wrack);-- and Bus2IP_WrCE;
reset_error         <=  data_is_non_reset_match and Bus2IP_WrCE;
Reset2IP_Reset      <=  Bus2IP_Reset or sm_reset;
      
---------------------------------------------------------------------------------
---- Register WRCE for use in creating a strobe pulse
---------------------------------------------------------------------------------
--REG_WRCE : process(Bus2IP_Clk)
--    begin
--        if(Bus2IP_Clk'EVENT and Bus2IP_Clk = '1')then
--            if(Bus2IP_Reset = '1')then
--                bus2ip_wrce_d1 <= '0';
--            else
--                bus2ip_wrce_d1 <= Bus2IP_WrCE;
--            end if;
--        end if;
--    end process REG_WRCE;
--
-------------------------------------------------------------------------------
-- Start the S/W reset state machine as a result of an IPIF Bus write to
-- the Reset port and the data on the DBus inputs matching the Reset 
-- match value. If the value on the data bus input does not match the 
-- designated reset key, an error acknowledge is generated.
-------------------------------------------------------------------------------
--DETECT_SW_RESET : process (Bus2IP_Clk)
--    begin
--        if(Bus2IP_Clk'EVENT and Bus2IP_Clk = '1') then
--            if (Bus2IP_Reset = '1') then
--                error_reply       <= '0';
--                reset_trig        <= '0';
--            elsif (Bus2IP_WrCE = '1' 
--            and Bus2IP_BE(BE_MATCH) = '1'
--            and Bus2IP_Data(28 to 31) = RESET_MATCH) then
--                error_reply       <= '0';
--                reset_trig        <= Bus2IP_WrCE and not bus2ip_wrce_d1;
--            elsif (Bus2IP_WrCE = '1') then 
--                error_reply       <= '1';
--                reset_trig        <= '0';
--            else
--                error_reply       <= '0';
--                reset_trig        <= '0';
--            end if;
--        end if;
--    end process DETECT_SW_RESET;


    data_is_non_reset_match <=
        '0' when (Bus2IP_Data(C_SIPIF_DWIDTH-4 to C_SIPIF_DWIDTH-1) = RESET_MATCH
             and Bus2IP_BE(BE_MATCH) = '1')
        else '1';

--------------------------------------------------------------------------------
-- SW Reset
--------------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    sw_rst_cond <= Bus2IP_WrCE and not data_is_non_reset_match;
    --
    RST_PULSE_PROC : process (Bus2IP_Clk)
    Begin
       if (Bus2IP_Clk'EVENT and Bus2IP_Clk = '1') Then
           if (Bus2IP_Reset = '1') Then
              sw_rst_cond_d1    <= '0';
              reset_trig        <= '0';
           else
              sw_rst_cond_d1    <= sw_rst_cond;
              reset_trig        <= sw_rst_cond and not sw_rst_cond_d1;
           end if;
       end if;
    End process;

        
-------------------------------------------------------------------------------
-- RESET_FLOPS:
-- This FORGEN implements the register chain used to create 
-- the parameterizable reset pulse width.
-------------------------------------------------------------------------------
RESET_FLOPS : for index in 0 to C_RESET_WIDTH-1 generate

    flop_q_chain(0) <= '0';

    RST_FLOPS : FDRSE
        port map(
            Q   =>  flop_q_chain(index+1), -- :    out std_logic;
            C   =>  Bus2IP_Clk,            -- :    in  std_logic;
            CE  =>  '1',                   -- :    in  std_logic;
            D   =>  flop_q_chain(index),   -- :    in  std_logic;    
            R   =>  Bus2IP_Reset,          -- :    in  std_logic;
            S   =>  reset_trig             -- :    in  std_logic
        );

end generate RESET_FLOPS;

    
-- Use the last flop output for the commanded reset pulse 
sm_reset        <= flop_q_chain(C_RESET_WIDTH);

wrack_ff_chain  <= flop_q_chain(C_RESET_WIDTH) and 
                    not(flop_q_chain(C_RESET_WIDTH-1));


-- Register the Write Acknowledge for the Reset write
-- This is generated at the end of the reset pulse. This
-- keeps the Slave busy until the commanded reset completes.
FF_WRACK : FDRSE
    port map(
        Q   =>  wrack,            -- :  out std_logic;
        C   =>  Bus2IP_Clk,       -- :  in  std_logic;
        CE  =>  '1',              -- :  in  std_logic;
        D   =>  wrack_ff_chain,   -- :  in  std_logic;    
        R   =>  Bus2IP_Reset,     -- :  in  std_logic;
        S   =>  '0'               -- :  in  std_logic
    );


end implementation;


 








-------------------------------------------------------------------------------
-- xip_cross_clk_sync.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
-------------------------------------------------------------------------------
-- Filename:        xip_cross_clk_sync.vhd
-- Version:         v3.0
-- Description:     This is the CDC file for XIP mode
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
--
-- History:
-- ~~~~~~
--  SK 19/01/11  -- created v2.00.a version
-- ^^^^^^
-- 1. Created second version of the core.
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.conv_std_logic_vector;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_signed.all;
    use ieee.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
    use ieee.std_logic_unsigned.all;


library axi_lite_ipif_v3_0_4;
use axi_lite_ipif_v3_0_4.axi_lite_ipif;
use axi_lite_ipif_v3_0_4.ipif_pkg.all;
library lib_fifo_v1_0_6;
    use lib_fifo_v1_0_6.async_fifo_fg;
library lib_cdc_v1_0_2;
	use lib_cdc_v1_0_2.cdc_sync;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
library unisim;
    use unisim.vcomponents.FDRE;
    use unisim.vcomponents.FDR;
-------------------------------------------------------------------------------
entity xip_cross_clk_sync is
     generic (
             C_S_AXI4_DATA_WIDTH          : integer;
             C_SPI_MEM_ADDR_BITS          : integer;
			 Async_Clk                    : integer ;

             C_NUM_SS_BITS                : integer
     );
     port (
              EXT_SPI_CLK               : in std_logic;

              S_AXI4_ACLK               : in std_logic;
              S_AXI4_ARESET             : in std_logic;

              S_AXI_ACLK                : in std_logic;
              S_AXI_ARESETN             : in std_logic;

              Rst_from_axi_cdc_to_spi       : in std_logic;
              ----------------------------
              spiXfer_done_cdc_from_spi      : in std_logic;
              spiXfer_done_cdc_to_axi_1     : out std_logic;
              ----------------------------
              mst_modf_err_cdc_from_spi      : in std_logic;
              mst_modf_err_cdc_to_axi       : out std_logic;
              mst_modf_err_cdc_to_axi4      : out std_logic;
              ----------------------------
              one_byte_xfer_cdc_from_axi     : in std_logic;
              one_byte_xfer_cdc_to_spi      : out std_logic;
              ----------------------
              two_byte_xfer_cdc_from_axi     : in std_logic;
              two_byte_xfer_cdc_to_spi      : out std_logic;
              ----------------------
              four_byte_xfer_cdc_from_axi    : in std_logic;
              four_byte_xfer_cdc_to_spi     : out std_logic;
              ----------------------
              Transmit_Addr_cdc_from_axi     : in std_logic_vector(C_SPI_MEM_ADDR_BITS-1 downto 0);
              Transmit_Addr_cdc_to_spi      : out std_logic_vector(C_SPI_MEM_ADDR_BITS-1 downto 0);
              ----------------------
              load_cmd_cdc_from_axi          : in std_logic;
              load_cmd_cdc_to_spi           : out std_logic;
              --------------------------
              CPOL_cdc_from_axi              : in std_logic;
              CPOL_cdc_to_spi               : out std_logic;
              --------------------------
              CPHA_cdc_from_axi              : in std_logic;
              CPHA_cdc_to_spi               : out std_logic;
              --------------------------
              SS_cdc_from_axi                : in std_logic_vector((C_NUM_SS_BITS-1) downto 0);
              SS_cdc_to_spi                 : out std_logic_vector((C_NUM_SS_BITS-1) downto 0);
              --------------------------
              type_of_burst_cdc_from_axi     : in std_logic;-- _vector(1 downto 0);
              type_of_burst_cdc_to_spi      : out std_logic;-- _vector(1 downto 0);
              --------------------------
              axi_length_cdc_from_axi        : in std_logic_vector(7 downto 0);
              axi_length_cdc_to_spi         : out std_logic_vector(7 downto 0);
              --------------------------
              dtr_length_cdc_from_axi        : in std_logic_vector(7 downto 0);
              dtr_length_cdc_to_spi         : out std_logic_vector(7 downto 0);
              --------------------------
              load_axi_data_cdc_from_axi     : in std_logic;
              load_axi_data_cdc_to_spi      : out std_logic;
              ------------------------------
              Rx_FIFO_Full_cdc_from_spi      : in std_logic;
              Rx_FIFO_Full_cdc_to_axi       : out std_logic;
              Rx_FIFO_Full_cdc_to_axi4      : out std_logic;
              ------------------------------
              wb_hpm_done_cdc_from_spi       : in std_logic;
              wb_hpm_done_cdc_to_axi        : out std_logic

);
end entity xip_cross_clk_sync;
-------------------------------------------------------------------------------
architecture imp of xip_cross_clk_sync is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

signal size_length_cdc_to_spi_d1 : std_logic_vector(1 downto 0);
signal size_length_cdc_to_spi_d2 : std_logic_vector(1 downto 0);

signal spiXfer_done_d1            : std_logic;
signal spiXfer_done_d2            : std_logic;
signal spiXfer_done_d3            : std_logic;
signal spiXfer_done_cdc_from_spi_int_2 : std_logic;
signal byte_xfer_cdc_from_axi_d1       : std_logic;
signal byte_xfer_cdc_from_axi_d2       : std_logic;

signal hw_xfer_cdc_from_axi_d1         : std_logic;
signal hw_xfer_cdc_from_axi_d2         : std_logic;

signal word_xfer_cdc_from_axi_d1  : std_logic;
signal word_xfer_cdc_from_axi_d2  : std_logic;

signal SS_cdc_from_spi_d1 : std_logic_vector((C_NUM_SS_BITS-1) downto 0);
signal SS_cdc_from_spi_d2 : std_logic_vector((C_NUM_SS_BITS-1) downto 0);

signal mst_modf_err_d1 : std_logic;
signal mst_modf_err_d2 : std_logic;
signal mst_modf_err_d3 : std_logic;
signal mst_modf_err_d4 : std_logic;


signal dtr_length_cdc_from_axi_d1 : std_logic_vector(7 downto 0);
signal dtr_length_cdc_from_axi_d2 : std_logic_vector(7 downto 0);

signal axi_length_cdc_to_spi_d1 : std_logic_vector(7 downto 0);
signal axi_length_cdc_to_spi_d2 : std_logic_vector(7 downto 0);


signal CPOL_cdc_to_spi_d1 : std_logic;
signal CPOL_cdc_to_spi_d2 : std_logic;

signal CPHA_cdc_to_spi_d1 : std_logic;
signal CPHA_cdc_to_spi_d2 : std_logic;

signal load_axi_data_cdc_to_spi_d1 : std_logic;
signal load_axi_data_cdc_to_spi_d2 : std_logic;
signal load_axi_data_cdc_to_spi_d3 : std_logic;
signal Transmit_Addr_cdc_from_axi_d1 : std_logic_vector(C_SPI_MEM_ADDR_BITS-1 downto 0);
signal Transmit_Addr_cdc_from_axi_d2 : std_logic_vector(C_SPI_MEM_ADDR_BITS-1 downto 0);

signal type_of_burst_cdc_to_spi_d1 : std_logic;-- _vector(1 downto 0);
signal type_of_burst_cdc_to_spi_d2 : std_logic;-- _vector(1 downto 0);

     signal load_cmd_cdc_from_axi_d1 : std_logic;
     signal load_cmd_cdc_from_axi_d2 : std_logic;
     signal load_cmd_cdc_from_axi_d3 : std_logic;
     signal load_cmd_cdc_from_axi_int_2    : std_logic;

signal rx_fifo_full_d1 : std_logic;
signal rx_fifo_full_d2 : std_logic;
signal rx_fifo_full_d3 : std_logic;
signal rx_fifo_full_d4 : std_logic;
signal ld_axi_data_cdc_from_axi_int_2 : std_logic;
signal wb_hpm_done_cdc_from_spi_d1 : std_logic;
signal wb_hpm_done_cdc_from_spi_d2 : std_logic;



-- attribute ASYNC_REG : string;
-- attribute ASYNC_REG of XFER_DONE_SYNC_SPI2AXI     : label is "TRUE";
-- attribute ASYNC_REG of MST_MODF_SYNC_SPI2AXI      : label is "TRUE";
-- attribute ASYNC_REG of MST_MODF_SYNC_SPI2AXI4     : label is "TRUE";
-- attribute ASYNC_REG of BYTE_XFER_SYNC_AXI2SPI     : label is "TRUE";
-- attribute ASYNC_REG of HW_XFER_SYNC_AXI2SPI       : label is "TRUE";
-- attribute ASYNC_REG of WORD_XFER_SYNC_AXI2SPI     : label is "TRUE";
-- attribute ASYNC_REG of TYP_OF_XFER_SYNC_AXI2SPI   : label is "TRUE";
-- attribute ASYNC_REG of LD_AXI_DATA_SYNC_AXI2SPI   : label is "TRUE";
-- attribute ASYNC_REG of LD_CMD_SYNC_AXI2SPI        : label is "TRUE";

-- -- attribute ASYNC_REG of TRANSMIT_DATA_SYNC_AXI_2_SPI_1          : label is "TRUE";
-- attribute ASYNC_REG of CPOL_SYNC_AXI2SPI          : label is "TRUE";
-- attribute ASYNC_REG of CPHA_SYNC_AXI2SPI          : label is "TRUE";
-- attribute ASYNC_REG of Rx_FIFO_Full_SYNC_SPI2AXI  : label is "TRUE";
-- attribute ASYNC_REG of Rx_FIFO_Full_SYNC_SPI2AXI4 : label is "TRUE";
-- attribute ASYNC_REG of WB_HPM_DONE_SYNC_SPI2AXI   : label is "TRUE";

attribute KEEP : string;
attribute KEEP of SS_cdc_from_spi_d2              : signal is "TRUE";
attribute KEEP of load_axi_data_cdc_to_spi_d3    : signal is "TRUE";
attribute KEEP of load_axi_data_cdc_to_spi_d2    : signal is "TRUE";
attribute KEEP of type_of_burst_cdc_to_spi_d2    : signal is "TRUE";
attribute KEEP of rx_fifo_full_d2            : signal is "TRUE";
attribute KEEP of CPHA_cdc_to_spi_d2             : signal is "TRUE";
attribute KEEP of CPOL_cdc_to_spi_d2             : signal is "TRUE";
attribute KEEP of Transmit_Addr_cdc_from_axi_d2   : signal is "TRUE";
attribute KEEP of load_cmd_cdc_from_axi_d3        : signal is "TRUE";
attribute KEEP of load_cmd_cdc_from_axi_d2        : signal is "TRUE";
attribute KEEP of word_xfer_cdc_from_axi_d2       : signal is "TRUE";
attribute KEEP of hw_xfer_cdc_from_axi_d2         : signal is "TRUE";
attribute KEEP of byte_xfer_cdc_from_axi_d2       : signal is "TRUE";
attribute KEEP of mst_modf_err_d2            : signal is "TRUE";
attribute KEEP of mst_modf_err_d4            : signal is "TRUE";
attribute KEEP of spiXfer_done_d2            : signal is "TRUE";
attribute KEEP of spiXfer_done_d3            : signal is "TRUE";
attribute KEEP of axi_length_cdc_to_spi_d2	     : signal is "TRUE";
attribute KEEP of dtr_length_cdc_from_axi_d2     : signal is "TRUE";

constant LOGIC_CHANGE : integer range 0 to 1 := 1;
constant MTBF_STAGES_AXI2S : integer range 0 to 6 := 3 ;
constant MTBF_STAGES_S2AXI : integer range 0 to 6 := 4 ;
-----
begin

LOGIC_GENERATION_FDR : if (Async_Clk = 0) generate
-----
SPI_XFER_DONE_STRETCH_1: process(EXT_SPI_CLK)is
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
           if(Rst_from_axi_cdc_to_spi = '1') then
                   spiXfer_done_cdc_from_spi_int_2 <= '0';
           else
                   spiXfer_done_cdc_from_spi_int_2 <= spiXfer_done_cdc_from_spi xor
                                                 spiXfer_done_cdc_from_spi_int_2;
           end if;
     end if;
end process SPI_XFER_DONE_STRETCH_1;

XFER_DONE_SYNC_SPI2AXI: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => spiXfer_done_d1,
                         C  => S_AXI4_ACLK,
                         D  => spiXfer_done_cdc_from_spi_int_2,
                         R  => S_AXI4_ARESET
                       );
FER_DONE_SYNC_SPI2AXI_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => spiXfer_done_d2,
                         C  => S_AXI4_ACLK,
                         D  => spiXfer_done_d1,
                         R  => S_AXI4_ARESET
                       );
FER_DONE_SYNC_SPI2AXI_2: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => spiXfer_done_d3,
                         C  => S_AXI4_ACLK,
                         D  => spiXfer_done_d2,
                         R  => S_AXI4_ARESET
                       );
spiXfer_done_cdc_to_axi_1 <= spiXfer_done_d2 xor spiXfer_done_d3;
-------------------------------------------------------------------------------
MST_MODF_SYNC_SPI2AXI: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => mst_modf_err_d1,
                         C  => S_AXI_ACLK,
                         D  => mst_modf_err_cdc_from_spi,
                         R  => S_AXI_ARESETN
                       );
MST_MODF_SYNC_SPI2AXI_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => mst_modf_err_d2,
                         C  => S_AXI_ACLK,
                         D  => mst_modf_err_d1,
                         R  => S_AXI_ARESETN
                       );
mst_modf_err_cdc_to_axi <= mst_modf_err_d2;
-------------------------------------------------------------------------------
MST_MODF_SYNC_SPI2AXI4: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => mst_modf_err_d3,
                         C  => S_AXI4_ACLK,
                         D  => mst_modf_err_cdc_from_spi,
                         R  => S_AXI4_ARESET
                       );
MST_MODF_SYNC_SPI2AXI4_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => mst_modf_err_d4,
                         C  => S_AXI4_ACLK,
                         D  => mst_modf_err_d3,
                         R  => S_AXI4_ARESET
                       );
mst_modf_err_cdc_to_axi4 <= mst_modf_err_d4;
-------------------------------------------------------------------------------
BYTE_XFER_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => byte_xfer_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => one_byte_xfer_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     BYTE_XFER_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => byte_xfer_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => byte_xfer_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );

     one_byte_xfer_cdc_to_spi <= byte_xfer_cdc_from_axi_d2;
     ------------------------------------------------
     HW_XFER_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => hw_xfer_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => two_byte_xfer_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     HW_XFER_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => hw_xfer_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => hw_xfer_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );

     two_byte_xfer_cdc_to_spi <= hw_xfer_cdc_from_axi_d2;
     ------------------------------------------------
     WORD_XFER_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => word_xfer_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => four_byte_xfer_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     WORD_XFER_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => word_xfer_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => word_xfer_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );

     four_byte_xfer_cdc_to_spi <= word_xfer_cdc_from_axi_d2;
     ------------------------------------------------
     LD_CMD_cdc_from_AXI_STRETCH: process(S_AXI4_ACLK)is
     begin
     -----
          if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1')then
                if(S_AXI4_ARESET = '1')then
                    load_cmd_cdc_from_axi_int_2 <= '0';
                else
                    load_cmd_cdc_from_axi_int_2 <= load_cmd_cdc_from_axi xor load_cmd_cdc_from_axi_int_2;
                end if;
          end if;
     end process LD_CMD_cdc_from_AXI_STRETCH;
     -------------------------------------
-- from AXI4 to SPI
LD_CMD_SYNC_AXI2SPI: component FDR
                   port map (
                              Q  => load_cmd_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => load_cmd_cdc_from_axi_int_2,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     LD_CMD_SYNC_AXI2SPI_1: component FDR
                   port map (
                              Q  => load_cmd_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => load_cmd_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     LD_CMD_SYNC_AXI2SPI_2: component FDR
                   port map (
                              Q  => load_cmd_cdc_from_axi_d3,
                              C  => EXT_SPI_CLK,
                              D  => load_cmd_cdc_from_axi_d2,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     load_cmd_cdc_to_spi          <= load_cmd_cdc_from_axi_d3 xor
                                 load_cmd_cdc_from_axi_d2;
     --------------------------------------------------------------------------
-- from AXI4 to SPI
     TRANS_ADDR_SYNC_GEN: for i in C_SPI_MEM_ADDR_BITS-1 downto 0 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of TRANS_ADDR_SYNC_AXI2SPI_CDC  : label is "TRUE";

     -----
     begin
     -----
     TRANS_ADDR_SYNC_AXI2SPI_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Transmit_Addr_cdc_from_axi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => Transmit_Addr_cdc_from_axi(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     TRANS_ADDR_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Transmit_Addr_cdc_from_axi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => Transmit_Addr_cdc_from_axi_d1(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     end generate TRANS_ADDR_SYNC_GEN;
     -- Transmit_Addr_cdc_to_spi <= Transmit_Addr_cdc_from_axi_d2; -- 4/19/2013
     Transmit_Addr_cdc_to_spi <= Transmit_Addr_cdc_from_axi_d1; -- 4/19/2013
     ------------------------------------------------
     -- from AXI4 Lite to SPI
     CPOL_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => CPOL_cdc_to_spi_d1,
                              C  => EXT_SPI_CLK,
                              D  => CPOL_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     CPOL_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => CPOL_cdc_to_spi_d2,
                              C  => EXT_SPI_CLK,
                              D  => CPOL_cdc_to_spi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     CPOL_cdc_to_spi <= CPOL_cdc_to_spi_d2;
     ------------------------------------------------
     -- from AXI4 Lite to SPI
     CPHA_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => CPHA_cdc_to_spi_d1,
                              C  => EXT_SPI_CLK,
                              D  => CPHA_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     CPHA_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => CPHA_cdc_to_spi_d2,
                              C  => EXT_SPI_CLK,
                              D  => CPHA_cdc_to_spi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     CPHA_cdc_to_spi <= CPHA_cdc_to_spi_d2;
     ------------------------------------------------
     LD_AXI_DATA_STRETCH: process(S_AXI4_ACLK)is
     begin
     -----
          if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1')then
                if(S_AXI4_ARESET = '1')then
                    ld_axi_data_cdc_from_axi_int_2 <= '0';
                else
                    ld_axi_data_cdc_from_axi_int_2 <= load_axi_data_cdc_from_axi xor
                                                 ld_axi_data_cdc_from_axi_int_2;
                end if;
          end if;
     end process LD_AXI_DATA_STRETCH;
     -------------------------------------
     LD_AXI_DATA_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => load_axi_data_cdc_to_spi_d1,
                              C  => EXT_SPI_CLK,
                              D  => ld_axi_data_cdc_from_axi_int_2,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     LD_AXI_DATA_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => load_axi_data_cdc_to_spi_d2,
                              C  => EXT_SPI_CLK,
                              D  => load_axi_data_cdc_to_spi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     LD_AXI_DATA_SYNC_AXI2SPI_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => load_axi_data_cdc_to_spi_d3,
                              C  => EXT_SPI_CLK,
                              D  => load_axi_data_cdc_to_spi_d2,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     load_axi_data_cdc_to_spi <= load_axi_data_cdc_to_spi_d3 xor load_axi_data_cdc_to_spi_d2;
     ------------------------------------------------
     SS_SYNC_AXI_SPI_GEN: for i in (C_NUM_SS_BITS-1) downto 0 generate
     ---------------------
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of SS_SYNC_AXI2SPI_CDC : label is "TRUE";
     begin
     -----
          SS_SYNC_AXI2SPI_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SS_cdc_from_spi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => SS_cdc_from_axi(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
          SS_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SS_cdc_from_spi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => SS_cdc_from_spi_d1(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     end generate SS_SYNC_AXI_SPI_GEN;

     SS_cdc_to_spi <= SS_cdc_from_spi_d2;
     ------------------------------------------------------------------------
     TYP_OF_XFER_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => type_of_burst_cdc_to_spi_d1,
                              C  => EXT_SPI_CLK,
                              D  => type_of_burst_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     TYP_OF_XFER_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => type_of_burst_cdc_to_spi_d2,
                              C  => EXT_SPI_CLK,
                              D  => type_of_burst_cdc_to_spi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     --end generate TYP_OF_XFER_GEN;
     ------------------------------
     type_of_burst_cdc_to_spi   <= type_of_burst_cdc_to_spi_d2;
     ------------------------------------------------
     AXI_LEN_SYNC_AXI_SPI_GEN: for i in 7 downto 0 generate
     ---------------------
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of AXI_LEN_SYNC_AXI2SPI : label is "TRUE";
     begin
     -----
          AXI_LEN_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => axi_length_cdc_to_spi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => axi_length_cdc_from_axi(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
          AXI_LEN_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => axi_length_cdc_to_spi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => axi_length_cdc_to_spi_d1(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     end generate AXI_LEN_SYNC_AXI_SPI_GEN;
     axi_length_cdc_to_spi <= axi_length_cdc_to_spi_d2;
     ------------------------------------------------------------------------
     DTR_LEN_SYNC_AXI_SPI_GEN: for i in 7 downto 0 generate
     ---------------------
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of DTR_LEN_SYNC_AXI2SPI : label is "TRUE";
     begin
     -----
          DTR_LEN_SYNC_AXI2SPI: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => dtr_length_cdc_from_axi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => dtr_length_cdc_from_axi(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
          DTR_LEN_SYNC_AXI2SPI_1: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => dtr_length_cdc_from_axi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => dtr_length_cdc_from_axi_d1(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     end generate DTR_LEN_SYNC_AXI_SPI_GEN;
     dtr_length_cdc_to_spi <= dtr_length_cdc_from_axi_d2;
     ------------------------------------------------------------------------
-- from SPI to AXI Lite
Rx_FIFO_Full_SYNC_SPI2AXI: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => rx_fifo_full_d1,
                         C  => S_AXI_ACLK,
                         D  => Rx_FIFO_Full_cdc_from_spi,
                         R  => S_AXI_ARESETN
                       );
Rx_FIFO_Full_SYNC_SPI2AXI_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => rx_fifo_full_d2,
                         C  => S_AXI_ACLK,
                         D  => rx_fifo_full_d1,
                         R  => S_AXI_ARESETN
                       );
Rx_FIFO_Full_cdc_to_axi <= rx_fifo_full_d2;
-------------------------------------------------------------------------------
-- from SPI to AXI4
Rx_FIFO_Full_SYNC_SPI2AXI4: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => rx_fifo_full_d3,
                         C  => S_AXI4_ACLK,
                         D  => Rx_FIFO_Full_cdc_from_spi,
                         R  => S_AXI4_ARESET
                       );
Rx_FIFO_Full_SYNC_SPI2AXI4_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => rx_fifo_full_d4,
                         C  => S_AXI4_ACLK,
                         D  => rx_fifo_full_d3,
                         R  => S_AXI4_ARESET
                       );
Rx_FIFO_Full_cdc_to_axi4 <= rx_fifo_full_d4;
-------------------------------------------------------------------------------
-- from SPI to AXI4
WB_HPM_DONE_SYNC_SPI2AXI: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => wb_hpm_done_cdc_from_spi_d1,
                         C  => S_AXI4_ACLK,
                         D  => wb_hpm_done_cdc_from_spi,
                         R  => S_AXI4_ARESET
                       );
WB_HPM_DONE_SYNC_SPI2AXI_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => wb_hpm_done_cdc_from_spi_d2,
                         C  => S_AXI4_ACLK,
                         D  => wb_hpm_done_cdc_from_spi_d1,
                         R  => S_AXI4_ARESET
                       );
wb_hpm_done_cdc_to_axi <= wb_hpm_done_cdc_from_spi_d2;
-------------------------------------------------------------------------------
end generate LOGIC_GENERATION_FDR;


LOGIC_GENERATION_CDC : if (Async_Clk = 1) generate
-------------------------------------------------------------------------------
SPI_XFER_DONE_STRETCH_1: process(EXT_SPI_CLK)is
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
     
           if(Rst_from_axi_cdc_to_spi = '1') then
                   spiXfer_done_cdc_from_spi_int_2 <= '0';
				   --spiXfer_done_d1            <= '0';
           else
                   spiXfer_done_cdc_from_spi_int_2 <= spiXfer_done_cdc_from_spi xor spiXfer_done_cdc_from_spi_int_2;
				   --spiXfer_done_d1            <= spiXfer_done_cdc_from_spi_int_2;
           end if;
     end if;
end process SPI_XFER_DONE_STRETCH_1;

XFER_DONE_SYNC_SPI2AXI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 1 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => spiXfer_done_cdc_from_spi_int_2,--spiXfer_done_d1 ,
        scndry_aclk          => S_AXI4_ACLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => S_AXI4_ARESET ,
        scndry_out            => spiXfer_done_d2
    ); 
	
	SPI_XFER_DONE_STRETCH_1_CDC: process(S_AXI4_ACLK)is
begin
-----
     if(S_AXI4_ACLK'event and S_AXI4_ACLK= '1') then
     
           if(S_AXI4_ARESET = '1') then
                   spiXfer_done_d3 <= '0';
				  
           else
                   spiXfer_done_d3 <= spiXfer_done_d2 ;
           end if;
     end if;
end process SPI_XFER_DONE_STRETCH_1_CDC;

spiXfer_done_cdc_to_axi_1 <= spiXfer_done_d2 xor spiXfer_done_d3;
-------------------------------------------------------------------------------

MST_MODF_SYNC_SPI2AXI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => S_AXI_ACLK , 
        prmry_resetn         => S_AXI_ARESETN ,
        prmry_in             => mst_modf_err_cdc_from_spi ,
        scndry_aclk          => S_AXI_ACLK ,
	    prmry_vect_in        => (others => '0' ), 
        scndry_resetn        => S_AXI_ARESETN ,
        scndry_out           => mst_modf_err_cdc_to_axi
    ); 
-------------------------------------------------------------------------------


MST_MODF_SYNC_SPI2AXI4_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI4_ARESET ,
        prmry_in             => mst_modf_err_cdc_from_spi ,
        scndry_aclk          => S_AXI4_ACLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => S_AXI4_ARESET ,
        scndry_out           => mst_modf_err_cdc_to_axi4
    ); 
-------------------------------------------------------------------------------

BYTE_XFER_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => one_byte_xfer_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
		prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => one_byte_xfer_cdc_to_spi
    ); 
-------------------------------------------------------------------------------
HW_XFER_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => two_byte_xfer_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
		prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => two_byte_xfer_cdc_to_spi
    ); 
-------------------------------------------------------------------------------

WORD_XFER_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => four_byte_xfer_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => four_byte_xfer_cdc_to_spi
    ); 
-------------------------------------------------------------------------------

LD_CMD_cdc_from_AXI_STRETCH_CDC: process(S_AXI4_ACLK)is
     begin
     -----
          if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1')then
                if(S_AXI4_ARESET = '1')then
                    load_cmd_cdc_from_axi_int_2 <= '0';
                    --load_cmd_cdc_from_axi_d1    <= '0';
                else
                    load_cmd_cdc_from_axi_int_2 <= load_cmd_cdc_from_axi xor load_cmd_cdc_from_axi_int_2;
                    --load_cmd_cdc_from_axi_d1    <= load_cmd_cdc_from_axi_int_2;
                end if;
          end if;
     end process LD_CMD_cdc_from_AXI_STRETCH_CDC;

 LD_CMD_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 1 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI4_ARESET ,
        prmry_in             => load_cmd_cdc_from_axi_int_2,--load_cmd_cdc_from_axi_d1 ,
        scndry_aclk          => EXT_SPI_CLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out            => load_cmd_cdc_from_axi_d2
    ); 
	
	LD_CMD_cdc_from_AXI_STRETCH: process(EXT_SPI_CLK)is
     begin
     -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                if(Rst_from_axi_cdc_to_spi = '1')then
                    load_cmd_cdc_from_axi_d3 <= '0';
                    
                else
                    load_cmd_cdc_from_axi_d3 <= load_cmd_cdc_from_axi_d2;
                end if;
          end if;
     end process LD_CMD_cdc_from_AXI_STRETCH;
     
          load_cmd_cdc_to_spi          <= load_cmd_cdc_from_axi_d3 xor
                                 load_cmd_cdc_from_axi_d2;
-------------------------------------------------------------------------------

  

TRANS_ADDR_SYNC_GEN_CDC: for i in C_SPI_MEM_ADDR_BITS-1 downto 0 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of TRANS_ADDR_SYNC_AXI2SPI_CDC  : label is "TRUE";

     -----
     begin
     -----
     
 TRANS_ADDR_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 ,-- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK,
        prmry_resetn         => Rst_from_axi_cdc_to_spi,
        prmry_in             => Transmit_Addr_cdc_from_axi(i),
        scndry_aclk          => EXT_SPI_CLK, 
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi,
        scndry_out           => Transmit_Addr_cdc_from_axi_d2(i)
    );
    
    end generate TRANS_ADDR_SYNC_GEN_CDC;
    Transmit_Addr_cdc_to_spi <= Transmit_Addr_cdc_from_axi_d2;
-------------------------------------------------------------------------------


CPOL_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch 
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => CPOL_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => CPOL_cdc_to_spi
    ); 
	
	-------------------------------------------------------------------------------
	
		
   CPHA_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => CPHA_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => CPHA_cdc_to_spi
    ); 
    -------------------------------------------------------------------------------
    
    LD_AXI_DATA_STRETCH_CDC: process(S_AXI4_ACLK)is
         begin
         -----
              if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1')then
                    if(S_AXI4_ARESET = '1')then
                        ld_axi_data_cdc_from_axi_int_2 <= '0';
                        --load_axi_data_cdc_to_spi_d1   <= '0';
                    else
                        ld_axi_data_cdc_from_axi_int_2 <= load_axi_data_cdc_from_axi xor
                                                 ld_axi_data_cdc_from_axi_int_2;
                       -- load_axi_data_cdc_to_spi_d1   <= ld_axi_data_cdc_from_axi_int_2;
                    end if;
              end if;
     end process LD_AXI_DATA_STRETCH_CDC;
    
   LD_AXI_DATA_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 1 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI4_ARESET ,
        prmry_in             => ld_axi_data_cdc_from_axi_int_2,--load_axi_data_cdc_to_spi_d1 ,
	prmry_vect_in        => (others => '0' ),
        scndry_aclk          => EXT_SPI_CLK ,
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out            => load_axi_data_cdc_to_spi_d2
    ); 
	
	LD_AXI_DATA_STRETCH: process(EXT_SPI_CLK)is
         begin
         -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                    if(Rst_from_axi_cdc_to_spi = '1')then
                        load_axi_data_cdc_to_spi_d3 <= '0';
                        
                    else
                        load_axi_data_cdc_to_spi_d3 <= load_axi_data_cdc_to_spi_d2 ;
                    end if;
              end if;
     end process LD_AXI_DATA_STRETCH;
     
      load_axi_data_cdc_to_spi <= load_axi_data_cdc_to_spi_d3 xor load_axi_data_cdc_to_spi_d2;
	---------------------------------------------------------------------------------------
	
	     
	SS_SYNC_AXI_SPI_GEN_CDC: for i in (C_NUM_SS_BITS-1) downto 0 generate
	     ---------------------
	     attribute ASYNC_REG : string;
	     attribute ASYNC_REG of SS_SYNC_AXI2SPI_CDC : label is "TRUE";
     begin
    SS_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK,
        prmry_resetn         => Rst_from_axi_cdc_to_spi,
        prmry_in             => SS_cdc_from_axi(i),
        scndry_aclk          => EXT_SPI_CLK, 
        scndry_resetn        => Rst_from_axi_cdc_to_spi,
	    prmry_vect_in        => (others => '0' ),
        scndry_out           => SS_cdc_from_spi_d2(i)
    );
    end generate SS_SYNC_AXI_SPI_GEN_CDC;
    SS_cdc_to_spi <= SS_cdc_from_spi_d2;
    
     ------------------------------------------------------------------------------------------
     
       
	 
	 TYP_OF_XFER_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => type_of_burst_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => type_of_burst_cdc_to_spi
    ); 
	---------------------------------------------------------------------------------------
	
	     
	AXI_LEN_SYNC_AXI_SPI_GEN_CDC: for i in 7 downto 0 generate
	     ---------------------
	     attribute ASYNC_REG : string;
	     attribute ASYNC_REG of AXI_LEN_SYNC_AXI2SPI_CDC : label is "TRUE";
     begin
     -------------
    AXI_LEN_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK,
        prmry_resetn         => Rst_from_axi_cdc_to_spi,
        prmry_in             => axi_length_cdc_from_axi(i),
        scndry_aclk          => EXT_SPI_CLK, 
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi,
        scndry_out           => axi_length_cdc_to_spi_d2(i)
    );
    end generate AXI_LEN_SYNC_AXI_SPI_GEN_CDC;
     axi_length_cdc_to_spi <= axi_length_cdc_to_spi_d2;
     ---------------------------------------------------------------------------------------
     
          
     DTR_LEN_SYNC_AXI_SPI_GEN_CDC: for i in 7 downto 0 generate
          ---------------------
          attribute ASYNC_REG : string;
          attribute ASYNC_REG of DTR_LEN_SYNC_AXI2SPI_CDC : label is "TRUE";
          begin
     -----
    DTR_LEN_SYNC_AXI2SPI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK,
        prmry_resetn         => Rst_from_axi_cdc_to_spi,
        prmry_in             => dtr_length_cdc_from_axi(i),
        scndry_aclk          => EXT_SPI_CLK, 
		prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi,
        scndry_out            => dtr_length_cdc_from_axi_d2(i)
    );
    end generate DTR_LEN_SYNC_AXI_SPI_GEN_CDC;
     dtr_length_cdc_to_spi <= dtr_length_cdc_from_axi_d2;
     ------------------------------------------------------------------------
    ------------------------------------------------------------------------------------------
	 
	 
	 	 
	 Rx_FIFO_Full_SYNC_SPI2AXI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => S_AXI_ACLK , 
        prmry_resetn         => S_AXI_ARESETN ,
        prmry_in             => Rx_FIFO_Full_cdc_from_spi ,
	prmry_vect_in        => (others => '0' ),
        scndry_aclk          => S_AXI_ACLK ,
        scndry_resetn        => S_AXI_ARESETN ,
        scndry_out           => Rx_FIFO_Full_cdc_to_axi
    ); 
     ------------------------------------------------------------------------
     
     	     
 Rx_FIFO_Full_SYNC_SPI2AXI4_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI4_ARESET ,
        prmry_in             => Rx_FIFO_Full_cdc_from_spi ,
	prmry_vect_in        => (others => '0' ),
        scndry_aclk          => S_AXI4_ACLK ,
        scndry_resetn        => S_AXI4_ARESET ,
        scndry_out           => Rx_FIFO_Full_cdc_to_axi4
    ); 
-------------------------------------------------------------------------------
	     

WB_HPM_DONE_SYNC_SPI2AXI_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI4_ARESET ,
        prmry_in             => wb_hpm_done_cdc_from_spi ,
	prmry_vect_in        => (others => '0' ),
        scndry_aclk          => S_AXI4_ACLK ,
        scndry_resetn        => S_AXI4_ARESET ,
        scndry_out           => wb_hpm_done_cdc_to_axi
    ); 
-------------------------------------------------------------------------------
byte_xfer_cdc_from_axi_d2 <= '0' ;
hw_xfer_cdc_from_axi_d2   <= '0' ;
word_xfer_cdc_from_axi_d2 <= '0' ;
mst_modf_err_d2 <= '0' ;
mst_modf_err_d4 <= '0' ;
CPOL_cdc_to_spi_d2 <= '0' ;
CPHA_cdc_to_spi_d2 <= '0' ;
type_of_burst_cdc_to_spi_d2 <= '0' ;
rx_fifo_full_d2 <= '0' ;





end generate LOGIC_GENERATION_CDC;

end architecture imp;
---------------------


-------------------------------------------------------------------------------
-- reset_sync_module.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        reset_sync_module.vhd
-- Version:         v3.0
-- Description:     This is the reset sync module.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.conv_std_logic_vector;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_signed.all;
    use ieee.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
    use ieee.std_logic_unsigned.all;


library axi_lite_ipif_v3_0_4;
    use axi_lite_ipif_v3_0_4.axi_lite_ipif;
    use axi_lite_ipif_v3_0_4.ipif_pkg.all;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
library unisim;
    use unisim.vcomponents.FDR;
-------------------------------------------------------------------------------
entity reset_sync_module is
--generic();
port(EXT_SPI_CLK       : in std_logic;
     Soft_Reset_frm_axi: in std_logic;
     Rst_to_spi        : out std_logic
);
end entity reset_sync_module;

architecture imp of reset_sync_module is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- signal declaration
signal Soft_Reset_frm_axi_d1 : std_logic;
signal Soft_Reset_frm_axi_d2 : std_logic;
signal Soft_Reset_frm_axi_d3 : std_logic;
attribute ASYNC_REG : string;
attribute ASYNC_REG of RESET_SYNC_AX2S_1     : label is "TRUE";
-----
begin
-----
--RESET_SYNC_FROM_AXI_TO_SPI: process(EXT_SPI_CLK)is
-------
--begin
-------
--     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
--         Soft_Reset_frm_axi_d1 <= Soft_Reset_frm_axi;
--         Soft_Reset_frm_axi_d2 <= Soft_Reset_frm_axi_d1;
--         Soft_Reset_frm_axi_d3 <= Soft_Reset_frm_axi_d2;
--     end if;
--end process RESET_SYNC_FROM_AXI_TO_SPI;
-----------------------------------------
     RESET_SYNC_AX2S_1: component FDR
                   generic map(INIT => '0' 
                   )port map (
                              Q  => Soft_Reset_frm_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => Soft_Reset_frm_axi,
                              R  => '0'
                            );
     RESET_SYNC_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Soft_Reset_frm_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => Soft_Reset_frm_axi_d1,
                              R  => '0'
                            );
Rst_to_spi <= Soft_Reset_frm_axi_d2;
---------------------------------------

end architecture imp;
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--  SPI Status Register Module - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        spi_status_reg.vhd
-- Version:         v3.0
-- Description:     Serial Peripheral Interface (SPI) Module for interfacing
--                  with a 32-bit AXI4 Bus. The file defines the logic for
--                  status and slave select register.
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;


library unisim;
    use unisim.vcomponents.FDRE;
-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------

-- C_SPI_NUM_BITS_REG              -- Width of SPI registers
-- C_S_AXI_DATA_WIDTH                -- Native data bus width 32 bits only
-- C_NUM_SS_BITS               -- Number of bits in slave select
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------

-- SYSTEM
--  Bus2IP_Clk                  --  Bus to IP clock
--  Soft_Reset_op                       --  Soft_Reset_op Signal

-- STATUS REGISTER RELATED SIGNALS
--================================
-- REGISTER/FIFO INTERFACE
-- Bus2IP_SPISR_RdCE      --  Status register Read Chip Enable
-- IP2Bus_SPISR_Data      --  Status register data to PLB based on PLB read

-- SR_3_modf                   --  Mode fault error status flag
-- SR_4_Tx_Full                --  Transmit register full status flag
-- SR_5_Tx_Empty               --  Transmit register empty status flag
-- SR_6_Rx_Full                --  Receive register full status flag
-- SR_7_Rx_Empty               --  Receive register empty stauts flag
-- ModeFault_Strobe            --  Mode fault strobe

-- SLAVE REGISTER RELATED SIGNALS
--===============================
-- Bus2IP_SPISSR_WrCE    -- slave select register write chip enable
-- Bus2IP_SPISSR_RdCE    -- slave select register read chip enable
-- Bus2IP_SPISSR_Data        -- slave register data from PLB Bus
-- IP2Bus_SPISSR_Data        -- Data from slave select register during PLB rd
-- SPISSR_Data_reg_op      -- Data to SPI Module
-- Wr_ce_reduce_ack_gen         -- commaon write ack generation signal
-- Rd_ce_reduce_ack_gen         -- commaon read ack generation signal

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity qspi_status_slave_sel_reg is
    generic
    (
        C_SPI_NUM_BITS_REG      : integer;    -- Number of bits in SR
        ------------------------
        C_S_AXI_DATA_WIDTH      : integer;       -- 32 bits
        ------------------------
        C_NUM_SS_BITS           : integer;    -- Number of bits in slave select
        ------------------------
        C_SPISR_REG_WIDTH       : integer
    );
    port
    (
       Bus2IP_Clk               : in  std_logic;
       Soft_Reset_op            : in  std_logic;
       -- I/P from control register

       SPISR_0_Command_Error      : in std_logic;       -- bit0 of SPISR
       SPISR_1_LOOP_Back_Error    : in std_logic;       -- bit1 of SPISR
       SPISR_2_MSB_Error          : in std_logic;
       SPISR_3_Slave_Mode_Error   : in std_logic;
       SPISR_4_CPOL_CPHA_Error    : in std_logic;       -- bit 4 of SPISR
       -- I/P from other modules
       SPISR_Ext_SPISEL_slave   : in std_logic; -- bit 5 of SPISR
       SPISR_7_Tx_Full          : in std_logic; -- bit 7 of SPISR
       SPISR_8_Tx_Empty         : in std_logic;
       SPISR_9_Rx_Full          : in std_logic;
       SPISR_10_Rx_Empty        : in std_logic; -- bit 10 of SPISR

       -- Slave attachment ports
       ModeFault_Strobe         : in  std_logic;
       Rd_ce_reduce_ack_gen     : in std_logic;
       Bus2IP_SPISR_RdCE        : in  std_logic;

       IP2Bus_SPISR_Data        : out std_logic_vector(0 to (C_SPISR_REG_WIDTH-1));
       SR_3_modf                : out std_logic;
       -- Reg/FIFO ports

       -- SPI module ports
       -----------------------------------
       -- Slave Select Register ports
       Bus2IP_SPISSR_WrCE   : in std_logic;
       Wr_ce_reduce_ack_gen : in std_logic;

       Bus2IP_SPISSR_RdCE   : in std_logic;
       Bus2IP_SPISSR_Data   : in std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1));
       IP2Bus_SPISSR_Data   : out std_logic_vector(0 to (C_NUM_SS_BITS-1));
       -- SPI module ports
       SPISSR_Data_reg_op   : out std_logic_vector(0 to (C_NUM_SS_BITS-1))
   );
end qspi_status_slave_sel_reg;
-------------------------------------------------------------------------------
-- Architecture
---------------
architecture imp of qspi_status_slave_sel_reg is
----------------------------------------------------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- Signal Declarations
----------------------
signal SPISR_reg                : std_logic_vector(0 to (C_SPISR_REG_WIDTH-1));
signal modf                     : std_logic;
signal modf_Reset               : std_logic;
----------------------
signal SPISSR_Data_reg          : std_logic_vector(0 to (C_NUM_SS_BITS-1));
signal spissr_reg_en            : std_logic;

constant RESET_ACTIVE       : std_logic         := '1'; 

----------------------
begin
-----
-- SPISR  - 0       1       2     3        4         5          6    7       8        9       10
--          Command Loop BK MSB   Slv Mode CPOL_CPHA Slave Mode MODF Tx_Full Tx_Empty Rx_Full Rx_Empty
--          Error   Error   Error Error    Error     Select
-- Default  0       0       0     1        0         1          0    0       1        0       1
-------------------------------------------------------------------------------
--  Combinatorial operations
-------------------------------------------------------------------------------
 SPISR_reg(C_SPISR_REG_WIDTH - 11) <= SPISR_0_Command_Error;     -- SPISR bit 0 @ C_SPISR_REG_WIDTH = 11
 SPISR_reg(C_SPISR_REG_WIDTH - 10) <= SPISR_1_LOOP_Back_Error;   -- SPISR bit 1
 SPISR_reg(C_SPISR_REG_WIDTH - 9)  <= SPISR_2_MSB_Error;         -- SPISR bit 2
 SPISR_reg(C_SPISR_REG_WIDTH - 8)  <= SPISR_3_Slave_Mode_Error;  -- SPISR bit 3
 SPISR_reg(C_SPISR_REG_WIDTH - 7)  <= SPISR_4_CPOL_CPHA_Error;   -- SPISR bit 4
 SPISR_reg(C_SPISR_REG_WIDTH - 6)  <= SPISR_Ext_SPISEL_slave;    -- SPISR bit 5
 SPISR_reg(C_SPISR_REG_WIDTH - 5)  <= modf;                      -- SPISR bit 6
 SPISR_reg(C_SPISR_REG_WIDTH - 4)  <= SPISR_7_Tx_Full;           -- SPISR bit 7
 SPISR_reg(C_SPISR_REG_WIDTH - 3)  <= SPISR_8_Tx_Empty;          -- SPISR bit 8
 SPISR_reg(C_SPISR_REG_WIDTH - 2)  <= SPISR_9_Rx_Full;           -- SPISR bit 9
 SPISR_reg(C_SPISR_REG_WIDTH - 1)  <= SPISR_10_Rx_Empty;         -- SPISR bit 10

 SR_3_modf                   <= modf;
-------------------------------------------------------------------------------
--  STATUS_REG_RD_GENERATE : Status Register Read Generate
----------------------------
STATUS_REG_RD_GENERATE: for i in 0 to C_SPISR_REG_WIDTH-1 generate
-----
begin
-----

    IP2Bus_SPISR_Data(i) <= SPISR_reg(i) and Bus2IP_SPISR_RdCE;

end generate STATUS_REG_RD_GENERATE;
-------------------------------------------------------------------------------
-- MODF_REG_PROCESS : Set and Clear modf
------------------------
MODF_REG_PROCESS:process(Bus2IP_Clk) is
-----
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (modf_Reset = RESET_ACTIVE) then
            modf <= '0';
        elsif (ModeFault_Strobe = '1') then
            modf <= '1';
        end if;
    end if;
end process MODF_REG_PROCESS;

modf_Reset <= (Rd_ce_reduce_ack_gen and Bus2IP_SPISR_RdCE) or Soft_Reset_op;

--******************************************************************************
-- logic for Slave Select Register

-- Combinatorial operations
----------------------------
SPISSR_Data_reg_op   <= SPISSR_Data_reg;

-------------------------------------------------------------------------------
--  SPISSR_WR_GEN : Slave Select Register Write Operation
----------------------------
SPISSR_WR_GEN: for i in 0 to C_NUM_SS_BITS-1 generate
-----
begin
-----
    spissr_reg_en <= Wr_ce_reduce_ack_gen and Bus2IP_SPISSR_WrCE;

    SPISSR_WR_PROCESS:process(Bus2IP_Clk) is
    -----
    begin
    -----
        if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
            if (Soft_Reset_op = RESET_ACTIVE) then
                SPISSR_Data_reg(i) <= '1';
        elsif ((Wr_ce_reduce_ack_gen and Bus2IP_SPISSR_WrCE) = '1') then
                SPISSR_Data_reg(i) <=
                        Bus2IP_SPISSR_Data(C_S_AXI_DATA_WIDTH-C_NUM_SS_BITS+i);
            end if;
        end if;
    end process SPISSR_WR_PROCESS;
        --SPISSR_WR_PROCESS_I: component FDRE
        --    generic map(
        --           INIT => '1'
        --    )
        --    port map
        --    (
        --    Q  => SPISSR_Data_reg(i)    ,-- out:
        --    C  => Bus2IP_Clk                ,--: in
        --    CE => spissr_reg_en             ,--: in
        --    R  => Soft_Reset_op             ,-- : in
        --    D  => Bus2IP_SPISSR_Data(C_S_AXI_DATA_WIDTH-C_NUM_SS_BITS+i)    --: in
        --    );
    ---------------------------------
-----
end generate SPISSR_WR_GEN;

-------------------------------------------------------------------------------
--  SLAVE_SEL_REG_RD_GENERATE : Slave Select Register Read Generate
-------------------------------
SLAVE_SEL_REG_RD_GENERATE: for i in 0 to C_NUM_SS_BITS-1 generate
-----
begin
-----
    IP2Bus_SPISSR_Data(i) <= SPISSR_Data_reg(i) and
                             Bus2IP_SPISSR_RdCE;
end generate SLAVE_SEL_REG_RD_GENERATE;
---------------------------------------

end imp;
--------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- qspi_startup_block.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_startup_block.vhd
-- Version:         v3.0
-- Description:     This module uses the STARTUP primitive based upon the generic.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      Soft_Reset_op signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.conv_std_logic_vector;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use IEEE.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
use ieee.std_logic_unsigned.all;

library unisim;

    --use unisim.vcomponents.STARTUP_SPARTAN6;
    --use unisim.vcomponents.STARTUP_VIRTEX6;
    use unisim.vcomponents.STARTUPE2; -- for 7-series FPGA's
	use unisim.vcomponents.STARTUPE3; -- for 8 series FPGA's

------------------------------
entity qspi_startup_block is
        generic
        (
                C_SUB_FAMILY             : string  ;
                ---------------------
                C_USE_STARTUP            : integer ;
                ---------------------
                C_SHARED_STARTUP    : integer range 0 to 1 := 0;
                ---------------------
                C_SPI_MODE               : integer
                ---------------------
        );
        port
        (
                SCK_O          : in std_logic; -- input from the spi_mode_0_module
                IO1_I_startup  : in std_logic; -- input from the top level port list
                IO1_Int        : out std_logic;
		        Bus2IP_Clk     : in std_logic;
                reset2ip_reset : in std_logic;
				CFGCLK         : out std_logic;       -- FGCLK        , -- 1-bit output: Configuration main clock output
                CFGMCLK        : out std_logic; -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
                EOS            : out std_logic;-- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
                PREQ           : out std_logic;-- REQ          , -- 1-bit output: PROGRAM request to fabric output
                DI             : out std_logic_vector(3 downto 0);-- output
                DO             : in std_logic_vector(3 downto 0);-- input
                DTS            : in std_logic_vector(3 downto 0);
                FCSBO          : in std_logic;
                FCSBTS         : in std_logic;
                CLK            : in std_logic;
                GSR            : in std_logic;
                GTS            : in std_logic;
                KEYCLEARB      : in std_logic;
                PACK           : in std_logic;
                USRCCLKTS      : in std_logic;
                USRDONEO       : in std_logic;
                USRDONETS      : in std_logic
 
        );
end entity qspi_startup_block;
------------------------------

architecture imp of qspi_startup_block is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- 19-11-2012 added below parameter and signals to fix the CR #679609
constant ADD_PIPELINTE : integer := 8;
signal pipe_signal     : std_logic_vector(ADD_PIPELINTE-1 downto 0);
signal PREQ_int        : std_logic;
signal PACK_int        : std_logic;
-----
begin
-----
PREQ_REG_P:process(Bus2IP_Clk)is  -- 19-11-2012
begin
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
         if(reset2ip_reset = '1')then
              pipe_signal(0) <= '0';
         elsif(PREQ_int = '1')then
              pipe_signal(0) <= '1';
         end if;
     end if;
end process PREQ_REG_P;

PIPE_PACK_P:process(Bus2IP_Clk)is -- 19-11-2012
begin
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
         if(reset2ip_reset = '1')then
              pipe_signal(ADD_PIPELINTE-1 downto 1) <= (others => '0');
         else
              pipe_signal(1) <= pipe_signal(0);
              pipe_signal(2) <= pipe_signal(1);
              pipe_signal(3) <= pipe_signal(2);
              pipe_signal(4) <= pipe_signal(3);
              pipe_signal(5) <= pipe_signal(4);
              pipe_signal(6) <= pipe_signal(5);
              pipe_signal(7) <= pipe_signal(6);
--              pipe_signal(8) <= pipe_signal(7);
         end if;
     end if;
end process PIPE_PACK_P;

PACK_int  <= pipe_signal(7); -- 19-11-2012

-- STARTUP_7SERIES_GEN: Logic instantiation of STARTUP primitive in the core.
STARTUP_7SERIES_GEN: if ( -- In 7-series, the start up is allowed in all C_SPI_MODE values.
                         C_SUB_FAMILY = "virtex7" or
                         C_SUB_FAMILY = "kintex7" or
                         (C_SUB_FAMILY = "zynq") or
                         (C_SUB_FAMILY = "spartan7") or
                         C_SUB_FAMILY = "artix7"
                         ) and (C_USE_STARTUP = 1 and C_SHARED_STARTUP = 0) generate
-----
begin
-----

   ASSERT (
           ( -- no check for C_SPI_MODE is needed here. On S6 the startup is not supported.
            -- (C_SUB_FAMILY = "virtex6") or
            (C_SUB_FAMILY = "virtex7") or
            (C_SUB_FAMILY = "kintex7") or
            (C_SUB_FAMILY = "zynq") or
            (C_SUB_FAMILY = "spartan7") or
            (C_SUB_FAMILY = "artix7")  
           )and
           (C_USE_STARTUP = 1)
          )
   REPORT "*** The use of STARTUP primitive is not supported on this targeted device. ***"
   SEVERITY error;


        -------------------
        IO1_Int <= IO1_I_startup;
        -------------------

        STARTUP2_7SERIES_inst : component STARTUPE2
        -----------------------
        generic map
        (
                PROG_USR      => "FALSE", -- Activate program event security feature.
                SIM_CCLK_FREQ => 0.0      -- Set the Configuration Clock Frequency(ns) for simulation.
        )
        port map
        (
                USRCCLKO  => SCK_O,      -- SRCCLKO      , -- 1-bit input: User CCLK input
                ----------
                CFGCLK    => CFGCLK,       -- FGCLK        , -- 1-bit output: Configuration main clock output
                CFGMCLK   => CFGMCLK,       -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
                EOS       => EOS,       -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
                PREQ      => PREQ_int,       -- REQ          , -- 1-bit output: PROGRAM request to fabric output
                ----------
                CLK       => '0',        -- LK           , -- 1-bit input: User start-up clock input
                GSR       => '0',        -- SR           , -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
                GTS       => '0',        -- TS           , -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
                KEYCLEARB => '0',        -- EYCLEARB     , -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
                PACK      => PACK_int, -- '1',        -- ACK          , -- 1-bit input: PROGRAM acknowledge input
                USRCCLKTS => '0',        -- SRCCLKTS     , -- 1-bit input: User CCLK 3-state enable input
                USRDONEO  => '1',        -- SRDONEO      , -- 1-bit input: User DONE pin output control
                USRDONETS => '1'         -- SRDONETS       -- 1-bit input: User DONE 3-state enable output
        );

end generate STARTUP_7SERIES_GEN;

STARTUP_SHARE_7SERIES_GEN: if ( -- In 7-series, the start up is allowed in all C_SPI_MODE values.
                         C_SUB_FAMILY = "virtex7" or
                         C_SUB_FAMILY = "kintex7" or
                         (C_SUB_FAMILY = "zynq") or
                         (C_SUB_FAMILY = "spartan7") or
                         C_SUB_FAMILY = "artix7"
                         ) and (C_USE_STARTUP = 1 and C_SHARED_STARTUP = 1) generate
-----
begin
-----

   ASSERT (
           ( -- no check for C_SPI_MODE is needed here. On S6 the startup is not supported.
            -- (C_SUB_FAMILY = "virtex6") or
            (C_SUB_FAMILY = "virtex7") or
            (C_SUB_FAMILY = "kintex7") or
            (C_SUB_FAMILY = "zynq") or
            (C_SUB_FAMILY = "spartan7") or
            (C_SUB_FAMILY = "artix7")  
           )and
           (C_USE_STARTUP = 1)
          )
   REPORT "*** The use of STARTUP primitive is not supported on this targeted device. ***"
   SEVERITY error;


        -------------------
        IO1_Int <= IO1_I_startup;
        -------------------

        STARTUP2_7SERIES_inst : component STARTUPE2
        -----------------------
        generic map
        (
                PROG_USR      => "FALSE", -- Activate program event security feature.
                SIM_CCLK_FREQ => 0.0      -- Set the Configuration Clock Frequency(ns) for simulation.
        )
        port map
        (
                USRCCLKO  => SCK_O,      -- SRCCLKO      , -- 1-bit input: User CCLK input
                ----------
                CFGCLK    => CFGCLK,       -- FGCLK        , -- 1-bit output: Configuration main clock output
                CFGMCLK   => CFGMCLK,       -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
                EOS       => EOS,       -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
                PREQ      => PREQ_int,       -- REQ          , -- 1-bit output: PROGRAM request to fabric output
                ----------
                CLK       => CLK,        -- LK           , -- 1-bit input: User start-up clock input
                GSR       => GSR,        -- SR           , -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
                GTS       => GTS,        -- TS           , -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
                KEYCLEARB => KEYCLEARB,        -- EYCLEARB     , -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
                PACK      => PACK_int, -- '1',        -- ACK          , -- 1-bit input: PROGRAM acknowledge input
                USRCCLKTS => USRCCLKTS,        -- SRCCLKTS     , -- 1-bit input: User CCLK 3-state enable input
                USRDONEO  => USRDONEO,        -- SRDONEO      , -- 1-bit input: User DONE pin output control
                USRDONETS => USRDONETS         -- SRDONETS       -- 1-bit input: User DONE 3-state enable output
        );

end generate STARTUP_SHARE_7SERIES_GEN;

---------------------------------
---STARTUP for 8 series STARTUPE3
---------------------------------
 STARTUP_8SERIES_GEN: if ( -- In 8-series, the start up is allowed in all C_SPI_MODE values.
                          (C_SUB_FAMILY /= "virtex7") and
                          (C_SUB_FAMILY /= "kintex7") and
                          (C_SUB_FAMILY /= "zynq") and
                          (C_SUB_FAMILY /= "spartan7") and
                          (C_SUB_FAMILY /= "artix7")
                           ) and C_USE_STARTUP = 1 generate
-- -----
 begin
-- -----

    ASSERT (
            ( 
             (C_SUB_FAMILY /= "virtex7") and
             (C_SUB_FAMILY /= "kintex7") and
                          (C_SUB_FAMILY /= "spartan7") and
             (C_SUB_FAMILY /= "zynq") and
             (C_SUB_FAMILY /= "artix7")
            )and

            (C_USE_STARTUP = 1)
           )
    REPORT "*** The use of STARTUP primitive is not supported on this targeted device. ***"
    SEVERITY error;


         -------------------
         IO1_Int <= IO1_I_startup;
         -------------------

         STARTUP3_8SERIES_inst : component STARTUPE3
         -----------------------
         generic map
         (
                 PROG_USR      => "FALSE", -- Activate program event security feature.
                SIM_CCLK_FREQ => 0.0      -- Set the Configuration Clock Frequency(ns) for simulation.
         )
         port map
         (
                 USRCCLKO  => SCK_O,      -- SRCCLKO      , -- 1-bit input: User CCLK input
                 ----------
                 CFGCLK    => CFGCLK,       -- FGCLK        , -- 1-bit output: Configuration main clock output
                 CFGMCLK   => CFGMCLK,       -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
                 EOS       => EOS,       -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
                 PREQ      => PREQ_int,       -- REQ          , -- 1-bit output: PROGRAM request to fabric output
                 ----------
				 DO        => DO,      -- input
				 DI        => DI,       -- output
				 DTS       => DTS,        -- input
                 FCSBO     => FCSBO,        -- input
                 FCSBTS    => FCSBTS,        -- input
                 GSR       => GSR,        -- SR           , -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
                 GTS       => GTS,        -- TS           , -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
                 KEYCLEARB => KEYCLEARB,        -- EYCLEARB     , -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
                 PACK      => PACK_int, -- '1',        -- ACK          , -- 1-bit input: PROGRAM acknowledge input
                 USRCCLKTS => USRCCLKTS,        -- SRCCLKTS     , -- 1-bit input: User CCLK 3-state enable input
                 USRDONEO  => USRDONEO,        -- SRDONEO      , -- 1-bit input: User DONE pin output control
                 USRDONETS => USRDONETS         -- SRDONETS       -- 1-bit input: User DONE 3-state enable output
         );

 end generate STARTUP_8SERIES_GEN;


PREQ <= PREQ_int;

end architecture imp;


-------------------------------------------------------------------------------
-- qspi_receive_reg.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_receive_reg.vhd
-- Version:         v3.0
-- Description:     Quad Serial Peripheral Interface (SPI) Module for interfacing
--                  with a 32-bit AXI4 Bus.
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------

--  C_NUM_TRANSFER_BITS         --      SPI Serial transfer width.
--                                      Can be 8, 16 or 32 bit wide
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------
-- SYSTEM
--  Bus2IP_Clk                  --      Bus to IP clock
--  Soft_Reset_op                       --      Soft_Reset_op Signal

-- SLAVE ATTACHMENT INTERFACE

--  Bus2IP_Reg_RdCE             --      Read CE for receive register
--  IP2Bus_RdAck_sa             --      IP2Bus read acknowledgement
--  IP2Bus_Receive_Reg_Data                 --      Data to be send on the bus
--  Receive_ip2bus_error        --      Receive register error signal

-- SPI MODULE INTERFACE

--  DRR_Overrun                 --      DRR Overrun bit
--  SR_7_Rx_Empty               --      Receive register empty signal
--  SPI_Received_Data                 --      Data received from receive register
--  SPIXfer_done                --      SPI transfer done flag
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity qspi_receive_transmit_reg is
    generic
    (
        C_S_AXI_DATA_WIDTH   : integer;      -- 32 bits
        ---------------------
        C_NUM_TRANSFER_BITS  : integer       -- Number of bits to be transferred
        ---------------------
    );
    port
    (
     Bus2IP_Clk               : in  std_logic;
     Soft_Reset_op            : in  std_logic;
     ------------------------------------
     -- RECEIVER RELATED SIGNALS
     --=========================
     Bus2IP_Receive_Reg_RdCE  : in  std_logic;
     Receive_ip2bus_error     : out std_logic;
     IP2Bus_Receive_Reg_Data  : out std_logic_vector
                                                 (0 to (C_NUM_TRANSFER_BITS-1));
     -- SPI module ports
     SPIXfer_done             : in  std_logic;
     SPI_Received_Data        : in  std_logic_vector
                                                 (0 to (C_NUM_TRANSFER_BITS-1));
     -- receive & transmit reg signals
     -- DRR_Overrun              : out std_logic;
     SR_7_Rx_Empty            : out std_logic;
     ------------------------------------
     -- TRANSMITTER RELATED SIGNALS
     --============================
     -- Slave attachment ports
     Bus2IP_Transmit_Reg_Data : in std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1));
     Bus2IP_Transmit_Reg_WrCE : in std_logic;
     Wr_ce_reduce_ack_gen     : in std_logic;
     Rd_ce_reduce_ack_gen     : in std_logic;
     --SPI Transmitter signals
     Transmit_ip2bus_error    : out std_logic;

     -- SPI module ports
     DTR_underrun             : in  std_logic;
     SR_5_Tx_Empty            : out std_logic;
     tx_empty_signal_handshake_req            : out std_logic;
     tx_empty_signal_handshake_gnt            : in std_logic;
     DTR_Underrun_strobe      : out std_logic;
     Transmit_Reg_Data_Out    : out std_logic_vector
                                               (0 to (C_NUM_TRANSFER_BITS-1))
    );
end qspi_receive_transmit_reg;

-------------------------------------------------------------------------------
-- Architecture
---------------
architecture imp of qspi_receive_transmit_reg is
---------------------------------------------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- Signal Declarations
----------------------
signal Received_register_Data         : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal sr_7_Rx_Empty_reg         : std_logic;
signal drr_Overrun_strobe      : std_logic;
--------------------------------------------
signal sr_5_Tx_Empty_i         : std_logic;
signal tx_empty_signal_handshake_req_i         : std_logic;
signal tx_Reg_Soft_Reset_op            : std_logic;
signal dtr_Underrun_strobe_i   : std_logic;
signal dtr_underrun_d1         : std_logic;
signal SPIXfer_done_delay : std_logic;

constant RESET_ACTIVE       : std_logic         := '1'; 

--------------------------------------------
begin
-----
-- RECEIVER LOGIC
--=================
--  Combinatorial operations
----------------------------
SR_7_Rx_Empty   <= sr_7_Rx_Empty_reg;
-- DRR_Overrun     <= drr_Overrun_strobe;

DELAY_XFER_DONE_P:process(Bus2IP_Clk)
    begin
        if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
            if (Soft_Reset_op = RESET_ACTIVE) then
                 SPIXfer_done_delay <= '0';
            else
                 SPIXfer_done_delay <= SPIXfer_done;
            end if;
        end if;
end process DELAY_XFER_DONE_P;
-------------------------------------------------------------------------------
--  RECEIVE_REG_GENERATE : Receive Register Read Operation from SPI_Received_Data
--                         register
--------------------------
RECEIVE_REG_GENERATE: for i in 0 to C_NUM_TRANSFER_BITS-1 generate
begin
-----
    RECEIVE_REG_PROCESS_P:process(Bus2IP_Clk)
    begin
        if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
            if (Soft_Reset_op = RESET_ACTIVE) then
                Received_register_Data(i) <= '0';
            elsif (SPIXfer_done_delay = '1') then--((sr_7_Rx_Empty_reg and SPIXfer_done) = '1') then
                Received_register_Data(i) <= SPI_Received_Data(i);
            end if;
        end if;
    end process RECEIVE_REG_PROCESS_P;
-----
end generate RECEIVE_REG_GENERATE;

-------------------------------------------------------------------------------
--  RECEIVE_REG_RD_GENERATE : Receive Register Read Operation
-----------------------------
RECEIVE_REG_RD_GENERATE: for i in 0 to C_NUM_TRANSFER_BITS-1 generate
begin
     IP2Bus_Receive_Reg_Data(i) <= Received_register_Data(i) and
                                   Bus2IP_Receive_Reg_RdCE;
end generate RECEIVE_REG_RD_GENERATE;

-------------------------------------------------------------------------------
--  RX_ERROR_ACK_REG_PROCESS_P : Strobe error when receive register is empty
--------------------------------
RX_ERROR_ACK_REG_PROCESS_P:process(Bus2IP_Clk)
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        Receive_ip2bus_error <= sr_7_Rx_Empty_reg and
                                Bus2IP_Receive_Reg_RdCE;
    end if;
end process RX_ERROR_ACK_REG_PROCESS_P;

-------------------------------------------------------------------------------
--  SR_7_RX_EMPTY_REG_PROCESS_P : SR_7_Rx_Empty register
-------------------------------
SR_7_RX_EMPTY_REG_PROCESS_P:process(Bus2IP_Clk)
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            sr_7_Rx_Empty_reg <= '1';
        elsif (SPIXfer_done = '1') then
            sr_7_Rx_Empty_reg <= '0';
        elsif ((rd_ce_reduce_ack_gen and Bus2IP_Receive_Reg_RdCE) = '1') then
            sr_7_Rx_Empty_reg <= '1';
        end if;
    end if;
end process SR_7_RX_EMPTY_REG_PROCESS_P;
----******************************************************************************
-- TRANSMITTER LOGIC
--==================
--  Combinatorial operations
----------------------------
tx_empty_signal_handshake_req       <= tx_empty_signal_handshake_req_i;
SR_5_Tx_Empty       <= sr_5_Tx_Empty_i;
DTR_Underrun_strobe <= dtr_Underrun_strobe_i;

tx_Reg_Soft_Reset_op <= SPIXfer_done or Soft_Reset_op;
--------------------------------------

-------------------------------------------------------------------------------
--  TRANSMIT_REG_GENERATE : Transmit Register Write
---------------------------
TRANSMIT_REG_GENERATE: for i in 0 to C_NUM_TRANSFER_BITS-1 generate
begin
-----
    TRANSMIT_REG_PROCESS_P:process(Bus2IP_Clk)
    begin
        if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
            if (tx_Reg_Soft_Reset_op = RESET_ACTIVE) then
                Transmit_Reg_Data_Out(i) <= '0';
            elsif ((wr_ce_reduce_ack_gen and Bus2IP_Transmit_Reg_WrCE) = '1')then
                Transmit_Reg_Data_Out(i) <=
                            Bus2IP_Transmit_Reg_Data
                            (C_S_AXI_DATA_WIDTH-C_NUM_TRANSFER_BITS+i) after 100 ps;
            end if;
        end if;
    end process TRANSMIT_REG_PROCESS_P;
-----
end generate TRANSMIT_REG_GENERATE;
-----------------------------------

--  TX_ERROR_ACK_REG_PROCESS_P : Strobe error when transmit register is full
--------------------------------
TX_ERROR_ACK_REG_PROCESS_P:process(Bus2IP_Clk)
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        Transmit_ip2bus_error <= not(sr_5_Tx_Empty_i) and
                                 Bus2IP_Transmit_Reg_WrCE;
    end if;
end process TX_ERROR_ACK_REG_PROCESS_P;

-------------------------------------------------------------------------------
--  SR_5_TX_EMPTY_REG_PROCESS_P : Tx Empty generate
-------------------------------
SR_5_TX_EMPTY_REG_PROCESS_P:process(Bus2IP_Clk)
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            sr_5_Tx_Empty_i <= '1';
        elsif ((wr_ce_reduce_ack_gen and Bus2IP_Transmit_Reg_WrCE) = '1') then
            sr_5_Tx_Empty_i <= '0';
        elsif (SPIXfer_done = '1') then
            sr_5_Tx_Empty_i <= '1';
        end if;
    end if;
end process SR_5_TX_EMPTY_REG_PROCESS_P;


-------------------------------------------------------------------------------
--  tx_empty_signal_handshake_req_i 
-------------------------------
process(Bus2IP_Clk)
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            tx_empty_signal_handshake_req_i <= '1';
        elsif (sr_5_Tx_Empty_i = '1') then
            tx_empty_signal_handshake_req_i <= '1';
        elsif (sr_5_Tx_Empty_i  = '0' and tx_empty_signal_handshake_gnt = '1') then
            tx_empty_signal_handshake_req_i <= '0';
        end if;
    end if;
end process ;





-------------------------------------------------------------------------------
--  DTR_UNDERRUN_REG_PROCESS_P : Strobe to interrupt for transmit data underrun
--                           which happens only in slave mode
-----------------------------
DTR_UNDERRUN_REG_PROCESS_P:process(Bus2IP_Clk)
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            dtr_underrun_d1 <= '0';
        else
            dtr_underrun_d1 <= DTR_underrun;
        end if;
    end if;
end process DTR_UNDERRUN_REG_PROCESS_P;
---------------------------------------

dtr_Underrun_strobe_i <= DTR_underrun and (not dtr_underrun_d1);

--******************************************************************************

end imp;
--------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- qspi_occupancy_reg.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_occupancy_reg.vhd
-- Version:         v3.0
-- Description:     Serial Peripheral Interface (SPI) Module for interfacing
--                  with a 32-bit AXI4 Bus.Defines logic for occupancy regist
--                  -er.
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;

-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------

--  C_DBUS_WIDTH                --      Width of the slave data bus
--  C_OCCUPANCY_NUM_BITS        --      Number of bits in occupancy count
--  C_NUM_BITS_REG              --      Width of SPI registers
--  C_NUM_TRANSFER_BITS         --      SPI Serial transfer width.
--                                      Can be 8, 16 or 32 bit wide

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------

-- SYSTEM

--  Bus2IP_Clk                  --      Bus to IP clock
--  Reset                       --      Reset Signal

-- SLAVE ATTACHMENT INTERFACE
--===========================
--  Bus2IP_OCC_REG_RdCE             --      Read CE for occupancy register
--  SPIXfer_done                --      SPI transfer done flag

--  FIFO INTERFACE
--  IP2Reg_OCC_Data        --      Occupancy data read from FIFO

--  IP2Bus_OCC_REG_Data                 --      Data to be send on the bus
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity qspi_occupancy_reg is
    generic
    (
        C_OCCUPANCY_NUM_BITS: integer--  --Number of bits in occupancy count
    );
    port
    (
        -- Slave attachment ports
       Bus2IP_OCC_REG_RdCE   : in std_logic;
       IP2Reg_OCC_Data       : in std_logic_vector(0 to (C_OCCUPANCY_NUM_BITS-1));
       IP2Bus_OCC_REG_Data   : out std_logic_vector(0 to (C_OCCUPANCY_NUM_BITS-1))

     );
end qspi_occupancy_reg;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture imp of qspi_occupancy_reg is
-------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- Signal Declarations
----------------------
begin
-----
--  OCCUPANCY_REG_RD_GENERATE : Occupancy Register Read Generate
-------------------------------
OCCUPANCY_REG_RD_GENERATE: for j in 0 to C_OCCUPANCY_NUM_BITS-1 generate
begin
    IP2Bus_OCC_REG_Data(j) <= IP2Reg_OCC_Data(C_OCCUPANCY_NUM_BITS-1-j) and
                                                            Bus2IP_OCC_REG_RdCE;
end generate OCCUPANCY_REG_RD_GENERATE;

end imp;
--------------------------------------------------------------------------------


--
----  qspi_mode_control_logic - entity/architecture pair
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
---- Filename:        qspi_mode_control_logic.vhd
---- Version:         v3.0
---- Description:     Serial Peripheral Interface (SPI) Module for interfacing
----                  with a 32-bit AXI4 Bus.
----
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_unsigned.all;
    use ieee.numeric_std.all;
    use ieee.std_logic_misc.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.log2;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

library unisim;
    use unisim.vcomponents.FD;
    use unisim.vcomponents.FDRE;
-------------------------------------------------------------------------------

entity qspi_mode_control_logic is
        generic(
                C_SCK_RATIO           : integer;
                C_NUM_SS_BITS         : integer;
                C_NUM_TRANSFER_BITS   : integer;

                C_SPI_MODE            : integer;
                C_USE_STARTUP         : integer;
                C_SPI_MEMORY          : integer;
                C_SUB_FAMILY          : string;
                C_DUAL_MODE           : integer;
                C_STARTUP_EXT         : integer
        );
        port(
                Bus2IP_Clk           : in std_logic;
                Soft_Reset_op        : in std_logic;
                --------------------
                DTR_FIFO_Data_Exists : in std_logic;
                Slave_Select_Reg     : in  std_logic_vector(0 to (C_NUM_SS_BITS-1));
                Transmit_Data        : in  std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
                Receive_Data         : out std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
                --Data_To_Rx_FIFO_1    : out std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
                SPIXfer_done         : out std_logic;
                SPIXfer_done_Rx_Wr_en: out std_logic;
                MODF_strobe          : out std_logic;
                SPIXfer_done_rd_tx_en: out std_logic;
                ----------------------
                SR_3_MODF            : in std_logic;
                SR_5_Tx_Empty        : in std_logic;
                --SR_6_Rx_Full         : in std_logic;
                --Last_count           : in std_logic;
                ---------------------- from control register
                SPICR_0_LOOP         : in std_logic;
                SPICR_1_SPE          : in std_logic;
                SPICR_2_MASTER_N_SLV : in std_logic;
                SPICR_3_CPOL         : in std_logic;
                SPICR_4_CPHA         : in std_logic;
                SPICR_5_TXFIFO_RST   : in std_logic;
                SPICR_6_RXFIFO_RST   : in std_logic;
                SPICR_7_SS           : in std_logic;
                SPICR_8_TR_INHIBIT   : in std_logic;
                SPICR_9_LSB          : in std_logic;
                ----------------------

                ---------------------- from look up table
                Data_Dir             : in std_logic;
                Data_Mode_1          : in std_logic;
                Data_Mode_0          : in std_logic;
                Data_Phase           : in std_logic;
                ----------------------
                Quad_Phase          : in std_logic;
                --Dummy_Bits           : in std_logic_vector(3 downto 0);
                ----------------------
                Addr_Mode_1          : in std_logic;
                Addr_Mode_0          : in std_logic;
                Addr_Bit             : in std_logic;
                Addr_Phase           : in std_logic;
                ----------------------
                CMD_Mode_1           : in std_logic;
                CMD_Mode_0           : in std_logic;
                CMD_Error            : in std_logic;
                CMD_decoded          : in std_logic;
                ----------------------

                --SPI Interface
                SCK_I                : in  std_logic;
                SCK_O_reg            : out std_logic;
                SCK_T                : out std_logic;

                IO0_I                : in  std_logic;
                IO0_O                : out std_logic; -- MOSI
                IO0_T                : out std_logic;

                IO1_I                : in  std_logic; -- MISO
                IO1_O                : out std_logic;
                IO1_T                : out std_logic;

                IO2_I                : in  std_logic;
                IO2_O                : out std_logic;
                IO2_T                : out std_logic;

                IO3_I                : in  std_logic;
                IO3_O                : out std_logic;
                IO3_T                : out std_logic;

                SPISEL               : in  std_logic;

                SS_I         : in std_logic_vector((C_NUM_SS_BITS-1) downto 0);
                SS_O         : out std_logic_vector((C_NUM_SS_BITS-1) downto 0);
                SS_T         : out std_logic;

                SPISEL_pulse_op      : out std_logic;
                SPISEL_d1_reg        : out std_logic;
                Control_bit_7_8      : in std_logic_vector(0 to 1); --(7 to 8)
                pr_state_idle        : out std_logic;
                Rx_FIFO_Full         : in std_logic ;
                DRR_Overrun_reg      : out std_logic;
                reset_RcFIFO_ptr_to_spi : in std_logic

        );
end entity qspi_mode_control_logic;
----------------------------------

architecture imp of qspi_mode_control_logic is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- constant declaration
constant RESET_ACTIVE : std_logic := '1';
constant COUNT_WIDTH  : INTEGER   := log2(C_NUM_TRANSFER_BITS)+1;
-- function declaration
------------------------
-- spcl_log2 : Performs log2(x) function for value of C_SCK_RATIO > 2
------------------------
function spcl_log2(x : natural) return integer is
    variable j  : integer := 0;
    variable k  : integer := 0;
begin
    if(C_SCK_RATIO /= 2) then
        for i in 0 to 11 loop
            if(2**i >= x) then
               if(k = 0) then
                  j := i;
               end if;
               k := 1;
            end if;
        end loop;
        return j;
    else
        return 2;
    end if;
end spcl_log2;
-- type declaration
type STATE_TYPE is
                  (IDLE,       -- decode command can be combined here later
                   CMD_SEND,
                   ADDR_SEND,TEMP_ADDR_SEND,
                   --DUMMY_SEND,
                   DATA_SEND,TEMP_DATA_SEND,
                   DATA_RECEIVE,TEMP_DATA_RECEIVE
                   );
signal qspi_cntrl_ps: STATE_TYPE;
signal qspi_cntrl_ns: STATE_TYPE;
-----------------------------------------
-- signal declaration
signal Ratio_Count               : std_logic_vector
                                   (0 to (spcl_log2(C_SCK_RATIO))-2);
signal Count                     : std_logic_vector(COUNT_WIDTH downto 0);
signal Count_1                   : std_logic_vector(COUNT_WIDTH downto 0);
signal LSB_first                 : std_logic;
signal Mst_Trans_inhibit         : std_logic;
signal Manual_SS_mode            : std_logic;
signal CPHA                      : std_logic;
signal CPOL                      : std_logic;
signal Mst_N_Slv                 : std_logic;
signal SPI_En                    : std_logic;
signal Loop_mode                 : std_logic;

signal transfer_start            : std_logic;

signal transfer_start_d1         : std_logic;
signal transfer_start_pulse      : std_logic;
signal SPIXfer_done_int          : std_logic;
signal SPIXfer_done_int_d1       : std_logic;
signal SPIXfer_done_int_pulse    : std_logic;
signal SPIXfer_done_int_pulse_d1 : std_logic;
signal SPIXfer_done_int_pulse_d2 : std_logic;
signal SPIXfer_done_int_pulse_d3 : std_logic;

signal Serial_Dout_0             : std_logic;
signal Serial_Dout_1             : std_logic;
signal Serial_Dout_2             : std_logic;
signal Serial_Dout_3             : std_logic;
signal Serial_Din_0              : std_logic;
signal Serial_Din_1              : std_logic;
signal Serial_Din_2              : std_logic;
signal Serial_Din_3              : std_logic;

signal io2_i_sync                : std_logic;
signal io3_i_sync                : std_logic;
signal serial_dout_int           : std_logic;
signal mosi_i_sync               : std_logic;
signal miso_i_sync               : std_logic;

signal master_tri_state_en_control : std_logic;
signal IO0_tri_state_en_control  : std_logic;
signal IO1_tri_state_en_control  : std_logic;
signal IO2_tri_state_en_control  : std_logic;
signal IO3_tri_state_en_control  : std_logic;
signal SCK_tri_state_en_control  : std_logic;

signal SPISEL_sync                 : std_logic;
signal spisel_d1                   : std_logic;
signal spisel_pulse                : std_logic;
signal Sync_Set                    : std_logic;
signal Sync_Reset                  : std_logic;

signal SS_Asserted                 : std_logic;
signal SS_Asserted_1dly            : std_logic;
signal Allow_MODF_Strobe           : std_logic;

signal MODF_strobe_int             : std_logic;
signal Load_tx_data_to_shift_reg_int : std_logic;


signal mode_0 : std_logic;
signal mode_1 : std_logic;

signal sck_o_int                 : std_logic;
signal sck_o_in                  : std_logic;
signal Shift_Reg                 : std_logic_vector
                                   (0 to C_NUM_TRANSFER_BITS-1);
signal sck_d1                    : std_logic;
signal sck_d2                    : std_logic;
signal sck_d3                    : std_logic;
signal sck_rising_edge           : std_logic;
signal rx_shft_reg               : std_logic_vector(0 to C_NUM_TRANSFER_BITS-1);
signal SCK_O_1                   : std_logic;-- :='0';

signal receive_Data_int  : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
                                                            --:=(others => '0');
signal rx_shft_reg_mode_0011 : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
                                                            --:=(others => '0');
signal Count_trigger             : std_logic;
signal Count_trigger_d1          : std_logic;
signal Count_trigger_pulse       : std_logic;

signal pr_state_cmd_ph       : std_logic;
signal pr_state_addr_ph      : std_logic;
signal pr_state_dummy_ph     : std_logic;
signal pr_state_data_receive : std_logic;
signal pr_state_non_idle     : std_logic;

signal addr_cnt        : std_logic_vector(2 downto 0);
signal dummy_cnt       : std_logic_vector(3 downto 0);
signal stop_clock      : std_logic;

signal IO0_T_control : std_logic;
signal IO1_T_control : std_logic;
signal IO2_T_control : std_logic;
signal IO3_T_control : std_logic;
signal dummy         : std_logic;
signal no_slave_selected : std_logic;

signal Data_To_Rx_FIFO_1    : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal Data_To_Rx_FIFO_2    : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

------------------------attribute IOB                    : string;
------------------------attribute IOB of QSPI_SCK_T      : label is "true";


signal Mst_Trans_inhibit_d1 : std_logic;
signal Mst_Trans_inhibit_pulse : std_logic;
signal stop_clock_reg : std_logic;

    signal transfer_start_d2      : std_logic;
    signal transfer_start_d3      : std_logic;
    signal transfer_start_pulse_11: std_logic;
 signal DRR_Overrun_reg_int : std_logic;
 signal Rx_FIFO_Full_reg : std_logic;
 signal SPIXfer_done_drr : std_logic;
-----
begin
-----

SPIXfer_done <= SPIXfer_done_drr;

LSB_first                       <= SPICR_9_LSB;          -- Control_Reg(0);
Mst_Trans_inhibit               <= SPICR_8_TR_INHIBIT;   -- Control_Reg(1);
Manual_SS_mode                  <= SPICR_7_SS;           -- Control_Reg(2);
CPHA                            <= SPICR_4_CPHA;         -- Control_Reg(5);
CPOL                            <= SPICR_3_CPOL;         -- Control_Reg(6);
Mst_N_Slv                       <= SPICR_2_MASTER_N_SLV; -- Control_Reg(7);
SPI_En                          <= SPICR_1_SPE;          -- Control_Reg(8);
Loop_mode                       <= SPICR_0_LOOP;         -- Control_Reg(9);

IO0_O                           <= Serial_Dout_0;
IO1_O                           <= Serial_Dout_1;
IO2_O                           <= Serial_Dout_2;
IO3_O                           <= Serial_Dout_3;

Receive_Data                    <= receive_Data_int;
DRR_Overrun_reg <= DRR_Overrun_reg_int;

--RX_FULL_CHECK_PROCESS: process(Bus2IP_Clk) is
--begin
--     if(Bus2IP_Clk'event and Bus2IP_Clk='1') then
--         if (Soft_Reset_op = RESET_ACTIVE)or(reset_RcFIFO_ptr_to_spi = '1') or (DRR_Overrun_reg_int = '1') then
--               Rx_FIFO_Full_reg <= '0';
--         elsif(Rx_FIFO_Full = '1')then
--               Rx_FIFO_Full_reg <= '1';
--         end if;
--     end if;
--end process RX_FULL_CHECK_PROCESS;
--
--DRR_OVERRUN_REG_PROCESS:process(Bus2IP_Clk) is
-------
--begin
-------
--    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
--        if (Soft_Reset_op = RESET_ACTIVE) then
--            DRR_Overrun_reg_int <= '0';
--        else
--            DRR_Overrun_reg_int <= not(DRR_Overrun_reg_int or Soft_Reset_op) and
--                                                                Rx_FIFO_Full_reg and
--                                                                SPIXfer_done_int_pulse_d2;
--        end if;
--    end if;
--end process DRR_OVERRUN_REG_PROCESS;



DRR_OVERRUN_REG_PROCESS:process(Bus2IP_Clk) is
-----
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            DRR_Overrun_reg_int <= '0';
        else
            DRR_Overrun_reg_int <= not(DRR_Overrun_reg_int or Soft_Reset_op) and
                                                                Rx_FIFO_Full and
                                                                SPIXfer_done_drr;
        end if;
    end if;
end process DRR_OVERRUN_REG_PROCESS;




--* -------------------------------------------------------------------------------
--* -- MASTER_TRIST_EN_PROCESS : If not master make tristate enabled
--* ----------------------------
master_tri_state_en_control <=
                     '0' when
                     (
                      (control_bit_7_8(0)='1') and        -- decides master/slave mode
                      (control_bit_7_8(1)='1') and        -- decide the spi_en
                      ((MODF_strobe_int or SR_3_MODF)='0')-- no mode fault
                     ) else
                     '1';

--QSPI_SS_T: tri-state register for SS,ideal state-deactive
QSPI_SS_T: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => SS_T,
        C  => Bus2IP_Clk,
        D  => master_tri_state_en_control
        );

--------------------------------------
    --QSPI_SCK_T : Tri-state register for SCK_T, ideal state-deactive
SCK_tri_state_en_control <= '0' when
                         (
                          -- (pr_state_non_idle = '1')    and -- CR#619275 - this is commented to operate the mode 3 with SW flow
                          (control_bit_7_8(0)='1') and        -- decides master/slave mode
                          (control_bit_7_8(1)='1') and        -- decide the spi_en
                          ((MODF_strobe_int or SR_3_MODF)='0')-- no mode fault
                         ) else
                         '1';
    QSPI_SCK_T: component FD
       generic map
           (
           INIT => '1'
           )
       port map
           (
           Q  => SCK_T,
           C  => Bus2IP_Clk,
           D  => SCK_tri_state_en_control
           );

    IO0_tri_state_en_control <= '0' when
                         (
                          (IO0_T_control = '0')    and
                          (control_bit_7_8(0)='1') and        -- decides master/slave mode
                          (control_bit_7_8(1)='1') and        -- decide the spi_en
                          ((MODF_strobe_int or SR_3_MODF)='0')-- no mode fault
                         ) else
                         '1';
    --QSPI_IO0_T: tri-state register for MOSI, ideal state-deactive
    QSPI_IO0_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO0_T,     -- MOSI_T,
            C  => Bus2IP_Clk,
            D  => IO0_tri_state_en_control -- master_tri_state_en_control
            );
    --------------------------------------
    IO1_tri_state_en_control <= '0' when
                         (
                          (IO1_T_control = '0')    and
                          (control_bit_7_8(0)='1') and        -- decides master/slave mode
                          (control_bit_7_8(1)='1') and        -- decide the spi_en
                          ((MODF_strobe_int or SR_3_MODF)='0')-- no mode fault
                         ) else
                         '1';

    --QSPI_IO0_T: tri-state register for MISO, ideal state-deactive
    QSPI_IO1_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO1_T,      -- MISO_T,
            C  => Bus2IP_Clk,
            D  => IO1_tri_state_en_control
            );
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
QSPI_NO_MODE_2_T_CONTROL: if C_SPI_MODE = 1 or C_SPI_MODE = 0 generate
----------------------
begin
-----
    --------------------------------------
    IO2_tri_state_en_control <= '1';
    IO3_tri_state_en_control <= '1';
    IO2_T <= '1';
    IO3_T <= '1';
    --------------------------------------
end generate QSPI_NO_MODE_2_T_CONTROL;
--------------------------------------
-------------------------------------------------------------------------------
QSPI_MODE_2_T_CONTROL: if C_SPI_MODE = 2 generate
----------------------
begin
-----
    --------------------------------------
    IO2_tri_state_en_control <= '0' when
                         (
                          (IO2_T_control = '0')    and
                          (control_bit_7_8(0)='1') and        -- decides master/slave mode
                          (control_bit_7_8(1)='1') and        -- decide the spi_en
                          ((MODF_strobe_int or SR_3_MODF)='0')-- no mode fault
                         ) else
                         '1';
    --QSPI_IO0_T: tri-state register for MOSI, ideal state-deactive
    QSPI_IO2_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO2_T,     -- MOSI_T,
            C  => Bus2IP_Clk,
            D  => IO2_tri_state_en_control -- master_tri_state_en_control
            );
    --------------------------------------
    IO3_tri_state_en_control <= '0' when
                         (
                          (IO3_T_control = '0')    and
                          (control_bit_7_8(0)='1') and        -- decides master/slave mode
                          (control_bit_7_8(1)='1') and        -- decide the spi_en
                          ((MODF_strobe_int or SR_3_MODF)='0')-- no mode fault
                         ) else
                         '1';

    --QSPI_IO0_T: tri-state register for MISO, ideal state-deactive
    QSPI_IO3_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO3_T,      -- MISO_T,
            C  => Bus2IP_Clk,
            D  => IO3_tri_state_en_control
            );
    --------------------------------------
end generate QSPI_MODE_2_T_CONTROL;
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- QSPI_SPISEL: first synchronize the incoming signal, this is required is slave
--------------- mode of the core.

    QSPI_SPISEL: component FD
       generic map
            (
            INIT => '1' -- default '1' to make the device in default master mode
            )
       port map
            (
            Q  => SPISEL_sync,
            C  => Bus2IP_Clk,
            D  => SPISEL
            );
    -- SPISEL_DELAY_1CLK_PROCESS_P : Detect active SCK edge in slave mode
    -----------------------------
    SPISEL_DELAY_1CLK_PROCESS_P: process(Bus2IP_Clk)
    begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE) then
                spisel_d1 <= '1';
            else
                spisel_d1 <= SPISEL_sync;
            end if;
        end if;
    end process SPISEL_DELAY_1CLK_PROCESS_P;
    ------------------------------------------------
    -- spisel pulse generating logic
    -- this one clock cycle pulse will be available for data loading into
    -- shift register
    spisel_pulse <= (not SPISEL_sync) and spisel_d1;

    -- --------|__________ -- SPISEL
    -- ----------|________ -- SPISEL_sync
    -- -------------|_____ -- spisel_d1
    -- __________|--|_____ -- SPISEL_pulse_op
    SPISEL_pulse_op       <= not SPISEL_sync; -- spisel_pulse;
    SPISEL_d1_reg         <= spisel_d1;


    MST_TRANS_INHIBIT_D1_I: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => Mst_Trans_inhibit_d1,
        C  => Bus2IP_Clk,
        D  => Mst_Trans_inhibit
        );
    Mst_Trans_inhibit_pulse <= Mst_Trans_inhibit and (not Mst_Trans_inhibit_d1);
    -------------------------------------------------------------------------------
    -- SCK_SET_GEN_PROCESS : Generate SET control for SCK_O_reg
    ------------------------
    SCK_SET_GEN_PROCESS: process(CPOL,
                                 CPHA,
                                 SPIXfer_done_int,
                                 transfer_start_pulse,
                                 Mst_Trans_inhibit_pulse) is
    -----
    begin
    -----
        --if(SPIXfer_done_int = '1' or transfer_start_pulse = '1') then
        if(Mst_Trans_inhibit_pulse = '1' or SPIXfer_done_int = '1') then
            Sync_Set <= (CPOL xor CPHA);
        else
            Sync_Set <= '0';
        end if;
    end process SCK_SET_GEN_PROCESS;

    -------------------------------------------------------------------------------
    -- SCK_RESET_GEN_PROCESS : Generate SET control for SCK_O_reg
    --------------------------
    SCK_RESET_GEN_PROCESS: process(CPOL,
                                   CPHA,
                                   transfer_start_pulse,
                                   SPIXfer_done_int,
                                   Mst_Trans_inhibit_pulse)is
    -----
    begin
    -----
        --if(SPIXfer_done_int = '1' or transfer_start_pulse = '1') then
        if(Mst_Trans_inhibit_pulse = '1' or SPIXfer_done_int = '1') then
            Sync_Reset <= not(CPOL xor CPHA);
        else
            Sync_Reset <= '0';
        end if;
    end process SCK_RESET_GEN_PROCESS;

    -------------------------------------------------------------------------------
    -- SELECT_OUT_PROCESS : This process sets SS active-low, one-hot encoded select
    --                      bit. Changing SS is premitted during a transfer by
    --                      hardware, but is to be prevented by software. In Auto
    --                      mode SS_O reflects value of Slave_Select_Reg only
    --                      when transfer is in progress, otherwise is SS_O is held
    --                      high
    -----------------------
    SELECT_OUT_PROCESS: process(Bus2IP_Clk)is
    begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
           if(Soft_Reset_op = RESET_ACTIVE) then
               SS_O                   <= (others => '1');
               SS_Asserted            <= '0';
               SS_Asserted_1dly       <= '0';
           elsif(transfer_start = '0') then    -- Tranfer not in progress
               for i in (C_NUM_SS_BITS-1) downto 0 loop
                   SS_O(i) <= Slave_Select_Reg(C_NUM_SS_BITS-1-i);
               end loop;
               SS_Asserted       <= '0';
               SS_Asserted_1dly  <= '0';
           else
               for i in (C_NUM_SS_BITS-1) downto 0 loop
                   SS_O(i) <= Slave_Select_Reg(C_NUM_SS_BITS-1-i);
               end loop;
               SS_Asserted       <= '1';
               SS_Asserted_1dly  <= SS_Asserted;
           end if;
        end if;
    end process SELECT_OUT_PROCESS;
    ----------------------------
    no_slave_selected <= and_reduce(Slave_Select_Reg(0 to (C_NUM_SS_BITS-1)));
    -------------------------------------------------------------------------------
    -- MODF_STROBE_PROCESS : Strobe MODF signal when master is addressed as slave
    ------------------------
    MODF_STROBE_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
           if((Soft_Reset_op = RESET_ACTIVE) or (SPISEL_sync = '1')) then
               MODF_strobe       <= '0';
               MODF_strobe_int   <= '0';
               Allow_MODF_Strobe <= '1';
           elsif((Mst_N_Slv = '1')   and --In Master mode
                 (SPISEL_sync = '0') and
                 (Allow_MODF_Strobe = '1')
                 ) then
               MODF_strobe       <= '1';
               MODF_strobe_int   <= '1';
               Allow_MODF_Strobe <= '0';
           else
               MODF_strobe       <= '0';
               MODF_strobe_int   <= '0';
           end if;
        end if;
    end process MODF_STROBE_PROCESS;

    --------------------------------------------------------------------------
    -- LOADING_FIRST_ELEMENT_PROCESS : Combinatorial process to generate flag
    --                                 when loading first data element in shift
    --                                 register from transmit register/fifo
    ----------------------------------
    LOADING_FIRST_ELEMENT_PROCESS: process(Soft_Reset_op,
                                           SPI_En,
                                           SS_Asserted,
                                           SS_Asserted_1dly,
                                           SR_3_MODF
                                           )is
    -----
    begin
    -----
        if(Soft_Reset_op = RESET_ACTIVE) then
            Load_tx_data_to_shift_reg_int <= '0';   --Clear flag
        elsif(SPI_En                 = '1'   and    --Enabled
              (
               (--(Mst_N_Slv              = '1')  and  --Master configuration
                (SS_Asserted            = '1')  and
                (SS_Asserted_1dly       = '0')  and
                (SR_3_MODF              = '0')
               )
              )
             )then
            Load_tx_data_to_shift_reg_int <= '1';               --Set flag
        else
            Load_tx_data_to_shift_reg_int <= '0';               --Clear flag
        end if;
    end process LOADING_FIRST_ELEMENT_PROCESS;
    ------------------------------------------
    -------------------------------------------------------------------------------
    -- TRANSFER_START_PROCESS : Generate transfer start signal. When the transfer
    --                          gets completed, SPI Transfer done strobe pulls
    --                          transfer_start back to zero.
    ---------------------------
    TRANSFER_START_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op             = RESET_ACTIVE or
                (
                 (
                  SPI_En            = '0' or  -- enable not asserted or
                  (SPIXfer_done_int = '1' and SR_5_Tx_Empty    = '1' and Data_Phase = '0' and Addr_Phase = '0') or  -- no data in Tx reg/FIFO or
                  SR_3_MODF         = '1' or  -- mode fault error
                  Mst_Trans_inhibit = '1' or  -- Do not start if Mst xfer inhibited
                  stop_clock        = '1'     -- core is in Data Receive State and DRR is not full
                 )
                )
              )then

                transfer_start <= '0';
            else
    -- Delayed SPIXfer_done_int_pulse to work for synchronous design and to remove
    -- asserting of loading_sr_reg in master mode after SR_5_Tx_Empty goes to 1
              --    if((SPIXfer_done_int_pulse = '1') --   or
                     --(SPIXfer_done_int_pulse_d1 = '1')-- or
                     --(SPIXfer_done_int_pulse_d2='1')
              --       ) then-- this is added to remove
                                                          -- glitch at the end of
                                                          -- transfer in AUTO mode
              --            transfer_start <= '0'; -- Set to 0 for at least 1 period
              --      else
                          transfer_start <= '1'; -- Proceed with SPI Transfer
              --      end if;
            end if;
        end if;
    end process TRANSFER_START_PROCESS;
    --------------------------------
    --TRANSFER_START_PROCESS: process(Bus2IP_Clk)is
    -------
    --begin
    -------
    --    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
    --        if(Soft_Reset_op             = RESET_ACTIVE or
    --            (
    --             (
    --              SPI_En            = '0' or  -- enable not asserted or
    --              (SR_5_Tx_Empty    = '1' and Data_Phase = '0' and Addr_Phase = '0') or  -- no data in Tx reg/FIFO or
    --              SR_3_MODF         = '1' or  -- mode fault error
    --              Mst_Trans_inhibit = '1' or  -- Do not start if Mst xfer inhibited
    --              stop_clock        = '1'     -- core is in Data Receive State and DRR is not full
    --             )
    --            )
    --          )then
    --
    --            transfer_start <= '0';
    --        else
    ---- Delayed SPIXfer_done_int_pulse to work for synchronous design and to remove
    ---- asserting of loading_sr_reg in master mode after SR_5_Tx_Empty goes to 1
    --              if((SPIXfer_done_int_pulse = '1')    or
    --                 (SPIXfer_done_int_pulse_d1 = '1')-- or
    --                 --(SPIXfer_done_int_pulse_d2='1')
    --                 ) then-- this is added to remove
    --                                                      -- glitch at the end of
    --                                                      -- transfer in AUTO mode
    --                      transfer_start <= '0'; -- Set to 0 for at least 1 period
    --                else
    --                    transfer_start <= '1'; -- Proceed with SPI Transfer
    --                end if;
    --        end if;
    --    end if;
    --end process TRANSFER_START_PROCESS;
    -------------------------------------

    -------------------------------------------------------------------------------
    -- TRANSFER_START_1CLK_PROCESS : Delay transfer start by 1 clock cycle
    --------------------------------
    TRANSFER_START_1CLK_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE) then
                transfer_start_d1 <= '0';
                transfer_start_d2 <= '0';
                transfer_start_d3 <= '0';
            else
                transfer_start_d1 <= transfer_start;
                transfer_start_d2 <= transfer_start_d1;
                transfer_start_d3 <= transfer_start_d2;
            end if;
        end if;
    end process TRANSFER_START_1CLK_PROCESS;

    -- transfer start pulse generating logic
    transfer_start_pulse <= transfer_start and (not(transfer_start_d1));

    transfer_start_pulse_11 <= transfer_start_d2 and (not transfer_start_d3);
    -------------------------------------------------------------------------------
    -- TRANSFER_DONE_1CLK_PROCESS : Delay SPI transfer done signal by 1 clock cycle
    -------------------------------
    TRANSFER_DONE_1CLK_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE) then
                SPIXfer_done_int_d1 <= '0';
            else
                SPIXfer_done_int_d1 <= SPIXfer_done_int;
            end if;
        end if;
    end process TRANSFER_DONE_1CLK_PROCESS;
    --
    -- transfer done pulse generating logic
    SPIXfer_done_int_pulse <= SPIXfer_done_int and (not(SPIXfer_done_int_d1));

    -------------------------------------------------------------------------------
    -- TRANSFER_DONE_PULSE_DLY_PROCESS : Delay SPI transfer done pulse by 1 and 2
    --                                   clock cycles
    ------------------------------------
    -- Delay the Done pulse by a further cycle. This is used as the output Rx
    -- data strobe when C_SCK_RATIO = 2
    TRANSFER_DONE_PULSE_DLY_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE) then
                SPIXfer_done_int_pulse_d1 <= '0';
                SPIXfer_done_int_pulse_d2 <= '0';
                SPIXfer_done_int_pulse_d3 <= '0';
            else
                SPIXfer_done_int_pulse_d1 <= SPIXfer_done_int_pulse;
                SPIXfer_done_int_pulse_d2 <= SPIXfer_done_int_pulse_d1;
                SPIXfer_done_int_pulse_d3 <= SPIXfer_done_int_pulse_d2;
            end if;
        end if;
    end process TRANSFER_DONE_PULSE_DLY_PROCESS;
--------------------------------------------
-------------------------------------------------------------------------------
-- RX_DATA_GEN1: Only for C_SCK_RATIO = 2 mode.
----------------
RX_DATA_SCK_RATIO_2_GEN1 : if C_SCK_RATIO = 2 generate
-----
begin
-----
    -------------------------------------------------------------------------------
    -- TRANSFER_DONE_PROCESS : Generate SPI transfer done signal. This will stop the SPI clock.
    --------------------------
    TRANSFER_DONE_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE or transfer_start_pulse = '1') then
                SPIXfer_done_int <= '0';
            --elsif (transfer_start_pulse = '1') then
            --    SPIXfer_done_int <= '0';
            else
                if(mode_1 = '1' and mode_0 = '0')then
                        SPIXfer_done_int <= Count(1) and
                                            not(Count(0));
                elsif(mode_1 = '0' and mode_0 = '1')then
                        SPIXfer_done_int <= not(Count(0)) and
                                                Count(2)  and
                                                Count(1);
                else
                        SPIXfer_done_int <= --Count(COUNT_WIDTH);
                                              Count(COUNT_WIDTH-1) and
                                              Count(COUNT_WIDTH-2) and
                                              Count(COUNT_WIDTH-3) and
                                              not Count(COUNT_WIDTH-4);
                end if;
            end if;
        end if;
    end process TRANSFER_DONE_PROCESS;

-- RECEIVE_DATA_STROBE_PROCESS : Strobe data from shift register to receive
--                               data register
--------------------------------
-- For a SCK ratio of 2 the Done needs to be delayed by an extra cycle
-- due to the serial input being captured on the falling edge of the PLB
-- clock. this is purely required for dealing with the real SPI slave memories.

     RECEIVE_DATA_STROBE_PROCESS: process(Bus2IP_Clk)
     -----
     begin
     -----
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE)then
                    Data_To_Rx_FIFO_1 <= (others => '0');
                    receive_Data_int  <= (others => '0');
            elsif(SPIXfer_done_int_pulse_d2 = '1')then
               if(mode_1 = '0' and mode_0 = '0')then    -- for Standard transfer
                      Data_To_Rx_FIFO_1 <= rx_shft_reg_mode_0011
                                         (1 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I ; --MISO_I;
                      receive_Data_int <= rx_shft_reg_mode_0011
                                         (1 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I ; --MISO_I;
               elsif(mode_1 = '0' and mode_0 = '1')then -- for Dual transfer
                      Data_To_Rx_FIFO_1 <= rx_shft_reg_mode_0011
                                         (2 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I &  -- MISO_I - MSB first
                                                                  IO0_I ;  -- MOSI_I
                      receive_Data_int <= rx_shft_reg_mode_0011
                                         (2 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I &  -- MISO_I - MSB first
                                                                  IO0_I ;  -- MOSI_I
               elsif(mode_1 = '1' and mode_0 = '0')then -- for Quad transfer
                      Data_To_Rx_FIFO_1 <= rx_shft_reg_mode_0011
                                         (4 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO3_I &  -- MSB first
                                                                  IO2_I &
                                                                  IO1_I &
                                                                  IO0_I ;
                      receive_Data_int <= rx_shft_reg_mode_0011
                                         (4 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO3_I &  -- MSB first
                                                                  IO2_I &
                                                                  IO1_I &
                                                                  IO0_I ;
               end if;
																  
																  
            end if;
         end if;
    end process RECEIVE_DATA_STROBE_PROCESS;

    RECEIVE_DATA_STROBE_PROCESS_1: process(Bus2IP_Clk)
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
           if(Soft_Reset_op = RESET_ACTIVE)then
                   Data_To_Rx_FIFO_2 <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d1 = '1')then
                   Data_To_Rx_FIFO_2 <= Data_To_Rx_FIFO_1;
           end if;
        end if;
    end process RECEIVE_DATA_STROBE_PROCESS_1;

    --receive_Data_int <= Data_To_Rx_FIFO_2;
    -- Done strobe delayed to match receive data
    SPIXfer_done_drr <= SPIXfer_done_int_pulse_d3;
  --  SPIXfer_done_rd_tx_en <= transfer_start_pulse or SPIXfer_done_int_d1; -- SPIXfer_done_int_pulse_d1;
    SPIXfer_done_rd_tx_en <= transfer_start_pulse or SPIXfer_done_int_pulse_d2;
   -- SPIXfer_done_rd_tx_en <= SPIXfer_done_int;
-------------------------------------------------
end generate RX_DATA_SCK_RATIO_2_GEN1;
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- RATIO_OF_2_GENERATE : Logic to be used when C_SCK_RATIO is equal to 2
------------------------
RATIO_OF_2_GENERATE: if(C_SCK_RATIO = 2) generate
--------------------
begin
-----
-------------------------------------------------------------------------------
-- SCK_CYCLE_COUNT_PROCESS : Counts number of trigger pulses provided. Used for
--                           controlling the number of bits to be transfered
--                           based on generic C_NUM_TRANSFER_BITS
----------------------------
  RATIO_2_SCK_CYCLE_COUNT_PROCESS: process(Bus2IP_Clk)
  begin
      -- if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      --     if((Soft_Reset_op = RESET_ACTIVE) or
      --        (transfer_start_d1 = '0')      or
      --        --(transfer_start = '0' and SPIXfer_done_int_d1 = '1')      or
      --        (Mst_N_Slv = '0')
      --       )then
      --
      --         Count <= (others => '0');
      --     elsif (Count(COUNT_WIDTH) = '0') then
      --         Count <=  Count + 1;
      -- end if;
      -- end if;

if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
    if((Soft_Reset_op = RESET_ACTIVE) or
       (SPIXfer_done_int = '1')      or
       (transfer_start = '0')
       --(transfer_start = '0' and SPIXfer_done_int_d1 = '1')      or
       --(Mst_N_Slv = '0')
      )then

        Count <= (others => '0');
    elsif (Count(COUNT_WIDTH) = '0') and ((CPOL and CPHA) = '0') then
        Count <=  Count + 1;
    elsif(transfer_start_d2 = '1') and (Count(COUNT_WIDTH) = '0') then
        Count <=  Count + 1;
    end if;
end if;
  end process RATIO_2_SCK_CYCLE_COUNT_PROCESS;
  ------------------------------------

  -------------------------------------------------------------------------------
  -- SCK_SET_RESET_PROCESS : Sync set/reset toggle flip flop controlled by
  --                         transfer_start signal
  --------------------------
  RATIO_2_SCK_SET_RESET_PROCESS: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (Sync_Reset = '1')) then
              sck_o_int <= '0';
          elsif(Sync_Set = '1') then
              sck_o_int <= '1';
          elsif (transfer_start = '1') then
              --sck_o_int <= (not sck_o_int) xor Count(COUNT_WIDTH);
              sck_o_int <= (not sck_o_int);
          end if;
      end if;
  end process RATIO_2_SCK_SET_RESET_PROCESS;
  ----------------------------------

      -- DELAY_CLK: Delay the internal clock for a cycle to generate internal enable
    --         -- signal for data register.
    -------------
    RATIO_2_DELAY_CLK: process(Bus2IP_Clk)is
    -----
    begin
    -----
       if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if (Soft_Reset_op = RESET_ACTIVE)then
             sck_d1 <= '0';
             sck_d2 <= '0';
             sck_d3 <= '0';
          else
             sck_d1 <= sck_o_int;
             sck_d2 <= sck_d1;
             sck_d3 <= sck_d2;
          end if;
       end if;
    end process RATIO_2_DELAY_CLK;
    ------------------------------------
    -- Rising egde pulse
    sck_rising_edge <= sck_d2 and (not sck_d1);

  --   CAPT_RX_FE_MODE_00_11: The below logic is to capture data for SPI mode of
  --------------------------- 00 and 11.
  -- Generate a falling edge pulse from the serial clock. Use this to
  -- capture the incoming serial data into a shift register.
  RATIO_2_CAPT_RX_FE_MODE_00_11 : process(Bus2IP_Clk)is
  begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then --SPIXfer_done_int_pulse_d2
          if (Soft_Reset_op = RESET_ACTIVE)then
                  rx_shft_reg_mode_0011 <= (others => '0');
          elsif((sck_d3='0') and --(sck_rising_edge = '1') and
                (Data_Dir='0')  -- data direction = 0 is read mode
               )then
               -------
               if(mode_1 = '0' and mode_0 = '0')then    -- for Standard transfer
                      rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                         (1 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I ; --MISO_I;
               elsif(mode_1 = '0' and mode_0 = '1')then -- for Dual transfer
                      rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                         (2 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I &  -- MISO_I - MSB first
                                                                  IO0_I ;  -- MOSI_I
               elsif(mode_1 = '1' and mode_0 = '0')then -- for Quad transfer
                      rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                         (4 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO3_I &  -- MSB first
                                                                  IO2_I &
                                                                  IO1_I &
                                                                  IO0_I ;
               end if;
               -------
          else
             rx_shft_reg_mode_0011<= rx_shft_reg_mode_0011;
          end if;
      end if;
  end process RATIO_2_CAPT_RX_FE_MODE_00_11;
  ----------------------------------
  RATIO_2_CAP_QSPI_QUAD_MODE_NM_MEM_GEN: if (
                                             (C_SPI_MODE = 2
                                              or
                                              C_SPI_MODE = 1
                                              )and
                                             (C_SPI_MEMORY = 2
											 )
                                             )generate
  --------------------------------------
  begin
  -----
  -------------------------------------------------------------------------------
  -- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
  --                             capture and shift operation for serial data in
  ------------------------------ master SPI mode only
  RATIO_2_CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk)is
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          elsif(transfer_start = '1') then --(Mst_N_Slv = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then --
              --if(Load_tx_data_to_shift_reg_int = '1') then
                      Shift_Reg   <= Transmit_Data;
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;-- this is to make the DQ3 bit 1 in quad command transfer mode.
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              elsif(
                    (Count(0) = '0')
                    )then -- Shift Data on even
                  if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                  elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                  elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                  end if;
              elsif(
                    (Count(0) = '1')       --and
                    ) then -- Capture Data on odd
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                           Shift_Reg <= Shift_Reg
                                        (1 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I ;-- MISO_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                        (2 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I &
                                                                IO0_I ;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                        (4 to C_NUM_TRANSFER_BITS -1) &
                                                                IO3_I &
                                                                IO2_I &
                                                                IO1_I &
                                                                IO0_I ;
                      end if;
              end if;
          end if;
      end if;
  end process RATIO_2_CAPTURE_AND_SHIFT_PROCESS;
  ----------------------------------------------
  end generate RATIO_2_CAP_QSPI_QUAD_MODE_NM_MEM_GEN;
  RATIO_2_CAP_QSPI_QUAD_MODE_SP_MEM_GEN: if (
                                             (C_SPI_MODE = 2
                                              or
                                              C_SPI_MODE = 1
                                              )and
                                             (
											 C_SPI_MEMORY = 3)
                                             )generate
  --------------------------------------
  begin
  -----
  -------------------------------------------------------------------------------
  -- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
  --                             capture and shift operation for serial data in
  ------------------------------ master SPI mode only
  RATIO_2_CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk)is
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          elsif(transfer_start = '1') then --(Mst_N_Slv = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then --
              --if(Load_tx_data_to_shift_reg_int = '1') then
                      Shift_Reg   <= Transmit_Data;
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;-- this is to make the DQ3 bit 1 in quad command transfer mode.
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              elsif(
                    (Count(0) = '0')
                    )then -- Shift Data on even
                  if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                  elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                  elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                  end if;
              elsif(
                    (Count(0) = '1')       --and
                    ) then -- Capture Data on odd
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                           Shift_Reg <= Shift_Reg
                                        (1 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I ;-- MISO_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                        (2 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I &
                                                                IO0_I ;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                        (4 to C_NUM_TRANSFER_BITS -1) &
                                                                IO3_I &
                                                                IO2_I &
                                                                IO1_I &
                                                                IO0_I ;
                      end if;
              end if;
          end if;
      end if;
  end process RATIO_2_CAPTURE_AND_SHIFT_PROCESS;
  ----------------------------------------------
  end generate RATIO_2_CAP_QSPI_QUAD_MODE_SP_MEM_GEN;

  RATIO_2_CAP_QSPI_QUAD_MODE_OTHER_MEM_GEN: if (
                                                 (C_SPI_MODE = 2 and
                                                  (C_SPI_MEMORY = 0
                                                   or
                                                   C_SPI_MEMORY = 1)
                                                 )
                                                 or
                                                 (C_SPI_MODE = 1 and
                                                  (C_SPI_MEMORY = 0
                                                   or
                                                   C_SPI_MEMORY = 1)
                                                 )
                                                ) generate
  -----------------------------------------
  begin
  -----
  -------------------------------------------------------------------------------
  -- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
  --                             capture and shift operation for serial data in
  ------------------------------ master SPI mode only
  RATIO_2_CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk)is
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          elsif(transfer_start = '1') then --(Mst_N_Slv = '1') then
              --if(Load_tx_data_to_shift_reg_int = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then --
                      Shift_Reg   <= Transmit_Data;
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;-- this is to make the DQ3 bit 1 in quad command transfer mode.
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              elsif(
                    (Count(0) = '0')       --and
                    )then -- Shift Data on even
                  if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                  elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                  elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                  end if;
              elsif(
                    (Count(0) = '1')       --and
                    ) then -- Capture Data on odd
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                           Shift_Reg <= Shift_Reg
                                        (1 to C_NUM_TRANSFER_BITS -1) &
                                                                 IO1_I;-- MISO_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                        (2 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I &
                                                                IO0_I ;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                        (4 to C_NUM_TRANSFER_BITS -1) &
                                                                IO3_I &
                                                                IO2_I &
                                                                IO1_I &
                                                                IO0_I ;
                      end if;
              end if;
          end if;
      end if;
  end process RATIO_2_CAPTURE_AND_SHIFT_PROCESS;
  ----------------------------------------------
  end generate RATIO_2_CAP_QSPI_QUAD_MODE_OTHER_MEM_GEN;
  ------------------------------------------------------
-----
end generate RATIO_OF_2_GENERATE;
---------------------------------
--------==================================================================-----
RX_DATA_GEN_OTHER_SCK_RATIOS : if C_SCK_RATIO /= 2 generate
------------------------------
-----
begin
-----
    -------------------------------------------------------------------------------
    -- TRANSFER_DONE_PROCESS : Generate SPI transfer done signal.  This will stop the SPI clock.
    --------------------------
    TRANSFER_DONE_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE or transfer_start_pulse = '1') then
                SPIXfer_done_int <= '0';
            --elsif (transfer_start_pulse = '1') then
            --    SPIXfer_done_int <= '0';
            else
                if(CPHA = '0' and CPOL = '0') then
                        if(mode_1 = '1' and mode_0 = '0')then    -- quad mode
                                SPIXfer_done_int <= Count(0) and Count(1);
                        elsif(mode_1 = '0' and mode_0 = '1')then -- for dual mode
                                SPIXfer_done_int <= Count(2) and
                                                    Count(1) and
                                                    Count(0);--- and
                                                    --(and_reduce(Ratio_Count));-- dual mode
                        else
                                SPIXfer_done_int <= Count(COUNT_WIDTH-COUNT_WIDTH+3) and
                                                    Count(COUNT_WIDTH-COUNT_WIDTH+2) and
                                                    Count(COUNT_WIDTH-COUNT_WIDTH+1) and
                                                    Count(COUNT_WIDTH-COUNT_WIDTH);
                        end if;
                else
                        if(mode_1 = '1' and mode_0 = '0')then    -- quad mode
                                SPIXfer_done_int <= Count(1) and
                                                    Count(0);
                        elsif(mode_1 = '0' and mode_0 = '1')then -- for dual mode
                                SPIXfer_done_int <= Count(2) and
                                                    Count(1) and
                                                    Count(0);
                        else
                                SPIXfer_done_int <= Count(COUNT_WIDTH-COUNT_WIDTH+3) and
                                                    Count(COUNT_WIDTH-COUNT_WIDTH+2) and
                                                    Count(COUNT_WIDTH-COUNT_WIDTH+1) and
                                                    Count(COUNT_WIDTH-COUNT_WIDTH);
                        end if;

                end if;
            end if;
        end if;
    end process TRANSFER_DONE_PROCESS;

    --  RECEIVE_DATA_STROBE_PROCESS_OTHER_RATIO: the below process if for other
    --------------------------------------------  SPI ratios of C_SCK_RATIO >2
    --                                        -- It multiplexes the data stored
    --                                        -- in internal registers in LSB and
    --                                        -- non-LSB modes, in master as well as
    --                                        -- in slave mode.
    RECEIVE_DATA_STROBE_PROCESS_OTHER_RATIO: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(Soft_Reset_op = RESET_ACTIVE)then
               receive_Data_int <= (others => '0');
            elsif(SPIXfer_done_int_pulse_d1 = '1')then
               receive_Data_int <= rx_shft_reg_mode_0011;
           end if;
        end if;
    end process RECEIVE_DATA_STROBE_PROCESS_OTHER_RATIO;

    SPIXfer_done_drr <= SPIXfer_done_int_pulse_d2;
    SPIXfer_done_rd_tx_en <= transfer_start_pulse or SPIXfer_done_int_pulse_d2;
    --------------------------------------------
end generate RX_DATA_GEN_OTHER_SCK_RATIOS;

-------------------------------------------------------------------------------
-- OTHER_RATIO_GENERATE : Logic to be used when C_SCK_RATIO is not equal to 2
-------------------------
OTHER_RATIO_GENERATE: if(C_SCK_RATIO /= 2) generate
begin
-----
-------------------------------------------------------------------------------
     IO0_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => mosi_i_sync,
          C  => Bus2IP_Clk,
          D  => IO0_I --MOSI_I
          );
     IO1_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => miso_i_sync,
          C  => Bus2IP_Clk,
          D  => IO1_I -- MISO_I
          );

     NO_IO_x_I_SYNC_MODE_1_GEN: if C_SPI_MODE = 1 generate
     -----
     begin
     -----

          io2_i_sync <= '0';
          io3_i_sync <= '0';

     end generate NO_IO_x_I_SYNC_MODE_1_GEN;
     ---------------------------------------

     IO_x_I_SYNC_MODE_2_GEN: if C_SPI_MODE = 2 generate
     ----------------
     -----
     begin
     -----
     -----------------------
     IO2_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => io2_i_sync,
            C  => Bus2IP_Clk,
            D  => IO2_I
            );
     -----------------------
     IO3_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => io3_i_sync,
            C  => Bus2IP_Clk,
            D  => IO3_I
            );
     -----------------------
    end generate IO_x_I_SYNC_MODE_2_GEN;
    ------------------------------------

    -------------------------------------------------------------------------------
    -- RATIO_COUNT_PROCESS : Counter which counts from (C_SCK_RATIO/2)-1 down to 0
    --                       Used for counting the time to control SCK_O_reg generation
    --                       depending on C_SCK_RATIO
    ------------------------
    OTHER_RATIO_COUNT_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
                Ratio_Count <= CONV_STD_LOGIC_VECTOR(
                               ((C_SCK_RATIO/2)-1),(spcl_log2(C_SCK_RATIO)-1));
            else
                Ratio_Count <= Ratio_Count - 1;
                if (Ratio_Count = 0) then
                    Ratio_Count <= CONV_STD_LOGIC_VECTOR(
                                ((C_SCK_RATIO/2)-1),(spcl_log2(C_SCK_RATIO)-1));
                end if;
            end if;
        end if;
    end process OTHER_RATIO_COUNT_PROCESS;
    --------------------------------
    -------------------------------------------------------------------------------
    -- COUNT_TRIGGER_GEN_PROCESS : Generate a trigger whenever Ratio_Count reaches
    --                             zero
    ------------------------------
    OTHER_RATIO_COUNT_TRIGGER_GEN_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if((Soft_Reset_op = RESET_ACTIVE) or
               --(SPIXfer_done_int = '1')       or
               (transfer_start = '0')
               ) then
                Count_trigger <= '0';
            elsif(Ratio_Count = 0) then
                Count_trigger <= not Count_trigger;
            end if;
        end if;
    end process OTHER_RATIO_COUNT_TRIGGER_GEN_PROCESS;
    --------------------------------------

    -------------------------------------------------------------------------------
    -- COUNT_TRIGGER_1CLK_PROCESS : Delay cnt_trigger signal by 1 clock cycle
    -------------------------------
    OTHER_RATIO_COUNT_TRIGGER_1CLK_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
                Count_trigger_d1 <= '0';
            else
                Count_trigger_d1 <=  Count_trigger;
            end if;
        end if;
    end process OTHER_RATIO_COUNT_TRIGGER_1CLK_PROCESS;

    -- generate a trigger pulse for rising edge as well as falling edge
    Count_trigger_pulse <= (Count_trigger and (not(Count_trigger_d1))) or
                           ((not(Count_trigger)) and Count_trigger_d1);
    -------------------------------------------------------------------------------
    -- SCK_CYCLE_COUNT_PROCESS : Counts number of trigger pulses provided. Used for
    --                           controlling the number of bits to be transfered
    --                           based on generic C_NUM_TRANSFER_BITS
    ----------------------------
    OTHER_RATIO_SCK_CYCLE_COUNT_PROCESS: process(Bus2IP_Clk) is
    -----
    begin
    -----
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(Soft_Reset_op = RESET_ACTIVE)or
               (SPIXfer_done_int = '1')      or
               (transfer_start = '0') then
                 Count <= (others => '0');
             --elsif (transfer_start = '0') then
             --        Count <= (others => '0');
             elsif (Count_trigger_pulse = '1') and (Count(COUNT_WIDTH) = '0') then
                     Count <=  Count + 1;
             end if;
         end if;
    end process OTHER_RATIO_SCK_CYCLE_COUNT_PROCESS;
    ------------------------------------

    -------------------------------------------------------------------------------
    -- SCK_SET_RESET_PROCESS : Sync set/reset toggle flip flop controlled by
    --                         transfer_start signal
    --------------------------
    OTHER_RATIO_SCK_SET_RESET_PROCESS: process(Bus2IP_Clk)is
    -----
    begin
    -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if((Soft_Reset_op = RESET_ACTIVE) or
               (Sync_Reset = '1')
               )then
                 sck_o_int <= '0';
            elsif(Sync_Set = '1') then
                 sck_o_int <= '1';
            elsif (transfer_start = '1') then
                  sck_o_int <= sck_o_int xor Count_trigger_pulse;
            end if;
        end if;
    end process OTHER_RATIO_SCK_SET_RESET_PROCESS;
    ----------------------------------

    -- DELAY_CLK: Delay the internal clock for a cycle to generate internal enable
    --         -- signal for data register.
    -------------
    OTHER_RATIO_DELAY_CLK: process(Bus2IP_Clk)is
    -----
    begin
    -----
       if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if (Soft_Reset_op = RESET_ACTIVE)then
             sck_d1 <= '0';
             sck_d2 <= '0';
          else
             sck_d1 <= sck_o_int;
             sck_d2 <= sck_d1;
          end if;
       end if;
    end process OTHER_RATIO_DELAY_CLK;
    ------------------------------------


    -- Rising egde pulse for CPHA-CPOL = 00/11 mode
    sck_rising_edge <= not(sck_d2) and  sck_d1;

    -- CAPT_RX_FE_MODE_00_11: The below logic is the date registery process for
    ------------------------- SPI CPHA-CPOL modes of 00 and 11.
    OTHER_RATIO_CAPT_RX_FE_MODE_00_11 : process(Bus2IP_Clk)is
    begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if (Soft_Reset_op = RESET_ACTIVE)then
                  rx_shft_reg_mode_0011 <= (others => '0');
            elsif((sck_rising_edge = '1') and
                  (transfer_start = '1')  and
                  (Data_Dir='0')  -- data direction = 0 is read mode
                  --(pr_state_data_receive = '1')
                  ) then
                 -------
                 if(mode_1 = '0' and mode_0 = '0')then     -- for Standard transfer
                    rx_shft_reg_mode_0011<= rx_shft_reg_mode_0011
                                       (1 to (C_NUM_TRANSFER_BITS-1)) &
                                                          IO1_I;-- MISO_I
                 elsif((mode_1 = '0' and mode_0 = '1') -- for Dual transfer
                       )then
                    rx_shft_reg_mode_0011<= rx_shft_reg_mode_0011
                                       (2 to (C_NUM_TRANSFER_BITS-1)) &
                                                         IO1_I &-- MSB first
                                                         IO0_I;
                 elsif((mode_1 = '1' and mode_0 = '0') -- for Quad transfer
                      )then
                    rx_shft_reg_mode_0011<= rx_shft_reg_mode_0011
                                      (4 to (C_NUM_TRANSFER_BITS-1)) &
                                                        IO3_I & -- MSB first
                                                        IO2_I &
                                                        IO1_I &
                                                        IO0_I;
                 end if;
                 -------
            else
                rx_shft_reg_mode_0011<= rx_shft_reg_mode_0011;
            end if;
        end if;
    end process OTHER_RATIO_CAPT_RX_FE_MODE_00_11;
    ---------------------------------------------------------------------
-------------------------------------------------------------------------------
-- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
--                             capture and shift operation for serial data
------------------------------
  OTHER_RATIO_CAP_QSPI_QUAD_MODE_NM_MEM_GEN: if (
                                                 (C_SPI_MODE = 2 or
                                                  C_SPI_MODE = 1) and
                                                  (C_SPI_MEMORY = 2)
                                                )generate
  --------------------------------------
  begin
  -----
  OTHER_RATIO_CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk) is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          else--if(
              --  (transfer_start = '1') and (not(Count(COUNT_WIDTH) = '1'))) then
              --if(Load_tx_data_to_shift_reg_int = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then
                      Shift_Reg   <= Transmit_Data;-- loading trasmit data in SR
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              -- Capture Data on even Count
              elsif(
                    (Count(0) = '0')
                   )then
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                      end if;
              -- Shift Data on odd Count
              elsif(
                    (Count(0) = '1')       and
                    (Count_trigger_pulse = '1')
                    ) then
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                          Shift_Reg   <= Shift_Reg
                                 (1 to C_NUM_TRANSFER_BITS -1) & IO1_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                 (2 to C_NUM_TRANSFER_BITS -1) & IO1_I
                                                               & IO0_I;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                 (4 to C_NUM_TRANSFER_BITS -1) & IO3_I
                                                               & IO2_I
                                                               & IO1_I
                                                               & IO0_I;
                      end if;
              end if;
          end if;
      end if;
  end process OTHER_RATIO_CAPTURE_AND_SHIFT_PROCESS;
  --------------------------------------------------
  end generate OTHER_RATIO_CAP_QSPI_QUAD_MODE_NM_MEM_GEN;
  -------------------------------------------------------
  OTHER_RATIO_CAP_QSPI_QUAD_MODE_SP_MEM_GEN: if (
                                                 (C_SPI_MODE = 2 or
                                                  C_SPI_MODE = 1) and
                                                  (
												  C_SPI_MEMORY = 3)
                                                )generate
  --------------------------------------
  begin
  -----
  OTHER_RATIO_CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk) is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          else--if(
              --  (transfer_start = '1') and (not(Count(COUNT_WIDTH) = '1'))) then
              --if(Load_tx_data_to_shift_reg_int = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then
                      Shift_Reg   <= Transmit_Data;-- loading trasmit data in SR
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              -- Capture Data on even Count
              elsif(
                    (Count(0) = '0')
                   )then
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                      end if;
              -- Shift Data on odd Count
              elsif(
                    (Count(0) = '1')       and
                    (Count_trigger_pulse = '1')
                    ) then
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                          Shift_Reg   <= Shift_Reg
                                 (1 to C_NUM_TRANSFER_BITS -1) & IO1_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                 (2 to C_NUM_TRANSFER_BITS -1) & IO1_I
                                                               & IO0_I;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                 (4 to C_NUM_TRANSFER_BITS -1) & IO3_I
                                                               & IO2_I
                                                               & IO1_I
                                                               & IO0_I;
                      end if;
              end if;
          end if;
      end if;
  end process OTHER_RATIO_CAPTURE_AND_SHIFT_PROCESS;
  --------------------------------------------------
  end generate OTHER_RATIO_CAP_QSPI_QUAD_MODE_SP_MEM_GEN;
  -------------------------------------------------------

  OTHER_RATIO_CAP_QSPI_QUAD_MODE_OTHER_MEM_GEN: if (
                                                     (C_SPI_MODE = 2 and
                                                      (C_SPI_MEMORY = 0
                                                       or
                                                       C_SPI_MEMORY = 1)
                                                     )
                                                     or
                                                     (C_SPI_MODE = 1 and
                                                      (C_SPI_MEMORY = 0
                                                       or
                                                       C_SPI_MEMORY = 1)
                                                     )
                                                    )generate
  --------------------------------------
  begin
  -----
  OTHER_RATIO_CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk) is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          else--if(
              --  (transfer_start = '1') and (not(Count(COUNT_WIDTH) = '1'))) then
              --if(Load_tx_data_to_shift_reg_int = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1')then
                      Shift_Reg   <= Transmit_Data;-- loading trasmit data in SR
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              -- Capture Data on even Count
              elsif(
                    (Count(0) = '0')
                   )then
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                      end if;
              -- Shift Data on odd Count
              elsif(
                    (Count(0) = '1')       and
                    (Count_trigger_pulse = '1')
                    ) then
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                          Shift_Reg   <= Shift_Reg
                                 (1 to C_NUM_TRANSFER_BITS -1) & IO1_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                 (2 to C_NUM_TRANSFER_BITS -1) & IO1_I
                                                               & IO0_I;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                 (4 to C_NUM_TRANSFER_BITS -1) & IO3_I
                                                               & IO2_I
                                                               & IO1_I
                                                               & IO0_I;
                      end if;
              end if;
          end if;
      end if;
  end process OTHER_RATIO_CAPTURE_AND_SHIFT_PROCESS;
  --------------------------------------------------
  end generate OTHER_RATIO_CAP_QSPI_QUAD_MODE_OTHER_MEM_GEN;
  -------------------------------------------------------

end generate OTHER_RATIO_GENERATE;
----------------------------------


--------------------------------------------------
PS_TO_NS_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            qspi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            qspi_cntrl_ps <= qspi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
pr_state_data_receive <= '1' when qspi_cntrl_ps = DATA_RECEIVE else
                         '0';
pr_state_non_idle     <= '1' when qspi_cntrl_ps /= IDLE else
                         '0';
pr_state_idle         <= '1' when qspi_cntrl_ps = IDLE else
                         '0';
pr_state_cmd_ph       <= '1' when qspi_cntrl_ps = CMD_SEND else
                         '0';

--------------------------------
QSPI_DUAL_MODE_MIXED_WB_MEM_GEN: if (C_SPI_MODE = 1 and
                                     (
                                       C_SPI_MEMORY = 0 or
                                       C_SPI_MEMORY = 1
                                      )
                                    )generate
--------------------------------
begin
-----

QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            CMD_decoded         ,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase         ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SR_6_Rx_Full        ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            ---------------------
                            qspi_cntrl_ps       ,
                            no_slave_selected
                            ---------------------
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     -------------
     stop_clock    <= '0';

     case qspi_cntrl_ps is
        when IDLE         => if((CMD_decoded = '1') and
                                 (CMD_Error = '0')-- proceed only when there is no command error
                                )then
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO1_T_control <= (CMD_Mode_1) or (not CMD_Mode_0);

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        if(SR_5_Tx_Empty = '1') then
                                            stop_clock <= SR_5_Tx_Empty;
                                            qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                        else
                                            qspi_cntrl_ns <= ADDR_SEND;
                                        end if;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                             --stop_clock    <= not SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')
                               )then
                                 if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else

                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and (Data_Phase='1')
                                    )then
                                     IO0_T_control <= '1';
                                     IO1_T_control <= '1';
                                     qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
                             ------------------------------------------------
        when TEMP_ADDR_SEND => --if((SPIXfer_done_int_pulse='1')
                               --  )then
                               --  if (no_slave_selected = '1')then
                               --         qspi_cntrl_ns <= IDLE;
                               --  else
                               --      stop_clock    <= SR_5_Tx_Empty;
                               --      if(SR_5_Tx_Empty='1')then
                               --          qspi_cntrl_ns <= TEMP_ADDR_SEND;
                               --      else
                               --          qspi_cntrl_ns <= ADDR_SEND;
                               --      end if;
                               --  end if;
                               --else
                               --    qspi_cntrl_ns <= TEMP_ADDR_SEND;
                               --end if;
                               mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;
        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;

                             --if(no_slave_selected = '1')then
                             --   qspi_cntrl_ns <= IDLE;
                             --else
                             --   qspi_cntrl_ns <= DATA_RECEIVE;
                             --end if;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;

        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------

pr_state_addr_ph <= '1' when (qspi_cntrl_ps = ADDR_SEND) else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------

end generate QSPI_DUAL_MODE_MIXED_WB_MEM_GEN;
------------------------------------------

--------------------------------------------------
QSPI_QUAD_MODE_MIXED_WB_MEM_GEN: if (C_SPI_MODE = 2 and
                                     (C_SPI_MEMORY = 1 or
                                      C_SPI_MEMORY = 0
                                      )
                                     )
                                  generate
-------------------
begin
-----
QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            CMD_decoded         ,
                            CMD_Error           ,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase         ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SR_6_Rx_Full        ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            ---------------------
                            qspi_cntrl_ps       ,
                            no_slave_selected
                            ---------------------
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     IO2_T_control <= '1';
     IO3_T_control <= '1';
     --------------
     stop_clock    <= '0';

     case qspi_cntrl_ps is
        when IDLE         => if((CMD_decoded = '1') and
                                 (CMD_Error = '0')-- proceed only when there is no command error
                                )then
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE; -- CMD_DECODE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO3_T_control <= not Quad_Phase;--

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                       if(SR_5_Tx_Empty = '1') then
                                            stop_clock <= SR_5_Tx_Empty;
                                            qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                        else
                                            qspi_cntrl_ns <= ADDR_SEND;
                                        end if;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
         when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                              mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                             IO2_T_control <= (not Addr_Mode_1);
                             IO3_T_control <= (not Addr_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1') and
                                 (Data_Phase='0')
                                )then
                                 if (no_slave_selected = '1')then
                                     qspi_cntrl_ns <= IDLE;
                                 else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                  if(
                                     (addr_cnt = "011") and -- 24 bit address
                                     (Addr_Bit='0')     and(Data_Phase='1')
                                     )then
                                         if((Data_Dir='1'))then
                                             mode_1 <= Data_Mode_1;
                                             mode_0 <= Data_Mode_0;
                                             IO0_T_control <= '0';              -- data output
                                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                                             IO2_T_control <= not (Data_Mode_1);-- active only
                                             IO3_T_control <= not (Data_Mode_1);-- active only
                                             qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                         else
                                             IO0_T_control <= '1';
                                             IO1_T_control <= '1';
                                             IO2_T_control <= '1';
                                             IO3_T_control <= '1';
                                             qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                         end if;
                                  -- -- coverage off
                                  -- -- below piece of code is for 32-bit address check, and left for future use
                                  -- elsif(
                                  --       (addr_cnt = "100") and -- 32 bit
                                  --       (Addr_Bit = '1')   and (Data_Phase='1')
                                  --       )then
                                  --         if((Data_Dir='1'))then
                                  --             qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                  --         else
                                  --             qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                  --         end if;
                                  -- -- coverage on
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                              end if;
                              ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                               IO2_T_control <= (not Addr_Mode_1);
                               IO3_T_control <= (not Addr_Mode_1);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;
        -----------------------------------------------------------------------
        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';              -- data output active only in Dual mode
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);-- active only in quad mode
                             IO3_T_control <= not (Data_Mode_1);-- active only in quad mode

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_SEND;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND => mode_1 <= Data_Mode_1;
                               mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';              -- data output active only in Dual mode
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);-- active only in quad mode
                             IO3_T_control <= not (Data_Mode_1);-- active only in quad mode

                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;
                             ------------------------------------------------
        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
------------------------------------------
end generate QSPI_QUAD_MODE_MIXED_WB_MEM_GEN;
------------------------------------------

--------------------------------------------------
QSPI_DUAL_MODE_NM_MEM_GEN: if C_SPI_MODE = 1 and (C_SPI_MEMORY = 2 )  generate
-------------------
begin
-----
QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            CMD_decoded         ,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SR_6_Rx_Full        ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps
                            ---------------------
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     --------------
     stop_clock    <= '0';
     --------------
     case qspi_cntrl_ps is
        when IDLE         => if((CMD_decoded = '1') and
                                 (CMD_Error = '0')-- proceed only when there is no command error
                                )then
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_1;

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        if(SR_5_Tx_Empty = '1') then
                                            stop_clock <= SR_5_Tx_Empty;
                                            qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                        else
                                            qspi_cntrl_ns <= ADDR_SEND;
                                        end if;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')
                               )then
                                 if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              IO0_T_control <= Data_Mode_1;
                                              IO1_T_control <= not(Data_Mode_0);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and (Data_Phase='1')
                                      ) then
                                          --if((Data_Dir='1'))then
                                          --    qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          --else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          --end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                   ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= Data_Mode_1;
                             IO1_T_control <= not(Data_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(no_slave_selected = '1')then
                                qspi_cntrl_ns <= IDLE;
                             else
                                qspi_cntrl_ns <= TEMP_DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND =>
                              mode_1 <= Data_Mode_1;
                              mode_0 <= Data_Mode_0;
                              IO0_T_control <= Data_Mode_1;
                              IO1_T_control <= not(Data_Mode_0);

                              stop_clock    <= stop_clock_reg;
                              if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                     mode_1 <= Data_Mode_1;
                                     mode_0 <= Data_Mode_0;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;

        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate QSPI_DUAL_MODE_NM_MEM_GEN;
--------------------------------
QSPI_DUAL_MODE_SP_MEM_GEN: if C_SPI_MODE = 1 and (C_SPI_MEMORY = 3)  generate
-------------------
begin
-----
QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            CMD_decoded         ,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SR_6_Rx_Full        ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps
                            ---------------------
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     --------------
     stop_clock    <= '0';
     --------------
     case qspi_cntrl_ps is
        when IDLE         => if((CMD_decoded = '1') and
                                 (CMD_Error = '0')-- proceed only when there is no command error
                                )then
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_1;

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        if(SR_5_Tx_Empty = '1') then
                                            stop_clock <= SR_5_Tx_Empty;
                                            qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                        else
                                            qspi_cntrl_ns <= ADDR_SEND;
                                        end if;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')
                               )then
                                 if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              IO0_T_control <= Data_Mode_1;
                                              IO1_T_control <= not(Data_Mode_0);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and (Data_Phase='1')
                                      ) then
                                          --if((Data_Dir='1'))then
                                          --    qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          --else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          --end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                   ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= Data_Mode_1;
                             IO1_T_control <= not(Data_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(no_slave_selected = '1')then
                                qspi_cntrl_ns <= IDLE;
                             else
                                qspi_cntrl_ns <= TEMP_DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND =>
                              mode_1 <= Data_Mode_1;
                              mode_0 <= Data_Mode_0;
                              IO0_T_control <= Data_Mode_1;
                              IO1_T_control <= not(Data_Mode_0);

                              stop_clock    <= stop_clock_reg;
                              if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                     mode_1 <= Data_Mode_1;
                                     mode_0 <= Data_Mode_0;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;

        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate QSPI_DUAL_MODE_SP_MEM_GEN;
--------------------------------

--------------------------------------------------
QSPI_QUAD_MODE_NM_MEM_GEN: if C_SPI_MODE = 2 and (C_SPI_MEMORY = 2 )generate
-------------------
begin
-----
QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            CMD_decoded         ,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase         ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps
                            ---------------------
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     IO2_T_control <= '1';
     IO3_T_control <= '1';
     -------------
     stop_clock    <= '0';

     case qspi_cntrl_ps is
        when IDLE          => if((CMD_decoded = '1') and
                                 (CMD_Error = '0')-- proceed only when there is no command error
                                )then
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO3_T_control <= not Quad_Phase;-- this is due to sending '1' on DQ3 line during command phase for Quad instructions only.

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        if(SR_5_Tx_Empty = '1') then
                                            stop_clock <= SR_5_Tx_Empty;
                                            qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                        else
                                            qspi_cntrl_ns <= ADDR_SEND;
                                        end if;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                             IO2_T_control <= (not Addr_Mode_1);
                             IO3_T_control <= (not Addr_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')
                               )then
                                 if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and
                                    (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;

                                              IO0_T_control <= '0';
                                              IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                                              IO2_T_control <= not (Data_Mode_1);
                                              IO3_T_control <= not (Data_Mode_1);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              --mode_1 <= Data_Mode_1;
                                              --mode_0 <= Data_Mode_0;
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and
                                       (Data_Phase='1')
                                      ) then
                                          --if((Data_Dir='1'))then
                                          --    qspi_cntrl_ns <= DATA_SEND; -- o/p
                                          --else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          --end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                     ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                               IO2_T_control <= (not Addr_Mode_1);
                               IO3_T_control <= (not Addr_Mode_1);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_SEND;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND=> mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE =>  mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;
                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        -- coverage off
        when others => qspi_cntrl_ns <= IDLE; -- CMD_DECODE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate QSPI_QUAD_MODE_NM_MEM_GEN;
---------------------------------------

QSPI_QUAD_MODE_SP_MEM_GEN: if C_SPI_MODE = 2 and (C_SPI_MEMORY = 3)generate
-------------------
begin
-----
QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            CMD_decoded         ,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase         ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps
                            ---------------------
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     IO2_T_control <= '1';
     IO3_T_control <= '1';
     -------------
     stop_clock    <= '0';

     case qspi_cntrl_ps is
        when IDLE          => if((CMD_decoded = '1') and
                                 (CMD_Error = '0')-- proceed only when there is no command error
                                )then
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO3_T_control <= not Quad_Phase;-- this is due to sending '1' on DQ3 line during command phase for Quad instructions only.

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        if(SR_5_Tx_Empty = '1') then
                                            stop_clock <= SR_5_Tx_Empty;
                                            qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                        else
                                            qspi_cntrl_ns <= ADDR_SEND;
                                        end if;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                             IO2_T_control <= (not Addr_Mode_1);
                             IO3_T_control <= (not Addr_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')
                               )then
                                 if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and
                                    (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;

                                              IO0_T_control <= '0';
                                              IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                                              IO2_T_control <= not (Data_Mode_1);
                                              IO3_T_control <= not (Data_Mode_1);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              --mode_1 <= Data_Mode_1;
                                              --mode_0 <= Data_Mode_0;
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and
                                       (Data_Phase='1')
                                      ) then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;

                                              IO0_T_control <= '0';
                                              IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                                              IO2_T_control <= not (Data_Mode_1);
                                              IO3_T_control <= not (Data_Mode_1);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                           else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                     ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                               IO2_T_control <= (not Addr_Mode_1);
                               IO3_T_control <= (not Addr_Mode_1);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_SEND;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND=> mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE =>  mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;
                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        -- coverage off
        when others => qspi_cntrl_ns <= IDLE; -- CMD_DECODE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate QSPI_QUAD_MODE_SP_MEM_GEN;
---------------------------------------

-------------------------------------------------------------------------------
-- RATIO_NOT_EQUAL_4_GENERATE : Logic to be used when C_SCK_RATIO is not equal
--                              to 4
-------------------------------
RATIO_NOT_EQUAL_4_GENERATE: if(C_SCK_RATIO /= 4) generate
-----
begin
-----


    SCK_O_NQ_4_NO_STARTUP_USED_DM: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    -------------------------------------------------------------------------------
    -- SCK_O_SELECT_PROCESS : Select the idle state (CPOL bit) when not transfering
    --                        data else select the clock for slave device
    -------------------------
    SCK_O_NQ_4_SELECT_PROCESS: process(--Mst_N_Slv         ,-- in master mode
                                       sck_o_int         ,-- value driven on sck_int
                                       CPOL              ,-- CPOL mode thr SPICR
                                       transfer_start    ,
                                       transfer_start_d1 ,
                                       Count(COUNT_WIDTH),
                                       pr_state_non_idle  -- State machine is in Non-idle state
                                      )is
    begin
            if((transfer_start = '1')    and
               (transfer_start_d1 = '1') and
               --(Count(COUNT_WIDTH) = '0')and
               (pr_state_non_idle = '1')
               ) then
                    sck_o_in <= sck_o_int;
            else
                    sck_o_in <= CPOL;
            end if;
    end process SCK_O_NQ_4_SELECT_PROCESS;
    ---------------------------------

    slave_mode <= not (Mst_N_Slv); -- create the reset condition by inverting the mst_n_slv signal. 1 - master mode, 0 - slave mode.
    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk). during slave mode no clock should be generated from the core.
    SCK_O_NE_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (â€™0â€™ or â€™1â€™)
          port map
                (
                 Q  => SCK_O_reg,   -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => sck_o_in     -- Data input
                );

    end generate SCK_O_NQ_4_NO_STARTUP_USED_DM;




    SCK_O_NQ_4_NO_STARTUP_USED: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 0) generate
    ----------------
    attribute IOB                         : string;
    attribute IOB of SCK_O_NE_4_FDRE_INST : label is "true";
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    -------------------------------------------------------------------------------
    -- SCK_O_SELECT_PROCESS : Select the idle state (CPOL bit) when not transfering
    --                        data else select the clock for slave device
    -------------------------
    SCK_O_NQ_4_SELECT_PROCESS: process(--Mst_N_Slv         ,-- in master mode
                                       sck_o_int         ,-- value driven on sck_int
                                       CPOL              ,-- CPOL mode thr SPICR
                                       transfer_start    ,
                                       transfer_start_d1 ,
                                       Count(COUNT_WIDTH),
                                       pr_state_non_idle  -- State machine is in Non-idle state
                                      )is
    begin
            if((transfer_start = '1')    and
               (transfer_start_d1 = '1') and
               --(Count(COUNT_WIDTH) = '0')and
               (pr_state_non_idle = '1')
               ) then
                    sck_o_in <= sck_o_int;
            else
                    sck_o_in <= CPOL;
            end if;
    end process SCK_O_NQ_4_SELECT_PROCESS;
    ---------------------------------

    slave_mode <= not (Mst_N_Slv); -- create the reset condition by inverting the mst_n_slv signal. 1 - master mode, 0 - slave mode.
    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk). during slave mode no clock should be generated from the core.
    SCK_O_NE_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (â€™0â€™ or â€™1â€™)
          port map
                (
                 Q  => SCK_O_reg,   -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => sck_o_in     -- Data input
                );

    end generate SCK_O_NQ_4_NO_STARTUP_USED;


    SCK_O_NQ_4_NO_STARTUP_USED_EXT: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    -------------------------------------------------------------------------------
    -- SCK_O_SELECT_PROCESS : Select the idle state (CPOL bit) when not transfering
    --                        data else select the clock for slave device
    -------------------------
    SCK_O_NQ_4_SELECT_PROCESS: process(--Mst_N_Slv         ,-- in master mode
                                       sck_o_int         ,-- value driven on sck_int
                                       CPOL              ,-- CPOL mode thr SPICR
                                       transfer_start    ,
                                       transfer_start_d1 ,
                                       Count(COUNT_WIDTH),
                                       pr_state_non_idle  -- State machine is in Non-idle state
                                      )is
    begin
            if((transfer_start = '1')    and
               (transfer_start_d1 = '1') and
               --(Count(COUNT_WIDTH) = '0')and
               (pr_state_non_idle = '1')
               ) then
                    sck_o_in <= sck_o_int;
            else
                    sck_o_in <= CPOL;
            end if;
    end process SCK_O_NQ_4_SELECT_PROCESS;
    ---------------------------------

    slave_mode <= not (Mst_N_Slv); -- create the reset condition by inverting the mst_n_slv signal. 1 - master mode, 0 - slave mode.
    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk). during slave mode no clock should be generated from the core.
    SCK_O_NE_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (â€™0â€™ or â€™1â€™)
          port map
                (
                 Q  => SCK_O_reg,   -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => sck_o_in     -- Data input
                );

    end generate SCK_O_NQ_4_NO_STARTUP_USED_EXT;


    -------------------------------

    SCK_O_NQ_4_STARTUP_USED: if (C_USE_STARTUP = 1) generate
    -------------
    begin
    -----
    -------------------------------------------------------------------------------
    -- SCK_O_SELECT_PROCESS : Select the idle state (CPOL bit) when not transfering
    --                        data else select the clock for slave device
    -------------------------
    SCK_O_NQ_4_SELECT_PROCESS: process(sck_o_int         ,
                                       CPOL              ,
                                       transfer_start    ,
                                       transfer_start_d1 ,
                                       Count(COUNT_WIDTH)
                                      )is
    begin
            if((transfer_start = '1')    and
               (transfer_start_d1 = '1') --and
               --(Count(COUNT_WIDTH) = '0')
               ) then
                    sck_o_in <= sck_o_int;
            else
                    sck_o_in <= CPOL;
            end if;
    end process SCK_O_NQ_4_SELECT_PROCESS;
    ---------------------------------

     ---------------------------------------------------------------------------
     -- SCK_O_FINAL_PROCESS : Register the final SCK_O_reg
     ------------------------
     SCK_O_NQ_4_FINAL_PROCESS: process(Bus2IP_Clk)
     -----
     begin
     -----
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
         --If Soft_Reset_op or slave Mode.Prevents SCK_O_reg to be generated in slave
            if((Soft_Reset_op = RESET_ACTIVE)
              ) then
                 SCK_O_reg <= '0';
            elsif((pr_state_non_idle='0') or  -- dont allow sck to go out when
                  (Mst_N_Slv = '0'))then      -- SM is in IDLE state or core in slave mode
                 SCK_O_reg <= '0';
            else
                 SCK_O_reg <= sck_o_in;
            end if;
         end if;
     end process SCK_O_NQ_4_FINAL_PROCESS;
     -------------------------------------
    end generate SCK_O_NQ_4_STARTUP_USED;
    -------------------------------------
end generate RATIO_NOT_EQUAL_4_GENERATE;


-------------------------------------------------------------------------------
-- RATIO_OF_4_GENERATE : Logic to be used when C_SCK_RATIO is equal to 4
------------------------
RATIO_OF_4_GENERATE: if(C_SCK_RATIO = 4) generate
-----
begin
-----
-------------------------------------------------------------------------------
-- SCK_O_FINAL_PROCESS : Select the idle state (CPOL bit) when not transfering
--                       data else select the clock for slave device
------------------------
-- A work around to reduce one clock cycle for sck_o generation. This would
-- allow for proper shifting of data bits into the slave device.
-- Removing the final stage F/F. Disadvantage of not registering final output
-------------------------------------------------------------------------------

    SCK_O_EQ_4_NO_STARTUP_USED_DM: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    SCK_O_EQ_4_FINAL_PROCESS: process(Mst_N_Slv         ,-- in master mode
                                      sck_o_int         ,-- value driven on sck_int
                                      CPOL              ,-- CPOL mode thr SPICR
                                      transfer_start    ,
                                      transfer_start_d1 ,
                                      Count(COUNT_WIDTH),
                                      pr_state_non_idle  -- State machine is in Non-idle state
                                      )is
   -----
   begin
   -----
    if(--(Mst_N_Slv = '1')         and
       (transfer_start = '1')    and
       (transfer_start_d1 = '1') and
       (Count(COUNT_WIDTH) = '0')and
       (pr_state_non_idle = '1')
      ) then
         SCK_O_1 <= sck_o_int;
    else
         SCK_O_1 <= CPOL and Mst_N_Slv;
    end if;
        end process SCK_O_EQ_4_FINAL_PROCESS;
        -------------------------------------

        slave_mode <= not (Mst_N_Slv);-- dont allow SPI clock to go out when core is in slave mode.

    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
        SCK_O_EQ_4_FDRE_INST : component FDRE
        generic map (
                    INIT => '0'
                    ) -- Initial value of register (â€™0â€™ or â€™1â€™)
        port map
                   (
                    Q  => SCK_O_reg,       -- Data output
                    C  => Bus2IP_Clk,  -- Clock input
                    CE => '1',         -- Clock enable input
                    R  => slave_mode,  -- Synchronous reset input
                    D  => SCK_O_1      -- Data input
                   );

   end generate SCK_O_EQ_4_NO_STARTUP_USED_DM;



    SCK_O_EQ_4_NO_STARTUP_USED: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 0) generate
    ----------------
    attribute IOB                         : string;
    attribute IOB of SCK_O_EQ_4_FDRE_INST : label is "true";
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    SCK_O_EQ_4_FINAL_PROCESS: process(Mst_N_Slv         ,-- in master mode
                                      sck_o_int         ,-- value driven on sck_int
                                      CPOL              ,-- CPOL mode thr SPICR
                                      transfer_start    ,
                                      transfer_start_d1 ,
                                      Count(COUNT_WIDTH),
                                      pr_state_non_idle  -- State machine is in Non-idle state
                                      )is
   -----
   begin
   -----
    if(--(Mst_N_Slv = '1')         and
       (transfer_start = '1')    and
       (transfer_start_d1 = '1') and
       (Count(COUNT_WIDTH) = '0')and
       (pr_state_non_idle = '1')
      ) then
         SCK_O_1 <= sck_o_int;
    else
         SCK_O_1 <= CPOL and Mst_N_Slv;
    end if;
        end process SCK_O_EQ_4_FINAL_PROCESS;
        -------------------------------------

        slave_mode <= not (Mst_N_Slv);-- dont allow SPI clock to go out when core is in slave mode.

    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
        SCK_O_EQ_4_FDRE_INST : component FDRE
        generic map (
                    INIT => '0'
                    ) -- Initial value of register (â€™0â€™ or â€™1â€™)
        port map
                   (
                    Q  => SCK_O_reg,       -- Data output
                    C  => Bus2IP_Clk,  -- Clock input
                    CE => '1',         -- Clock enable input
                    R  => slave_mode,  -- Synchronous reset input
                    D  => SCK_O_1      -- Data input
                   );

   end generate SCK_O_EQ_4_NO_STARTUP_USED;


    SCK_O_EQ_4_NO_STARTUP_USED_EXT: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    SCK_O_EQ_4_FINAL_PROCESS: process(Mst_N_Slv         ,-- in master mode
                                      sck_o_int         ,-- value driven on sck_int
                                      CPOL              ,-- CPOL mode thr SPICR
                                      transfer_start    ,
                                      transfer_start_d1 ,
                                      Count(COUNT_WIDTH),
                                      pr_state_non_idle  -- State machine is in Non-idle state
                                      )is
   -----
   begin
   -----
    if(--(Mst_N_Slv = '1')         and
       (transfer_start = '1')    and
       (transfer_start_d1 = '1') and
       (Count(COUNT_WIDTH) = '0')and
       (pr_state_non_idle = '1')
      ) then
         SCK_O_1 <= sck_o_int;
    else
         SCK_O_1 <= CPOL and Mst_N_Slv;
    end if;
        end process SCK_O_EQ_4_FINAL_PROCESS;
        -------------------------------------

        slave_mode <= not (Mst_N_Slv);-- dont allow SPI clock to go out when core is in slave mode.

    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
        SCK_O_EQ_4_FDRE_INST : component FDRE
        generic map (
                    INIT => '0'
                    ) -- Initial value of register (â€™0â€™ or â€™1â€™)
        port map
                   (
                    Q  => SCK_O_reg,       -- Data output
                    C  => Bus2IP_Clk,  -- Clock input
                    CE => '1',         -- Clock enable input
                    R  => slave_mode,  -- Synchronous reset input
                    D  => SCK_O_1      -- Data input
                   );

   end generate SCK_O_EQ_4_NO_STARTUP_USED_EXT;


   -----------------------------

   SCK_O_EQ_4_STARTUP_USED: if (C_USE_STARTUP = 1) generate
   -------------
   begin
   -----
        SCK_O_EQ_4_FINAL_PROCESS: process(Mst_N_Slv,            -- in master mode
                                          sck_o_int,            -- value driven on sck_int
                                          CPOL,                 -- CPOL mode thr SPICR
                                          transfer_start,
                                          transfer_start_d1,
                                          Count(COUNT_WIDTH)
                                          )is
        -----
        begin
        -----
                if(--(Mst_N_Slv = '1')         and
                   (transfer_start = '1')    and
                   (transfer_start_d1 = '1') --and
                   --(Count(COUNT_WIDTH) = '0')--and
                   --(pr_state_non_idle = '1')
                   )then
                        SCK_O_1 <= sck_o_int;
                else
                        SCK_O_1 <= CPOL and Mst_N_Slv;
                end if;
        end process SCK_O_EQ_4_FINAL_PROCESS;
        -------------------------------------

        ----------------------------------------------------------------------------
        -- SCK_RATIO_4_REG_PROCESS : The SCK is registered in SCK RATIO = 4 mode
        ----------------------------------------------------------------------------
        SCK_O_EQ_4_REG_PROCESS: process(Bus2IP_Clk)
        -----
        begin
        -----
                if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
                -- If Soft_Reset_op or slave Mode. Prevents SCK_O_reg to be generated in slave
                        if((Soft_Reset_op = RESET_ACTIVE)
                           ) then
                                SCK_O_reg <= '0';
                        elsif((pr_state_non_idle='0') or -- dont allow sck to go out when
                              (Mst_N_Slv = '0')          -- SM is in IDLE state or core in slave mode
                              )then
                                SCK_O_reg <= '0';
                        else
                                SCK_O_reg <= SCK_O_1;
                        end if;
                end if;
        end process SCK_O_EQ_4_REG_PROCESS;
        -----------------------------------
   end generate SCK_O_EQ_4_STARTUP_USED;
   -------------------------------------

end generate RATIO_OF_4_GENERATE;
---------------------
end architecture imp;
---------------------


--
----  SPI Module - entity/architecture pair
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
---- Filename:        qspi_mode_0_module.vhd
---- Version:         v3.0
---- Description:     Serial Peripheral Interface (SPI) Module for interfacing
----                  with a 32-bit AXI4 Bus.
----
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_unsigned.all;
    use ieee.numeric_std.all;
    use ieee.std_logic_misc.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.lib_pkg;
    use lib_pkg_v1_0_2.lib_pkg.log2;
library axi_lite_ipif_v3_0_4;
    use axi_lite_ipif_v3_0_4.axi_lite_ipif;
    use axi_lite_ipif_v3_0_4.ipif_pkg.all;


library lib_cdc_v1_0_2;
	use lib_cdc_v1_0_2.cdc_sync;

library unisim;
    use unisim.vcomponents.FD;
    use unisim.vcomponents.FDRE;
-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------:

--  C_SCK_RATIO                 --      2, 4, 16, 32, , , , 1024, 2048 SPI
--                                      clock ratio (16*N), where N=1,2,3...
--  C_SPI_NUM_BITS_REG              --      Width of SPI Control register
--                                      in this module
--  C_NUM_SS_BITS               --      Total number of SS-bits
--  C_NUM_TRANSFER_BITS         --      SPI Serial transfer width.
--                                      Can be 8, 16 or 32 bit wide

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------

-- SYSTEM

--  Bus2IP_Clk                  --      Bus to IP clock
--  Soft_Reset_op                       --      Soft_Reset_op Signal

-- OTHER INTERFACE

--  Slave_MODF_strobe           --      Slave mode fault strobe
--  MODF_strobe                 --      Mode fault strobe
--  SR_3_MODF                   --      Mode fault error flag
--  SR_5_Tx_Empty               --      Transmit Empty
--  Control_Reg                 --      Control Register
--  Slave_Select_Reg            --      Slave Select Register
--  Transmit_Data               --      Data Transmit Register Interface
--  Receive_Data                --      Data Receive Register Interface
--  SPIXfer_done                --      SPI transfer done flag
--  DTR_underrun                --      DTR underrun generation signal

-- SPI INTERFACE

--  SCK_I                       --      SPI Bus Clock Input
--  SCK_O_reg                       --      SPI Bus Clock Output
--  SCK_T                       --      SPI Bus Clock 3-state Enable
--                                      (3-state when high)
--  MISO_I                      --      Master out,Slave in Input
--  MISO_O                      --      Master out,Slave in Output
--  MISO_T                      --      Master out,Slave in 3-state Enable
--  MOSI_I                      --      Master in,Slave out Input
--  MOSI_O                      --      Master in,Slave out Output
--  MOSI_T                      --      Master in,Slave out 3-state Enable
--  SPISEL                      --      Local SPI slave select active low input
--                                      has to be initialzed to VCC
--  SS_I                        --      Input of slave select vector
--                                      of length N input where there are
--                                      N SPI devices,but not connected
--  SS_O                        --      One-hot encoded,active low slave select
--                                      vector of length N ouput
--  SS_T                        --      Single 3-state control signal for
--                                      slave select vector of length N
--                                      (3-state when high)
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity qspi_mode_0_module is
 generic
  (
    --C_SPI_MODE                  : integer;
    C_SCK_RATIO           : integer;
    C_NUM_SS_BITS         : integer;
    C_NUM_TRANSFER_BITS   : integer;
    C_USE_STARTUP         : integer;
    C_SPICR_REG_WIDTH     : integer;
    C_SUB_FAMILY          : string;
    C_FIFO_EXIST          : integer;
    C_DUAL_MODE           : integer;
    C_STARTUP_EXT         : integer
  );
 port
  (
    Bus2IP_Clk          : in  std_logic;
    Soft_Reset_op       : in  std_logic;
    ----------------------
    --  Control Reg is 10-bit wide

    SPICR_0_LOOP         : in std_logic;
    SPICR_1_SPE          : in std_logic;
    SPICR_2_MASTER_N_SLV : in std_logic;
    SPICR_3_CPOL         : in std_logic;
    SPICR_4_CPHA         : in std_logic;
    SPICR_5_TXFIFO_RST   : in std_logic;
    SPICR_6_RXFIFO_RST   : in std_logic;
    SPICR_7_SS           : in std_logic;
    SPICR_8_TR_INHIBIT   : in std_logic;
    SPICR_9_LSB          : in std_logic;
    ----------------------
    Rx_FIFO_Empty_i_no_fifo           : in  std_logic;
    SR_3_MODF           : in  std_logic;
    SR_5_Tx_Empty       : in  std_logic;
    Slave_MODF_strobe   : out std_logic;
    MODF_strobe         : out std_logic;
    SPIXfer_done_rd_tx_en: out std_logic;

    Slave_Select_Reg    : in  std_logic_vector(0 to (C_NUM_SS_BITS-1));
    Transmit_Data       : in  std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
    Receive_Data        : out std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
    SPIXfer_done        : out std_logic;
    DTR_underrun        : out std_logic;

    SPISEL_pulse_op     : out std_logic;
    SPISEL_d1_reg       : out std_logic;

  --SPI Interface
    SCK_I               : in  std_logic;
    SCK_O_reg               : out std_logic;
    SCK_T               : out std_logic;

    MISO_I              : in  std_logic;
    MISO_O              : out std_logic;
    MISO_T              : out std_logic;

    MOSI_I              : in  std_logic;
    MOSI_O              : out std_logic;
    MOSI_T              : out std_logic;

    SPISEL              : in  std_logic;

    SS_I                : in std_logic_vector((C_NUM_SS_BITS-1) downto 0);
    SS_O                : out std_logic_vector((C_NUM_SS_BITS-1) downto 0);
    SS_T                : out std_logic;

    control_bit_7_8     : in std_logic_vector(0 to 1);
    Mst_N_Slv_mode      : out std_logic;
    Rx_FIFO_Full        : in std_logic;
    reset_RcFIFO_ptr_to_spi : in std_logic;
    DRR_Overrun_reg     : out std_logic;
    tx_cntr_xfer_done : out std_logic

);
end qspi_mode_0_module;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture imp of qspi_mode_0_module is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Function Declarations
---------------------------------------------------------------------
------------------------
-- spcl_log2 : Performs log2(x) function for value of C_SCK_RATIO > 2
------------------------
function spcl_log2(x : natural) return integer is
    variable j  : integer := 0;
    variable k  : integer := 0;
begin
    if(C_SCK_RATIO /= 2) then
        for i in 0 to 11 loop
            if(2**i >= x) then
               if(k = 0) then
                  j := i;
               end if;
               k := 1;
            end if;
        end loop;
        return j;
    else
    -- coverage off
        return 2;
    -- coverage on
    end if;
end spcl_log2;

function log2(x : natural) return integer is
  variable i  : integer := 0; 
  variable val: integer := 1;
begin 
  if x = 0 then return 0;
  else
    for j in 0 to 29 loop -- for loop for XST 
      if val >= x then null; 
      else
        i := i+1;
        val := val*2;
      end if;
    end loop;
    assert val >= x
      report "Function log2 received argument larger" &
             " than its capability of 2^30. "
      severity failure;
  -- synthesis translate_on
    return i;
  end if;  
end function log2; 

-------------------------------------------------------------------------------
-- Constant Declarations
------------------------------------------------------------------
constant RESET_ACTIVE : std_logic := '1';
constant COUNT_WIDTH  : INTEGER   := log2(C_NUM_TRANSFER_BITS)+1;

-------------------------------------------------------------------------------
-- Signal Declarations
-------------------------------------------------------------------------------
signal Ratio_Count               : std_logic_vector
                                   (0 to (spcl_log2(C_SCK_RATIO))-2);
signal Count                     : std_logic_vector
                                   (COUNT_WIDTH downto 0)
                                   := (others => '0');
signal LSB_first                 : std_logic;
signal Mst_Trans_inhibit         : std_logic;
signal Manual_SS_mode            : std_logic;
signal CPHA                      : std_logic;
signal CPOL                      : std_logic;
signal Mst_N_Slv                 : std_logic;
signal SPI_En                    : std_logic;
signal Loop_mode                 : std_logic;
signal transfer_start            : std_logic;
signal transfer_start_d1         : std_logic;
signal transfer_start_pulse      : std_logic;
signal SPIXfer_done_int          : std_logic;
signal SPIXfer_done_int_d1       : std_logic;
signal SPIXfer_done_int_pulse    : std_logic;
signal SPIXfer_done_int_pulse_d1 : std_logic;
signal sck_o_int                 : std_logic;
signal sck_o_in                  : std_logic;
signal Count_trigger             : std_logic;
signal Count_trigger_d1          : std_logic;
signal Count_trigger_pulse       : std_logic;
signal Sync_Set                  : std_logic;
signal Sync_Reset                : std_logic;
signal Serial_Dout               : std_logic;
signal Serial_Din                : std_logic;
signal Shift_Reg                 : std_logic_vector
                                   (0 to C_NUM_TRANSFER_BITS-1);
signal SS_Asserted               : std_logic;
signal SS_Asserted_1dly          : std_logic;
signal Allow_Slave_MODF_Strobe   : std_logic;
signal Allow_MODF_Strobe         : std_logic;
signal Loading_SR_Reg_int        : std_logic;
signal sck_i_d1                  : std_logic;
signal spisel_d1                 : std_logic;
signal spisel_once_1             : std_logic;
signal spisel_pulse              : std_logic;
signal rising_edge_sck_i         : std_logic;
signal falling_edge_sck_i        : std_logic;
signal edge_sck_i                : std_logic;

signal MODF_strobe_int           : std_logic;
signal master_tri_state_en_control: std_logic;
signal slave_tri_state_en_control: std_logic;

-- following signals are added for use in variouos clock ratio modes.
signal sck_d1                    : std_logic;
signal sck_d2                    : std_logic;
signal sck_rising_edge           : std_logic;
signal rx_shft_reg               : std_logic_vector(0 to C_NUM_TRANSFER_BITS-1);
signal SPIXfer_done_int_pulse_d2 : std_logic;
signal SPIXfer_done_int_pulse_d3 : std_logic;

-- added synchronization signals for SPISEL and SCK_I
signal SPISEL_sync : std_logic;
signal SCK_I_sync : std_logic;

-- following register are declared for making data path clear in different modes
signal rx_shft_reg_s : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1))
                     :=(others => '0');
signal rx_shft_reg_mode_0011 : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1))
                     :=(others => '0');
signal rx_shft_reg_mode_0110 : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1))
                     :=(others => '0');

signal sck_fe1 : std_logic;
signal sck_d21 : std_logic:='0';
signal sck_d11 : std_logic:='0';

signal SCK_O_1 : std_logic:='0';

signal receive_Data_int  : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1))
                         :=(others => '0');
signal mosi_i_sync     : std_logic;
signal miso_i_sync     : std_logic;
signal serial_dout_int : std_logic;

--
signal Mst_Trans_inhibit_d1, Mst_Trans_inhibit_pulse : std_logic;
signal no_slave_selected : std_logic;
type STATE_TYPE is
                  (IDLE,       -- decode command can be combined here later
                   TRANSFER_OKAY,
                   TEMP_TRANSFER_OKAY
                   );
signal spi_cntrl_ps: STATE_TYPE;
signal spi_cntrl_ns: STATE_TYPE;
signal stop_clock_reg : std_logic;
signal stop_clock     : std_logic;
signal Rx_FIFO_Full_reg, DRR_Overrun_reg_int : std_logic;
signal transfer_start_d2 : std_logic;
signal transfer_start_d3 : std_logic;
signal SR_5_Tx_Empty_d1 : std_logic;
signal SR_5_Tx_Empty_pulse: std_logic;
signal SR_5_Tx_comeplete_Empty : std_logic;
signal falling_edge_sck_i_d1, rising_edge_sck_i_d1 : std_logic;
signal spisel_d2 : std_logic;
signal xfer_done_fifo_0 : std_logic;
signal rst_xfer_done_fifo_0 : std_logic;
signal Rx_FIFO_Empty_i_no_fifo_sync : std_logic;
signal SPIXfer_done_drr : std_logic;
-------------------------------------------------------------------------------
-- Architecture Starts
-------------------------------------------------------------------------------


begin

SPIXfer_done <= SPIXfer_done_drr;
--------------------------------------------------
LOCAL_TX_EMPTY_RX_FULL_FIFO_0_GEN: if C_FIFO_EXIST = 0 generate
-----
begin


    rx_empty_no_fifo_CDC: entity lib_cdc_v1_0_2.cdc_sync
    	    generic map (
    	        C_CDC_TYPE                  => 1 , -- 1 is level synch
    	        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
    	        C_SINGLE_BIT                => 1 , 
    	        C_FLOP_INPUT                => 0 ,
    	        C_VECTOR_WIDTH              => 1 ,
    	        C_MTBF_STAGES               => 2 
    			)
    	
    	    port map (
	        	        prmry_aclk           => '0',
	        	        prmry_resetn         => '0',
	        	        prmry_in             => Rx_FIFO_Empty_i_no_fifo,
	        	        scndry_aclk          => Bus2IP_Clk, 
				prmry_vect_in        => (others => '0' ),
	        	        scndry_resetn        => '0',
	        	        scndry_out           => Rx_FIFO_Empty_i_no_fifo_sync
	    );
         -----------------------------------------





-----------------------------------------
TX_EMPTY_MODE_0_P: process (Bus2IP_Clk)is
begin
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) or
          (transfer_start_pulse = '1') or
          (rst_xfer_done_fifo_0 = '1')then
            xfer_done_fifo_0 <= '0';
        elsif(SPIXfer_done_int_pulse = '1')then
            xfer_done_fifo_0 <= '1';
        end if;
     end if;
end process TX_EMPTY_MODE_0_P;
------------------------------


------------------------------
--RX_FULL_CHECK_PROCESS: process(Bus2IP_Clk) is
--begin
--     if(Bus2IP_Clk'event and Bus2IP_Clk='1') then
--         if (Soft_Reset_op = RESET_ACTIVE)or(reset_RcFIFO_ptr_to_spi = '1') then
--               Rx_FIFO_Full_reg <= '0';
--         elsif(SPIXfer_done_int_pulse = '1')then
--               Rx_FIFO_Full_reg <= '1';
--         end if;
--     end if;
--end process RX_FULL_CHECK_PROCESS;


RX_FULL_CHECK_PROCESS: process(Bus2IP_Clk) is
begin
     if(Bus2IP_Clk'event and Bus2IP_Clk='1') then
         if (Soft_Reset_op = RESET_ACTIVE) then
               Rx_FIFO_Full_reg <= '0';
        elsif(DRR_Overrun_reg_int = '1') then
              Rx_FIFO_Full_reg <= '0';
         elsif((SPIXfer_done_int_pulse = '1') and (Rx_FIFO_Empty_i_no_fifo_sync = '0'))then
               Rx_FIFO_Full_reg <= '1';
         end if;
     end if;
end process RX_FULL_CHECK_PROCESS;


DRR_OVERRUN_REG_PROCESS:process(Bus2IP_Clk) is
-----
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            DRR_Overrun_reg_int <= '0';
        else
            DRR_Overrun_reg_int <= not(DRR_Overrun_reg_int or Soft_Reset_op) and
                                                                Rx_FIFO_Full_reg and
                                                                SPIXfer_done_int_pulse_d1; --_d2;
                                                                --SPIXfer_done_int_pulse_d1; --_d2;
        end if;
    end if;
end process DRR_OVERRUN_REG_PROCESS;




--RX_FULL_CHECK_PROCESS: process(Bus2IP_Clk) is
--begin
--     if(Bus2IP_Clk'event and Bus2IP_Clk='1') then
--         if (Soft_Reset_op = RESET_ACTIVE)or(reset_RcFIFO_ptr_to_spi = '1') then
--         --if ((Soft_Reset_op = RESET_ACTIVE)or(reset_RcFIFO_ptr_to_spi = '1') or (Rx_FIFO_Full_reg = '1' and SPIXfer_done_int_pulse = '0'))  then
--         --if ((Soft_Reset_op = RESET_ACTIVE)or(reset_RcFIFO_ptr_to_spi = '1') or (Rx_FIFO_Empty_i_no_fifo = '1'))then
--               Rx_FIFO_Full_reg <= '0';
--         elsif(SPIXfer_done_int_pulse = '1')then
--               Rx_FIFO_Full_reg <= '1';
--	     elsif(Rx_FIFO_Empty_i_no_fifo = '1')then --Clear only if no simultaneous SPIXfer_done_int_pulse 
--               Rx_FIFO_Full_reg <= '0';
--         end if;
--     end if;
--end process RX_FULL_CHECK_PROCESS;



-----------------------------------
PS_TO_NS_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            spi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            spi_cntrl_ps <= spi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
SPI_STATE_MACHINE_P: process(
                             Mst_N_Slv,
                             stop_clock_reg,
                             spi_cntrl_ps,
                             no_slave_selected,
                             SR_5_Tx_Empty,
                             SPIXfer_done_int_pulse,
                             transfer_start_pulse,
                             xfer_done_fifo_0
                             )
begin
     stop_clock    <= '0';
     rst_xfer_done_fifo_0 <= '0';
     --------------------------
     case spi_cntrl_ps is
     --------------------------
     when IDLE               => if(SR_5_Tx_Empty = '0' and transfer_start_pulse = '1' and Mst_N_Slv = '1') then
                                    stop_clock   <= '0';
                                    spi_cntrl_ns <= TRANSFER_OKAY;
                                else
                                    stop_clock   <= SR_5_Tx_Empty;
                                    spi_cntrl_ns <= IDLE;
                                end if;
                                -------------------------------------
     when TRANSFER_OKAY      => if(SR_5_Tx_Empty = '1') then
                                    if(no_slave_selected = '1')then
                                        stop_clock   <= '1';
                                        spi_cntrl_ns <= IDLE;
                                    else
                                        spi_cntrl_ns <= TEMP_TRANSFER_OKAY;
                                    end if;
                                else
                                    spi_cntrl_ns <= TRANSFER_OKAY;
                                end if;
                                -------------------------------------
     when TEMP_TRANSFER_OKAY => stop_clock   <= stop_clock_reg;
                                if(SR_5_Tx_Empty='1')then
                                  stop_clock    <= xfer_done_fifo_0;
                                  if (no_slave_selected = '1')then
                                     spi_cntrl_ns <= IDLE;
                                  --code coverage -- elsif(SPIXfer_done_int_pulse='1')then
                                  --code coverage --    stop_clock    <= SR_5_Tx_Empty;
                                  --code coverage --     spi_cntrl_ns <= TEMP_TRANSFER_OKAY;
                                  else
                                     spi_cntrl_ns <= TEMP_TRANSFER_OKAY;
                                  end if;
                                else
                                   stop_clock    <= '0';
                                   rst_xfer_done_fifo_0 <= '1';
                                   spi_cntrl_ns <= TRANSFER_OKAY;
                               end if;
                                -------------------------------------
     -- coverage off
     when others             => spi_cntrl_ns <= IDLE;
     -- coverage on
                                -------------------------------------
     end case;
     --------------------------
end process SPI_STATE_MACHINE_P;
-----------------------------------------------



end generate LOCAL_TX_EMPTY_RX_FULL_FIFO_0_GEN;

-------------------------------------------------------------------------------
LOCAL_TX_EMPTY_FIFO_12_GEN: if C_FIFO_EXIST /= 0 generate
-----
begin
-----
xfer_done_fifo_0 <= '0';





--RX_FULL_CHECK_PROCESS: process(Bus2IP_Clk) is
------------------------
--begin
-------
--     if(Bus2IP_Clk'event and Bus2IP_Clk='1') then
--         if (Soft_Reset_op = RESET_ACTIVE) then
--               Rx_FIFO_Full_reg <= '0';
--         elsif(reset_RcFIFO_ptr_to_spi = '1') or (DRR_Overrun_reg_int = '1') then
--               Rx_FIFO_Full_reg <= '0';
--         elsif(SPIXfer_done_int_pulse = '1')and (Rx_FIFO_Full = '1') then
--               Rx_FIFO_Full_reg <= '1';
--         end if;
--     end if;
--end process RX_FULL_CHECK_PROCESS;
------------------------------------




--DRR_OVERRUN_REG_PROCESS:process(Bus2IP_Clk) is
-------
--begin
-------
--    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
--        if (Soft_Reset_op = RESET_ACTIVE) then
--            DRR_Overrun_reg_int <= '0';
--        else
--            DRR_Overrun_reg_int <= not(DRR_Overrun_reg_int or Soft_Reset_op) and
--                                                                Rx_FIFO_Full_reg and
--                                                                SPIXfer_done_int_pulse_d1; --_d2;
--                                                                --SPIXfer_done_int_pulse_d1; --_d2;
--        end if;
--    end if;
--end process DRR_OVERRUN_REG_PROCESS;


DRR_OVERRUN_REG_PROCESS:process(Bus2IP_Clk) is
-----
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            DRR_Overrun_reg_int <= '0';
        else
            DRR_Overrun_reg_int <= not(DRR_Overrun_reg_int or Soft_Reset_op) and
                                                                Rx_FIFO_Full and
                                                                SPIXfer_done_drr; --_d2;
        end if;
    end if;
end process DRR_OVERRUN_REG_PROCESS;






PS_TO_NS_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            spi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            spi_cntrl_ps <= spi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
SPI_STATE_MACHINE_P: process(
                             Mst_N_Slv		          ,
                             stop_clock_reg	          ,
                             spi_cntrl_ps	          ,
                             no_slave_selected	      ,
                             SR_5_Tx_Empty	          ,
                             SPIXfer_done_int_pulse   ,
                             transfer_start_pulse	  ,
			                 SPIXfer_done_int_pulse_d2,
			                 SR_5_Tx_comeplete_Empty,
			                 Loop_mode
                             )is
-----
begin
-----
     stop_clock    <= '0';
     --rst_xfer_done_fifo_0 <= '0';
     --------------------------
     case spi_cntrl_ps is
     --------------------------
     when IDLE               => if(SR_5_Tx_Empty = '0' and transfer_start_pulse = '1' and Mst_N_Slv = '1') then
                                    spi_cntrl_ns <= TRANSFER_OKAY;
                                    stop_clock   <= '0';
                                else
                                    stop_clock   <= SR_5_Tx_Empty;                                    
                                    spi_cntrl_ns <= IDLE;
                                end if;
                                -------------------------------------
     when TRANSFER_OKAY      => if(SR_5_Tx_Empty = '1') then
                                    --if(no_slave_selected = '1')then
				    if(SR_5_Tx_comeplete_Empty = '1' and 
				       SPIXfer_done_int_pulse_d2 = '1') then
                                        stop_clock   <= '1';
                                        spi_cntrl_ns <= IDLE;
                                    else
                                        spi_cntrl_ns <= TEMP_TRANSFER_OKAY;
                                    end if;
                                else
                                    spi_cntrl_ns <= TRANSFER_OKAY;
                                end if;
                                -------------------------------------
     when TEMP_TRANSFER_OKAY => stop_clock   <= stop_clock_reg;
                                --if(SR_5_Tx_Empty='1')then
				if(SR_5_Tx_comeplete_Empty='1')then
                                  -- stop_clock    <= xfer_done_fifo_0;
                                  if (Loop_mode = '1' and 
				                      SPIXfer_done_int_pulse_d2 = '1')then
                                        stop_clock    <= '1';
                                        spi_cntrl_ns  <= IDLE;
                                  elsif(SPIXfer_done_int_pulse_d2 = '1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     spi_cntrl_ns  <= TEMP_TRANSFER_OKAY;
                                  elsif(no_slave_selected = '1') then   
                                        stop_clock    <= '1';
                                        spi_cntrl_ns  <= IDLE;
                                  else
                                     spi_cntrl_ns <= TEMP_TRANSFER_OKAY;
                                  end if;
                                else
                                   --stop_clock    <= '0';
                                   --rst_xfer_done_fifo_0 <= '1';
                                   spi_cntrl_ns <= TRANSFER_OKAY;
                                end if;
                                -------------------------------------
     -- coverage off
     when others             => spi_cntrl_ns <= IDLE;
     -- coverage on
                                -------------------------------------
     end case;
     --------------------------
end process SPI_STATE_MACHINE_P;
----------------------------------------
----------------------------------------


end generate LOCAL_TX_EMPTY_FIFO_12_GEN;
-----------------------------------------



SR_5_TX_EMPTY_PROCESS: process(Bus2IP_Clk)is
-----
begin
-----
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            SR_5_Tx_Empty_d1 <= '0';
        else
            SR_5_Tx_Empty_d1 <= SR_5_Tx_Empty;
        end if;
    end if;
end process SR_5_TX_EMPTY_PROCESS;
----------------------------------
SR_5_Tx_Empty_pulse <= SR_5_Tx_Empty_d1 and not (SR_5_Tx_Empty);
----------------------------------
-------------------------------------------------------------------------------
-- Combinatorial operations
-------------------------------------------------------------------------------
-----------------------------------------------------------
LSB_first                       <= SPICR_9_LSB;          -- Control_Reg(0);
Mst_Trans_inhibit               <= SPICR_8_TR_INHIBIT;   -- Control_Reg(1);
Manual_SS_mode                  <= SPICR_7_SS;           -- Control_Reg(2);
CPHA                            <= SPICR_4_CPHA;         -- Control_Reg(5);
CPOL                            <= SPICR_3_CPOL;         -- Control_Reg(6);
Mst_N_Slv                       <= SPICR_2_MASTER_N_SLV; -- Control_Reg(7);
SPI_En                          <= SPICR_1_SPE;          -- Control_Reg(8);
Loop_mode                       <= SPICR_0_LOOP;         -- Control_Reg(9);
Mst_N_Slv_mode                  <= SPICR_2_MASTER_N_SLV; -- Control_Reg(7);
-----------------------------------------------------------
MOSI_O                          <= Serial_Dout;
MISO_O                          <= Serial_Dout;

Receive_Data <= receive_Data_int;
DRR_Overrun_reg <= DRR_Overrun_reg_int;

    MST_TRANS_INHIBIT_D1_I: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => Mst_Trans_inhibit_d1,
        C  => Bus2IP_Clk,
        D  => Mst_Trans_inhibit
        );
    Mst_Trans_inhibit_pulse <= Mst_Trans_inhibit and (not Mst_Trans_inhibit_d1);
    -------------------------------------------------------------------------------

--* -------------------------------------------------------------------------------
--* -- MASTER_TRIST_EN_PROCESS : If not master make tristate enabled
--* ----------------------------
master_tri_state_en_control <=
                     '0' when
                     (
                      (control_bit_7_8(0)='1') and -- decides master/slave mode
                      (control_bit_7_8(1)='1') and -- decide the spi_en
                      ((MODF_strobe_int or SR_3_MODF)='0') and --no mode fault
                      (Loop_mode = '0')
                     ) else
                     '1';

--SPI_TRISTATE_CONTROL_II : Tri-state register for SCK_T, ideal state-deactive
SPI_TRISTATE_CONTROL_II: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => SCK_T,
        C  => Bus2IP_Clk,
        D  => master_tri_state_en_control
        );
--SPI_TRISTATE_CONTROL_III: tri-state register for MOSI, ideal state-deactive
SPI_TRISTATE_CONTROL_III: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => MOSI_T,
        C  => Bus2IP_Clk,
        D  => master_tri_state_en_control
        );
--SPI_TRISTATE_CONTROL_IV: tri-state register for SS,ideal state-deactive
SPI_TRISTATE_CONTROL_IV: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => SS_T,
        C  => Bus2IP_Clk,
        D  => master_tri_state_en_control
        );
--* -------------------------------------------------------------------------------
--* -- SLAVE_TRIST_EN_PROCESS : If slave mode, then make tristate enabled
--* ---------------------------
slave_tri_state_en_control <=
                          '0' when
                          (
                           (control_bit_7_8(0)='0') and -- decides master/slave
                           (control_bit_7_8(1)='1') and -- decide the spi_en
                           (SPISEL_sync = '0')      and
                           (Loop_mode = '0')
                           ) else
                           '1';
--SPI_TRISTATE_CONTROL_V: tri-state register for MISO, ideal state-deactive
SPI_TRISTATE_CONTROL_V: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => MISO_T,
        C  => Bus2IP_Clk,
        D  => slave_tri_state_en_control
        );
-------------------------------------------------------------------------------
DTR_COMPLETE_EMPTY_P:process(Bus2IP_Clk)is
begin
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1')then
         if(SR_5_Tx_Empty = '1' and SPIXfer_done_int_pulse = '1')then
             SR_5_Tx_comeplete_Empty <= '1';
         elsif(SR_5_Tx_Empty = '0')then
             SR_5_Tx_comeplete_Empty <= '0';
         end if;
     end if;
end process DTR_COMPLETE_EMPTY_P;
---------------------------------
DTR_UNDERRUN_FIFO_0_GEN: if C_FIFO_EXIST = 0 generate
begin
-- DTR_UNDERRUN_PROCESS_P : For Generating DTR underrun error
-------------------------
DTR_UNDERRUN_PROCESS_P: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if((Soft_Reset_op = RESET_ACTIVE) or
           (SPISEL_sync = '1')    or
           (Mst_N_Slv = '1')--master mode
           ) then
            DTR_underrun <= '0';
        elsif((Mst_N_Slv = '0') and (SPI_En = '1')) then-- slave mode
            if (SR_5_Tx_comeplete_Empty = '1') then
                --if(SPIXfer_done_int_pulse_d2 = '1') then
                    DTR_underrun <= '1';
                --end if;
            else
                DTR_underrun <= '0';
            end if;
        end if;
    end if;
end process DTR_UNDERRUN_PROCESS_P;
-------------------------------------
end generate DTR_UNDERRUN_FIFO_0_GEN;

DTR_UNDERRUN_FIFO_EXIST_GEN: if C_FIFO_EXIST /= 0 generate
begin
-- DTR_UNDERRUN_PROCESS_P : For Generating DTR underrun error
-------------------------
DTR_UNDERRUN_PROCESS_P: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if((Soft_Reset_op = RESET_ACTIVE) or
           (SPISEL_sync = '1')    or
           (Mst_N_Slv = '1')--master mode
           ) then
            DTR_underrun <= '0';
        elsif((Mst_N_Slv = '0') and (SPI_En = '1')) then-- slave mode
            if (SR_5_Tx_comeplete_Empty = '1') then
                if(SPIXfer_done_int_pulse = '1') then
                    DTR_underrun <= '1';
                end if;
            else
                DTR_underrun <= '0';
            end if;
        end if;
    end if;
end process DTR_UNDERRUN_PROCESS_P;
-------------------------------------
end generate DTR_UNDERRUN_FIFO_EXIST_GEN;

-------------------------------------------------------------------------------
-- SPISEL_SYNC: first synchronize the incoming signal, this is required is slave
--------------- mode of the core.

SPISEL_REG: component FD
   generic map
        (
        INIT => '1' -- default '1' to make the device in default master mode
        )
   port map
        (
        Q  => SPISEL_sync,
        C  => Bus2IP_Clk,
        D  => SPISEL
        );

---- SPISEL_DELAY_1CLK_PROCESS_P : Detect active SCK edge in slave mode
-------------------------------
SPISEL_DELAY_1CLK_PROCESS_P: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            spisel_d1 <= '1';
            spisel_d2 <= '1';
        else
            spisel_d1 <= SPISEL_sync;
            spisel_d2 <= spisel_d1;
        end if;
    end if;
end process SPISEL_DELAY_1CLK_PROCESS_P;


--SPISEL_DELAY_1CLK: component FD
--   generic map
--        (
--        INIT => '1' -- default '1' to make the device in default master mode
--        )
--   port map
--        (
--        Q  => spisel_d1,
--        C  => Bus2IP_Clk,
--        D  => SPISEL_sync
--        );

--SPISEL_DELAY_2CLK: component FD
--   generic map
--        (
--        INIT => '1' -- default '1' to make the device in default master mode
--        )
--   port map
--        (
--        Q  => spisel_d2,
--        C  => Bus2IP_Clk,
--        D  => spisel_d1
--        );

---- spisel pulse generating logic
---- this one clock cycle pulse will be available for data loading into
---- shift register
--spisel_pulse <= (not SPISEL_sync) and spisel_d1;
------------------------------------------------
-- spisel pulse generating logic
-- this one clock cycle pulse will be available for data loading into
-- shift register
spisel_pulse <= (not spisel_d1) and spisel_d2;
SPISEL_ONCE: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            spisel_once_1 <= '1';
        else if(spisel_pulse = '1') then
            spisel_once_1 <= '0';
        end if;
        end if;
    end if;
end process SPISEL_ONCE;
-- --------|__________ -- SPISEL
-- ----------|________ -- SPISEL_sync
-- -------------|_____ -- spisel_d1
-- ----------------|___-- spisel_d2
-- _____________|--|__ -- SPISEL_pulse_op
SPISEL_pulse_op       <= spisel_pulse;
SPISEL_d1_reg         <= spisel_d2;
-------------------------------------------------------------------------------
--SCK_I_SYNC: first synchronize incomming signal
-------------

SCK_I_REG: component FD
   generic map
        (
        INIT => '0'
        )
   port map
        (
        Q  => SCK_I_sync,
        C  => Bus2IP_Clk,
        D  => SCK_I
        );
------------------------------------------------------------------
-- SCK_I_DELAY_1CLK_PROCESS : Detect active SCK edge in slave mode on +ve edge

SCK_I_DELAY_1CLK_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            sck_i_d1 <= '0';
        else
            sck_i_d1 <= SCK_I_sync;
        end if;
    end if;
end process SCK_I_DELAY_1CLK_PROCESS;

-------------------------------------------------------------------------------
-- RISING_EDGE_CLK_RATIO_4_GEN: to synchronise the incoming clock signal in
--                              slave mode in SCK ratio = 4
RISING_EDGE_CLK_RATIO_4_GEN : if C_SCK_RATIO = 4 generate
begin
     -- generate a SCK control pulse for rising edge as well as falling edge
   rising_edge_sck_i  <= SCK_I and (not(SCK_I_sync)) and (not(SPISEL_sync));
   falling_edge_sck_i <= (not(SCK_I) and SCK_I_sync) and (not(SPISEL_sync));
end generate RISING_EDGE_CLK_RATIO_4_GEN;
-------------------------------------------------------------------------------

-- RISING_EDGE_CLK_RATIO_OTHERS_GEN: Due to timing crunch, in SCK> 4 mode,
--                                   the incoming clock signal cant be synchro
--                                   -nized with internal AXI clock.
--                                   slave mode operation on SCK_RATIO=2 isn't
--                                   supported in the core.
RISING_EDGE_CLK_RATIO_OTHERS_GEN: if ((C_SCK_RATIO /= 2) and (C_SCK_RATIO /= 4))
                                   generate
begin
     -- generate a SCK control pulse for rising edge as well as falling edge
   rising_edge_sck_i  <= SCK_I_sync and (not(sck_i_d1)) and (not(SPISEL_sync));
   falling_edge_sck_i <= (not(SCK_I_sync) and sck_i_d1) and (not(SPISEL_sync));
end generate RISING_EDGE_CLK_RATIO_OTHERS_GEN;
-------------------------------------------------------------------------------

-- combine rising edge as well as falling edge as a single signal
edge_sck_i         <= rising_edge_sck_i or falling_edge_sck_i;
no_slave_selected <= and_reduce(Slave_Select_Reg(0 to (C_NUM_SS_BITS-1)));
-------------------------------------------------------------------------------
-- TRANSFER_START_PROCESS : Generate transfer start signal. When the transfer
--                          gets completed, SPI Transfer done strobe pulls
--                          transfer_start back to zero.
---------------------------
TRANSFER_START_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op             = RESET_ACTIVE or
            (
             Mst_N_Slv         = '1' and  -- If Master Mode
             (
              SPI_En            = '0' or  -- enable not asserted or
              (SPIXfer_done_int = '1' and SR_5_Tx_Empty = '1') or  -- no data in Tx reg/FIFO or
              -------------------- To remove glitch----------------((SPIXfer_done_int = '1' or SPIXfer_done_int_pulse_d1 = '1' ) and SR_5_Tx_Empty = '1') or  -- no data in Tx reg/FIFO or
              SR_3_MODF         = '1' or  -- mode fault error
              Mst_Trans_inhibit = '1' or    -- Do not start if Mst xfer inhibited
              stop_clock        = '1'
             )
            ) or
            (
             Mst_N_Slv         = '0' and  -- If Slave Mode
             (
              SPI_En            = '0'   -- enable not asserted or
             )
            )
          )then

            transfer_start <= '0';
        else
-- Delayed SPIXfer_done_int_pulse to work for synchronous design and to remove
-- asserting of loading_sr_reg in master mode after SR_5_Tx_Empty goes to 1
              --if((SPIXfer_done_int_pulse = '1')    or
              --   (SPIXfer_done_int_pulse_d1 = '1') or
              --   (SPIXfer_done_int_pulse_d2='1')) then-- this is added to remove
              --                                        -- glitch at the end of
              --                                        -- transfer in AUTO mode
              --        transfer_start <= '0'; -- Set to 0 for at least 1 period
              --  else
                      transfer_start <= '1'; -- Proceed with SPI Transfer
              --  end if;
        end if;
    end if;
end process TRANSFER_START_PROCESS;

-------------------------------------------------------------------------------
-- TRANSFER_START_1CLK_PROCESS : Delay transfer start by 1 clock cycle
--------------------------------
TRANSFER_START_1CLK_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            transfer_start_d1 <= '0';
                transfer_start_d2 <= '0';
                transfer_start_d3 <= '0';
        else
            transfer_start_d1 <= transfer_start;
                transfer_start_d2 <= transfer_start_d1;
                transfer_start_d3 <= transfer_start_d2;
        end if;
    end if;
end process TRANSFER_START_1CLK_PROCESS;

-- transfer start pulse generating logic
transfer_start_pulse <= transfer_start and (not(transfer_start_d1));

---------------------------------------------------------------------------------
---- TRANSFER_DONE_PROCESS : Generate SPI transfer done signal
----------------------------
--TRANSFER_DONE_PROCESS: process(Bus2IP_Clk)
--begin
--    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
--        if(Soft_Reset_op = RESET_ACTIVE or transfer_start_pulse = '1' or (and_reduce(Count(COUNT_WIDTH-1 downto (COUNT_WIDTH-COUNT_WIDTH)))='1')) then
--            SPIXfer_done_int <= '0';
--        --elsif (transfer_start_pulse = '1') then
--        --    SPIXfer_done_int <= '0';
--        elsif(and_reduce(Count((COUNT_WIDTH-1) downto (COUNT_WIDTH-COUNT_WIDTH+1))) = '1') then --(Count(COUNT_WIDTH) = '1') then
--            SPIXfer_done_int <= '1';
--        end if;
--    end if;
--end process TRANSFER_DONE_PROCESS;

-------------------------------------------------------------------------------
-- TRANSFER_DONE_1CLK_PROCESS : Delay SPI transfer done signal by 1 clock cycle
-------------------------------
TRANSFER_DONE_1CLK_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            SPIXfer_done_int_d1 <= '0';
        else
            SPIXfer_done_int_d1 <= SPIXfer_done_int;
        end if;
    end if;
end process TRANSFER_DONE_1CLK_PROCESS;
--
-- transfer done pulse generating logic
SPIXfer_done_int_pulse <= SPIXfer_done_int and (not(SPIXfer_done_int_d1));

-------------------------------------------------------------------------------
-- TRANSFER_DONE_PULSE_DLY_PROCESS : Delay SPI transfer done pulse by 1 and 2
--                                   clock cycles
------------------------------------
-- Delay the Done pulse by a further cycle. This is used as the output Rx
-- data strobe when C_SCK_RATIO = 2
TRANSFER_DONE_PULSE_DLY_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE) then
            SPIXfer_done_int_pulse_d1 <= '0';
            SPIXfer_done_int_pulse_d2 <= '0';
            SPIXfer_done_int_pulse_d3 <= '0';
        else
            SPIXfer_done_int_pulse_d1 <= SPIXfer_done_int_pulse;
            SPIXfer_done_int_pulse_d2 <= SPIXfer_done_int_pulse_d1;
            SPIXfer_done_int_pulse_d3 <= SPIXfer_done_int_pulse_d2;
        end if;
    end if;
end process TRANSFER_DONE_PULSE_DLY_PROCESS;

-------------------------------------------------------------------------------
-- RX_DATA_GEN1: Only for C_SCK_RATIO = 2 mode.
----------------

RX_DATA_SCK_RATIO_2_GEN1 : if C_SCK_RATIO = 2 generate
begin
-----
TRANSFER_DONE_8:  if C_NUM_TRANSFER_BITS = 8 generate 
TRANSFER_DONE_PROCESS_8: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE or transfer_start_pulse = '1' or SPIXfer_done_int = '1') then -- or (and_reduce(Count(COUNT_WIDTH-1 downto (COUNT_WIDTH-COUNT_WIDTH)))='1')) then
            SPIXfer_done_int <= '0';
       elsif  (Count(COUNT_WIDTH-1) = '1' and
	           Count(COUNT_WIDTH-2) = '1' and
	           Count(COUNT_WIDTH-3) = '1' and 
	           Count(COUNT_WIDTH-4) = '0') then
            SPIXfer_done_int <= '1';
        end if;
    end if;
end process TRANSFER_DONE_PROCESS_8;
end generate TRANSFER_DONE_8;

TRANSFER_DONE_16:  if C_NUM_TRANSFER_BITS = 16 generate 
TRANSFER_DONE_PROCESS_16: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE or transfer_start_pulse = '1' or SPIXfer_done_int = '1') then -- or (and_reduce(Count(COUNT_WIDTH-1 downto (COUNT_WIDTH-COUNT_WIDTH)))='1')) then
            SPIXfer_done_int <= '0';
       elsif  (Count(COUNT_WIDTH-1) = '1' and
	           Count(COUNT_WIDTH-2) = '1' and
	           Count(COUNT_WIDTH-3) = '1' and 
	           Count(COUNT_WIDTH-4) = '1' and 
	           Count(COUNT_WIDTH-5) = '0') then
            SPIXfer_done_int <= '1';
        end if;
    end if;
end process TRANSFER_DONE_PROCESS_16;
end generate TRANSFER_DONE_16;

TRANSFER_DONE_32:  if C_NUM_TRANSFER_BITS = 32 generate 
TRANSFER_DONE_PROCESS_32: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if(Soft_Reset_op = RESET_ACTIVE or transfer_start_pulse = '1' or SPIXfer_done_int = '1') then -- or (and_reduce(Count(COUNT_WIDTH-1 downto (COUNT_WIDTH-COUNT_WIDTH)))='1')) then
            SPIXfer_done_int <= '0';
       elsif  (Count(COUNT_WIDTH-1) = '1' and
	           Count(COUNT_WIDTH-2) = '1' and
	           Count(COUNT_WIDTH-3) = '1' and 
	           Count(COUNT_WIDTH-4) = '1' and 
	           Count(COUNT_WIDTH-5) = '1' and 
	           Count(COUNT_WIDTH-6) = '0') then
            SPIXfer_done_int <= '1';
        end if;
    end if;
end process TRANSFER_DONE_PROCESS_32;
end generate TRANSFER_DONE_32;



-- This is mux to choose the data register for SPI mode 00,11 and 01,10.
 rx_shft_reg <= rx_shft_reg_mode_0011
              when ((CPOL = '0' and CPHA = '0') or (CPOL = '1' and CPHA = '1'))
              else rx_shft_reg_mode_0110
              when ((CPOL = '0' and CPHA = '1') or (CPOL = '1' and CPHA = '0'))
              else
              (others=>'0');

-- RECEIVE_DATA_STROBE_PROCESS : Strobe data from shift register to receive
--                               data register
--------------------------------
-- For a SCK ratio of 2 the Done needs to be delayed by an extra cycle
-- due to the serial input being captured on the falling edge of the PLB
-- clock. this is purely required for dealing with the real SPI slave memories.

 RECEIVE_DATA_STROBE_PROCESS: process(Bus2IP_Clk)
 begin
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
           if(Loop_mode = '1') then
		     if(SPIXfer_done_int_pulse_d1 = '1') then
              if (LSB_first = '1') then
                 for i in 0 to C_NUM_TRANSFER_BITS-1 loop
                   receive_Data_int(i) <= Shift_Reg(C_NUM_TRANSFER_BITS-1-i);
                 end loop;
              else
                   receive_Data_int <= Shift_Reg;
              end if;
             end if;
           else
		     if(SPIXfer_done_int_pulse_d2 = '1') then
              if (LSB_first = '1') then
                for i in 0 to C_NUM_TRANSFER_BITS-1 loop
                  receive_Data_int(i) <= rx_shft_reg(C_NUM_TRANSFER_BITS-1-i);
                end loop;
              else
                  receive_Data_int <= rx_shft_reg;
              end if;
           end if;
        end if;
     end if;
 end process RECEIVE_DATA_STROBE_PROCESS;

    -- Done strobe delayed to match receive data
    SPIXfer_done_drr <= SPIXfer_done_int_pulse_d3;
    SPIXfer_done_rd_tx_en <= transfer_start_pulse or SPIXfer_done_int_pulse_d3; -- SPIXfer_done_int_pulse_d1;
    tx_cntr_xfer_done <= transfer_start_pulse or SPIXfer_done_int_pulse_d3;
--RatioSlave_2_GEN : if (Mst_N_Slv = '0') generate
--begin
---ratio count for spi = 2
-------------------------------------------------------------------------------
-- RATIO_COUNT_PROCESS : Counter which counts from (C_SCK_RATIO/2)-1 down to 0
--                       Used for counting the time to control SCK_O_reg generation
--                       depending on C_SCK_RATIO
------------------------
  RATIO_COUNT_PROCESS_SPI2: process(Bus2IP_Clk)is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
              Ratio_Count <= "1";
          else if(Ratio_Count = "1" and Mst_N_Slv = '0') then
              Ratio_Count <= "0"; --not (Ratio_Count);-- - 1;
          else
              Ratio_Count <= "1";--not (Ratio_Count);-- - 1;
          end if;
          end if;
      end if;
  end process RATIO_COUNT_PROCESS_SPI2;

-------------------------------------------------------------------------------
-- COUNT_TRIGGER_GEN_PROCESS : Generate a trigger whenever Ratio_Count reaches
--                             zero
------------------------------
  COUNT_TRIGGER_GEN_SCK2_PROCESS: process(Bus2IP_Clk)is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
              Count_trigger <= '0';
          elsif(Ratio_Count = 0 and Mst_N_Slv = '0') then
              Count_trigger <= not Count_trigger;
          end if;
      end if;
  end process COUNT_TRIGGER_GEN_SCK2_PROCESS;

-------------------------------------------------------------------------------
-- COUNT_TRIGGER_1CLK_PROCESS : Delay cnt_trigger signal by 1 clock cycle
-------------------------------
  COUNT_TRIGGER_1CLK_SCK2_PROCESS: process(Bus2IP_Clk)is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
              Count_trigger_d1 <= '0';
          else
              Count_trigger_d1 <=  Count_trigger;
          end if;
      end if;
  end process COUNT_TRIGGER_1CLK_SCK2_PROCESS;

 -- generate a trigger pulse for rising edge as well as falling edge
   Count_trigger_pulse <= (Count_trigger and (not(Count_trigger_d1))) or
                         ((not(Count_trigger)) and Count_trigger_d1);
--end generate RatioSlave_2_GEN;
-------------------------------------------------
end generate RX_DATA_SCK_RATIO_2_GEN1;
-------------------------------------------------------------------------------

-- RX_DATA_GEN_OTHER_RATIOS: This logic is for other SCK ratios than
---------------------------- C_SCK_RATIO =2

RX_DATA_GEN_OTHER_SCK_RATIOS : if C_SCK_RATIO /= 2 generate
begin
     FIFO_PRESENT_GEN: if C_FIFO_EXIST = 1 generate 
     -----
     begin
     -----
	-------------------------------------------------------------------------------
	-- TRANSFER_DONE_PROCESS : Generate SPI transfer done signal
	--------------------------
 TRANSFER_DONE_PROCESS: process(Bus2IP_Clk)
        begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
                if(Soft_Reset_op = RESET_ACTIVE or
                        transfer_start_pulse = '1'   or
                        SPIXfer_done_int = '1') then -- or (and_reduce(Count(COUNT_WIDTH-1 downto (COUNT_WIDTH-COUNT_WIDTH)))='1')) then
                        SPIXfer_done_int <= '0';
                elsif(Mst_N_Slv = '1') and ((CPOL xor CPHA) = '1') and
                     --and_reduce(Count((COUNT_WIDTH-1) downto (COUNT_WIDTH-COUNT_WIDTH))) ='1'
                     ((and_reduce(Count((COUNT_WIDTH-1) downto 0)) = '1') and (or_reduce(ratio_count) = '0'))
                     then
                        SPIXfer_done_int <= '1';
                elsif(Mst_N_Slv = '1') and ((CPOL xor CPHA) = '0') and
                     --and_reduce(Count((COUNT_WIDTH-1) downto (COUNT_WIDTH-COUNT_WIDTH))) ='1'
                     ((and_reduce(Count((COUNT_WIDTH-1) downto 0)) = '1') and (or_reduce(ratio_count) = '0'))
                  --   ((Count(COUNT_WIDTH) ='1') and (or_reduce(Count((COUNT_WIDTH-1) downto 0)) = '0'))
                     and
                     Count_trigger = '1'
                     then
                        SPIXfer_done_int <= '1';
                elsif--(Mst_N_Slv = '0') and
                     and_reduce(Count((COUNT_WIDTH-1) downto (COUNT_WIDTH-COUNT_WIDTH+1))) ='1' then
                        if((CPOL xor CPHA) = '0') and rising_edge_sck_i = '1' then
                                SPIXfer_done_int <= '1';
                        elsif((CPOL xor CPHA) = '1') and falling_edge_sck_i = '1' then
                                SPIXfer_done_int <= '1';
                        end if;
                end if;
        end if;
        end process TRANSFER_DONE_PROCESS;



--	TRANSFER_DONE_PROCESS: process(Bus2IP_Clk)
--	begin
--    	if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
--        	if(Soft_Reset_op = RESET_ACTIVE or
--           		transfer_start_pulse = '1'   or
--           		SPIXfer_done_int = '1') then -- or (and_reduce(Count(COUNT_WIDTH-1 downto (COUNT_WIDTH-COUNT_WIDTH)))='1')) then
--            		SPIXfer_done_int <= '0';
--        	elsif(Mst_N_Slv = '1') and
--             	     --and_reduce(Count((COUNT_WIDTH-1) downto (COUNT_WIDTH-COUNT_WIDTH))) ='1'
--		     ((Count(COUNT_WIDTH) ='1') and (or_reduce(Count((COUNT_WIDTH-1) downto 0)) = '0')) 
--              	     and
--             	     Count_trigger = '1'
--             	     then
--            	        SPIXfer_done_int <= '1';
--        	elsif--(Mst_N_Slv = '0') and
--             	     and_reduce(Count((COUNT_WIDTH-1) downto (COUNT_WIDTH-COUNT_WIDTH+1))) ='1' then
--             		if((CPOL xor CPHA) = '0') and rising_edge_sck_i = '1' then
--                		SPIXfer_done_int <= '1';
--             		elsif((CPOL xor CPHA) = '1') and falling_edge_sck_i = '1' then
--                		SPIXfer_done_int <= '1';
--             		end if;
 --       	end if;
 --   	end if;
--	end process TRANSFER_DONE_PROCESS;

     end generate FIFO_PRESENT_GEN;
     --------------------------------------------------------------
     FIFO_ABSENT_GEN: if C_FIFO_EXIST = 0 generate 
     -----
     begin
     -----
     -------------------------------------------------------------------------------
     -- TRANSFER_DONE_PROCESS : Generate SPI transfer done signal
     --------------------------
     TRANSFER_DONE_PROCESS: process(Bus2IP_Clk)
     begin
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(Soft_Reset_op = RESET_ACTIVE or
                transfer_start_pulse = '1'   or
                SPIXfer_done_int = '1') then
                	SPIXfer_done_int <= '0';
             elsif(Mst_N_Slv = '1') and
     	           ((Count(COUNT_WIDTH) ='1') and (or_reduce(Count((COUNT_WIDTH-1) downto 0)) = '0')) 
                   and
                   Count_trigger = '1'
                   then
			SPIXfer_done_int <= '1';
             elsif--(Mst_N_Slv = '0') and
                  and_reduce(Count((COUNT_WIDTH-1) downto (COUNT_WIDTH-COUNT_WIDTH+1))) ='1' then
                  if((CPOL xor CPHA) = '0') and rising_edge_sck_i = '1' then
                       SPIXfer_done_int <= '1';
                  elsif((CPOL xor CPHA) = '1') and falling_edge_sck_i = '1' then
                       SPIXfer_done_int <= '1';
                  end if;
             end if;
         end if;
      end process TRANSFER_DONE_PROCESS;
 
    end generate FIFO_ABSENT_GEN;

-- This is mux to choose the data register for SPI mode 00,11 and 01,10.
-- the below mux is applicable only for Master mode of SPI.
  rx_shft_reg <=
              rx_shft_reg_mode_0011
              when ((CPOL = '0' and CPHA = '0') or (CPOL = '1' and CPHA = '1'))
              else
              rx_shft_reg_mode_0110
              when ((CPOL = '0' and CPHA = '1') or (CPOL = '1' and CPHA = '0'))
              else
              (others=>'0');

--  RECEIVE_DATA_STROBE_PROCESS_OTHER_RATIO: the below process if for other
--------------------------------------------  SPI ratios of C_SCK_RATIO >2
--                                        -- It multiplexes the data stored
--                                        -- in internal registers in LSB and
--                                        -- non-LSB modes, in master as well as
--                                        -- in slave mode.
  RECEIVE_DATA_STROBE_PROCESS_OTHER_RATIO: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
         if(SPIXfer_done_int_pulse_d1 = '1') then
            if (Mst_N_Slv = '1') then -- in master mode
                if (LSB_first = '1') then
                  for i in 0 to (C_NUM_TRANSFER_BITS-1) loop
                   receive_Data_int(i) <= rx_shft_reg(C_NUM_TRANSFER_BITS-1-i);
                  end loop;
                else
                   receive_Data_int <= rx_shft_reg;
                end if;
            elsif(Mst_N_Slv = '0') then -- in slave mode
                if (LSB_first = '1') then
                  for i in 0 to (C_NUM_TRANSFER_BITS-1) loop
                    receive_Data_int(i) <= rx_shft_reg_s
                                                   (C_NUM_TRANSFER_BITS-1-i);
                  end loop;
                else
                   receive_Data_int <= rx_shft_reg_s;
                end if;
            end if;
         end if;
      end if;
  end process RECEIVE_DATA_STROBE_PROCESS_OTHER_RATIO;

  SPIXfer_done_drr <= SPIXfer_done_int_pulse_d2;
  SPIXfer_done_rd_tx_en <= transfer_start_pulse or
                           SPIXfer_done_int_pulse_d2 or
                           (spisel_pulse and spisel_once_1);
  tx_cntr_xfer_done <= transfer_start_pulse or SPIXfer_done_int_pulse_d2;
--------------------------------------------
end generate RX_DATA_GEN_OTHER_SCK_RATIOS;

-------------------------------------------------------------------------------
-- OTHER_RATIO_GENERATE : Logic to be used when C_SCK_RATIO is not equal to 2
-------------------------
OTHER_RATIO_GENERATE: if(C_SCK_RATIO /= 2) generate
begin
miso_i_sync <= MISO_I;
mosi_i_sync <= 	MOSI_I;	
 ------------------------------
 LOOP_BACK_PROCESS: process(Bus2IP_Clk)is
 -----
 begin
 -----
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if(Loop_mode = '0' or Soft_Reset_op = RESET_ACTIVE) then
        serial_dout_int <= '0';
      elsif(Loop_mode = '1') then
        serial_dout_int <= Serial_Dout;
      end if;
    end if;
 end process LOOP_BACK_PROCESS;
 ------------------------------
 -- EXTERNAL_INPUT_OR_LOOP_PROCESS: The logic below provides MUXed input to
 --                                 serial_din input.
 EXTERNAL_INPUT_OR_LOOP_PROCESS: process(Loop_mode,
                                         Mst_N_Slv,
                                         mosi_i_sync,
                                         miso_i_sync,
                                         serial_dout_int
                                         )is
 -----
 begin
 -----
        if(Mst_N_Slv = '1' )then
           if(Loop_mode = '1')then
             Serial_Din <= serial_dout_int;
           else
             Serial_Din <= miso_i_sync;
           end if;
        else
             Serial_Din <= mosi_i_sync;
        end if;
 end process EXTERNAL_INPUT_OR_LOOP_PROCESS;
-------------------------------------------------------------------------------
-- RATIO_COUNT_PROCESS : Counter which counts from (C_SCK_RATIO/2)-1 down to 0
--                       Used for counting the time to control SCK_O_reg generation
--                       depending on C_SCK_RATIO
------------------------
  RATIO_COUNT_PROCESS: process(Bus2IP_Clk)is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
              Ratio_Count <= CONV_STD_LOGIC_VECTOR(
                             ((C_SCK_RATIO/2)-1),(spcl_log2(C_SCK_RATIO)-1));
          else
              Ratio_Count <= Ratio_Count - 1;
              if (Ratio_Count = 0) then
                  Ratio_Count <= CONV_STD_LOGIC_VECTOR(
                               ((C_SCK_RATIO/2)-1),(spcl_log2(C_SCK_RATIO)-1));
              end if;
          end if;
      end if;
  end process RATIO_COUNT_PROCESS;

-------------------------------------------------------------------------------
-- COUNT_TRIGGER_GEN_PROCESS : Generate a trigger whenever Ratio_Count reaches
--                             zero
------------------------------
  COUNT_TRIGGER_GEN_PROCESS: process(Bus2IP_Clk)is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
              Count_trigger <= '0';
          elsif(Ratio_Count = 0) then
              Count_trigger <= not Count_trigger;
          end if;
      end if;
  end process COUNT_TRIGGER_GEN_PROCESS;

-------------------------------------------------------------------------------
-- COUNT_TRIGGER_1CLK_PROCESS : Delay cnt_trigger signal by 1 clock cycle
-------------------------------
  COUNT_TRIGGER_1CLK_PROCESS: process(Bus2IP_Clk)is
  -----
  begin
  -----
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (transfer_start = '0')) then
              Count_trigger_d1 <= '0';
          else
              Count_trigger_d1 <=  Count_trigger;
          end if;
      end if;
  end process COUNT_TRIGGER_1CLK_PROCESS;

 -- generate a trigger pulse for rising edge as well as falling edge
   Count_trigger_pulse <= (Count_trigger and (not(Count_trigger_d1))) or
                         ((not(Count_trigger)) and Count_trigger_d1);

-------------------------------------------------------------------------------
-- SCK_CYCLE_COUNT_PROCESS : Counts number of trigger pulses provided. Used for
--                           controlling the number of bits to be transfered
--                           based on generic C_NUM_TRANSFER_BITS
----------------------------
  SCK_CYCLE_COUNT_PROCESS: process(Bus2IP_Clk)is
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Count <= (others => '0');
          elsif (Mst_N_Slv = '1') then
              if (SPIXfer_done_int = '1')or
                 (transfer_start = '0')  or
                 (xfer_done_fifo_0 = '1') then
                  Count <= (others => '0');
              elsif((Count_trigger_pulse = '1') and (Count(COUNT_WIDTH) = '0')) then
                  Count <=  Count + 1;
                  -- coverage off
                  if (Count(COUNT_WIDTH) = '1') then
                      Count <= (others => '0');
                  end if;
                  -- coverage on
              end if;
          elsif (Mst_N_Slv = '0') then
              if ((transfer_start = '0') or (SPISEL_sync = '1')or
                  (spixfer_done_int = '1')) then
                  Count <= (others => '0');
              elsif (edge_sck_i = '1') then
                  Count <=  Count + 1;
                  -- coverage off
                  if (Count(COUNT_WIDTH) = '1') then
                      Count <= (others => '0');
                  end if;
                  -- coverage on
              end if;
          end if;
      end if;
  end process SCK_CYCLE_COUNT_PROCESS;

-------------------------------------------------------------------------------
-- SCK_SET_RESET_PROCESS : Sync set/reset toggle flip flop controlled by
--                         transfer_start signal
--------------------------
  SCK_SET_RESET_PROCESS: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or
             (Sync_Reset = '1')             or
             (Mst_N_Slv='0')
             )then
               sck_o_int <= '0';
          elsif(Sync_Set = '1') then
               sck_o_int <= '1';
          elsif (transfer_start = '1')  then
                sck_o_int <= sck_o_int xor Count_trigger_pulse;
          end if;
      end if;
  end process SCK_SET_RESET_PROCESS;
------------------------------------
-- DELAY_CLK: Delay the internal clock for a cycle to generate internal enable
--         -- signal for data register.
-------------
DELAY_CLK: process(Bus2IP_Clk)
  begin
     if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if (Soft_Reset_op = RESET_ACTIVE)then
           sck_d1 <= '0';
           sck_d2 <= '0';
        else
           sck_d1 <= sck_o_int;
           sck_d2 <= sck_d1;
        end if;
     end if;
  end process DELAY_CLK;
------------------------------------

 -- Rising egde pulse for CPHA-CPOL = 00/11 mode
 sck_rising_edge <= not(sck_d2) and  sck_d1;

-- CAPT_RX_FE_MODE_00_11: The below logic is the date registery process for
------------------------- SPI CPHA-CPOL modes of 00 and 11.
CAPT_RX_FE_MODE_00_11 : process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if (Soft_Reset_op = RESET_ACTIVE)then
              rx_shft_reg_mode_0011 <= (others => '0');
        elsif((sck_rising_edge = '1') and (transfer_start='1')) then
             rx_shft_reg_mode_0011<= rx_shft_reg_mode_0011
                                   (1 to (C_NUM_TRANSFER_BITS-1)) & Serial_Din;
        end if;
    end if;
end process CAPT_RX_FE_MODE_00_11;
--
   sck_fe1 <= (not sck_d1) and sck_d2;

-- CAPT_RX_FE_MODE_01_10 : The below logic is the date registery process for
------------------------- SPI CPHA-CPOL modes of 01 and 10.
CAPT_RX_FE_MODE_01_10 : process(Bus2IP_Clk)
  begin
      --if rising_edge(Bus2IP_Clk) then
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if (Soft_Reset_op = RESET_ACTIVE)then
                rx_shft_reg_mode_0110 <= (others => '0');
          elsif ((sck_fe1 = '1') and (transfer_start = '1')) then
                rx_shft_reg_mode_0110 <= rx_shft_reg_mode_0110
                                    (1 to (C_NUM_TRANSFER_BITS-1)) & Serial_Din;
          end if;
      end if;
  end process CAPT_RX_FE_MODE_01_10;

-------------------------------------------------------------------------------
-- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
--                             capture and shift operation for serial data
------------------------------
  CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0) <= '0';
              Shift_Reg(1) <= '1';
              Shift_Reg(2 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout <= '1';
          elsif((Mst_N_Slv = '1')) then --  and (not(Count(COUNT_WIDTH) = '1'))) then
              --if(Loading_SR_Reg_int = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1')then
                  if(LSB_first = '1') then
                      for i in 0 to C_NUM_TRANSFER_BITS-1 loop
                          Shift_Reg(i) <= Transmit_Data
                                          (C_NUM_TRANSFER_BITS-1-i);
                      end loop;
                      Serial_Dout <= Transmit_Data(C_NUM_TRANSFER_BITS-1);
                  else
                      Shift_Reg   <= Transmit_Data;
                      Serial_Dout <= Transmit_Data(0);
                  end if;
              -- Capture Data on even Count
              elsif(--(transfer_start = '1') and
                    (Count(0) = '0') ) then
                  Serial_Dout <= Shift_Reg(0);
              -- Shift Data on odd Count
              elsif(--(transfer_start = '1') and
                    (Count(0) = '1') and
                      (Count_trigger_pulse = '1')) then
                  Shift_Reg   <= Shift_Reg
                                 (1 to C_NUM_TRANSFER_BITS -1) & Serial_Din;
              end if;

          -- below mode is slave mode logic for SPI
          elsif(Mst_N_Slv = '0') then
              --if((Loading_SR_Reg_int = '1') or (spisel_pulse = '1')) then
              --if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1')then
              if(SR_5_Tx_Empty_pulse = '1' or SPIXfer_done_int = '1')then
                  if(LSB_first = '1') then
                      for i in 0 to C_NUM_TRANSFER_BITS-1 loop
                          Shift_Reg(i) <= Transmit_Data
                                          (C_NUM_TRANSFER_BITS-1-i);
                      end loop;
                      Serial_Dout <= Transmit_Data(C_NUM_TRANSFER_BITS-1);
                  else
                      Shift_Reg   <= Transmit_Data;
                      Serial_Dout <= Transmit_Data(0);
                  end if;
              elsif (transfer_start = '1') then
                  if((CPOL = '0' and CPHA = '0') or
                      (CPOL = '1' and CPHA = '1')) then

                      if(rising_edge_sck_i = '1') then
                          rx_shft_reg_s   <= rx_shft_reg_s(1 to
                                         C_NUM_TRANSFER_BITS -1) & Serial_Din;
                          Shift_Reg <= Shift_Reg(1 to
                                         C_NUM_TRANSFER_BITS -1) & Serial_Din;
                      --elsif(falling_edge_sck_i = '1') then
                      --elsif(rising_edge_sck_i_d1 = '1')then
                      --    Serial_Dout <= Shift_Reg(0);
                      end if;
                      Serial_Dout <= Shift_Reg(0);
                  elsif((CPOL = '0' and CPHA = '1') or
                        (CPOL = '1' and CPHA = '0')) then
                        --Serial_Dout <= Shift_Reg(0);
                      if(falling_edge_sck_i = '1') then
                          rx_shft_reg_s   <= rx_shft_reg_s(1 to
                                         C_NUM_TRANSFER_BITS -1) & Serial_Din;
                          Shift_Reg <= Shift_Reg(1 to
                                         C_NUM_TRANSFER_BITS -1) & Serial_Din;
                      --elsif(rising_edge_sck_i = '1') then
                      --elsif(falling_edge_sck_i_d1 = '1')then
                      --    Serial_Dout <= Shift_Reg(0);
                      end if;
                      Serial_Dout <= Shift_Reg(0);
                  end if;
              end if;
          end if;
      end if;
  end process CAPTURE_AND_SHIFT_PROCESS;
-----
end generate OTHER_RATIO_GENERATE;


-------------------------------------------------------------------------------
-- RATIO_OF_2_GENERATE : Logic to be used when C_SCK_RATIO is equal to 2
------------------------
RATIO_OF_2_GENERATE: if(C_SCK_RATIO = 2) generate
--------------------
begin
-----
-------------------------------------------------------------------------------
-- SCK_CYCLE_COUNT_PROCESS : Counts number of trigger pulses provided. Used for
--                           controlling the number of bits to be transfered
--                           based on generic C_NUM_TRANSFER_BITS
----------------------------
  SCK_CYCLE_COUNT_PROCESS: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or
             (transfer_start = '0') or
             (SPIXfer_done_int = '1') or
             (Mst_N_Slv = '0')) then
              Count <= (others => '0');
          --elsif (Count(COUNT_WIDTH) = '0') then
          --    Count <=  Count + 1;
                    elsif(Count(COUNT_WIDTH) = '0')then
             if(CPHA = '0')then
                if(CPOL = '0' and  transfer_start_d1 = '1')then      -- cpol = cpha = 00
                   Count <=  Count + 1;
                elsif(transfer_start_d1 = '1') then                     -- cpol = cpha = 10
                   Count <=  Count + 1;
                end if;
             else
                if(CPOL = '1' and  transfer_start_d1 = '1')then      -- cpol = cpha = 11
                     Count <=  Count + 1;
                elsif(transfer_start_d1 = '1') then-- cpol = cpha = 10
                     Count <=  Count + 1;
                end if;
             end if;
          end if;
      end if;
  end process SCK_CYCLE_COUNT_PROCESS;

-------------------------------------------------------------------------------
-- SCK_SET_RESET_PROCESS : Sync set/reset toggle flip flop controlled by
--                         transfer_start signal
--------------------------
  SCK_SET_RESET_PROCESS: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if((Soft_Reset_op = RESET_ACTIVE) or (Sync_Reset = '1')) then
              sck_o_int <= '0';
          elsif(Sync_Set = '1') then
              sck_o_int <= '1';
          elsif (transfer_start = '1') then
              sck_o_int <= (not sck_o_int);-- xor Count(COUNT_WIDTH);
          end if;
      end if;
  end process SCK_SET_RESET_PROCESS;

--   CAPT_RX_FE_MODE_00_11: The below logic is to capture data for SPI mode of
--------------------------- 00 and 11.
  -- Generate a falling edge pulse from the serial clock. Use this to
  -- capture the incoming serial data into a shift register.
  -- CAPT_RX_FE_MODE_00_11 : process(Bus2IP_Clk)
  -- begin
    -- if(Bus2IP_Clk'event and Bus2IP_Clk = '0') then
          -- sck_d1 <= sck_o_int;
          -- sck_d2 <= sck_d1;
          -- -- if (sck_rising_edge = '1') then
          -- if (sck_d1 = '1') then
             -- rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                       -- (1 to (C_NUM_TRANSFER_BITS-1)) & MISO_I;
          -- end if;
      -- end if;
  -- end process CAPT_RX_FE_MODE_00_11;

  CAPT_RX_FE_MODE_00_11 : process(Bus2IP_Clk)
  begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          sck_d1 <= sck_o_int;
          sck_d2 <= sck_d1;
         -- sck_d3 <= sck_d2;
          -- if (sck_rising_edge = '1') then
          if (sck_d2 = '0') then
             rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                       (1 to (C_NUM_TRANSFER_BITS-1)) & MISO_I;
          end if;
      end if;
  end process CAPT_RX_FE_MODE_00_11;

  
  -- Falling egde pulse
  sck_rising_edge <= sck_d2 and not sck_d1;
  --
--   CAPT_RX_FE_MODE_01_10: the below logic captures data in SPI 01 or 10 mode.
---------------------------
  CAPT_RX_FE_MODE_01_10: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          sck_d11 <= sck_o_in;
          sck_d21 <= sck_d11;
          if(CPOL = '1' and CPHA = '0') then
               -------------------if ((sck_d1 = '1') and (transfer_start = '1')) then
               if (sck_d2 = '1') then
                        rx_shft_reg_mode_0110 <= rx_shft_reg_mode_0110
                                       (1 to (C_NUM_TRANSFER_BITS-1)) & MISO_I;
                end if;
          elsif((CPOL = '0') and (CPHA = '1')) then
               -------------------if ((sck_fe1 = '0') and (transfer_start = '1')) then
               if (sck_fe1 = '1') then
                        rx_shft_reg_mode_0110 <= rx_shft_reg_mode_0110
                                       (1 to (C_NUM_TRANSFER_BITS-1)) & MISO_I;
               end if;
          end if;
      end if;
  end process CAPT_RX_FE_MODE_01_10;

  sck_fe1 <= (not sck_d11) and sck_d21;

-------------------------------------------------------------------------------
-- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
--                             capture and shift operation for serial data in
------------------------------ master SPI mode only
  CAPTURE_AND_SHIFT_PROCESS: process(Bus2IP_Clk)
  begin
      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
          if(Soft_Reset_op = RESET_ACTIVE) then
              Shift_Reg(0) <= '0';
              Shift_Reg(1) <= '1';
              Shift_Reg(2 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout  <= '1';
          elsif(Mst_N_Slv = '1') then
              --if(Loading_SR_Reg_int = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then
                  if(LSB_first = '1') then
                      for i in 0 to C_NUM_TRANSFER_BITS-1 loop
                         Shift_Reg(i) <= Transmit_Data
                                         (C_NUM_TRANSFER_BITS-1-i);
                      end loop;
                      Serial_Dout <= Transmit_Data(C_NUM_TRANSFER_BITS-1);
                  else
                      Shift_Reg   <= Transmit_Data;
                      Serial_Dout <= Transmit_Data(0);
                  end if;
              elsif(--(transfer_start = '1') and
                  (Count(0) = '0') -- and
                  --(Count(COUNT_WIDTH) = '0')
                  ) then -- Shift Data on even
                  Serial_Dout <= Shift_Reg(0);
                elsif(--(transfer_start = '1') and
                      (Count(0) = '1')-- and
                      --(Count(COUNT_WIDTH) = '0')
                      ) then -- Capture Data on odd
                  if(Loop_mode = '1') then       -- Loop mode
                      Shift_Reg   <= Shift_Reg(1 to
                                     C_NUM_TRANSFER_BITS -1) & Serial_Dout;
                  else
                      Shift_Reg   <= Shift_Reg(1 to
                                     C_NUM_TRANSFER_BITS -1) & MISO_I;
                  end if;
              end if;
          elsif(Mst_N_Slv = '0') then
              -- Added to have consistent default value after reset
              --if((Loading_SR_Reg_int = '1') or (spisel_pulse = '1')) then
              if(spisel_pulse = '1' or SPIXfer_done_int_d1 = '1') then
                  Shift_Reg   <= (others => '0');
                  Serial_Dout <= '0';
              end if;
          end if;
      end if;
  end process CAPTURE_AND_SHIFT_PROCESS;
-----
end generate RATIO_OF_2_GENERATE;

-------------------------------------------------------------------------------
-- SCK_SET_GEN_PROCESS : Generate SET control for SCK_O_reg
------------------------
SCK_SET_GEN_PROCESS: process(CPOL,CPHA,transfer_start_pulse,
                             SPIXfer_done_int,
                             Mst_Trans_inhibit_pulse
                             )
begin
    -- if(transfer_start_pulse = '1') then
    --if(Mst_Trans_inhibit_pulse = '1' or SPIXfer_done_int = '1') then
    if(transfer_start_pulse = '1' or SPIXfer_done_int = '1') then
        Sync_Set <= (CPOL xor CPHA);
    else
        Sync_Set <= '0';
    end if;
end process SCK_SET_GEN_PROCESS;

-------------------------------------------------------------------------------
-- SCK_RESET_GEN_PROCESS : Generate SET control for SCK_O_reg
--------------------------
SCK_RESET_GEN_PROCESS: process(CPOL,
                               CPHA,
                               transfer_start_pulse,
                                   SPIXfer_done_int,
                                   Mst_Trans_inhibit_pulse)
begin
    --if(transfer_start_pulse = '1') then
    --if(Mst_Trans_inhibit_pulse = '1' or SPIXfer_done_int = '1') then
    if(transfer_start_pulse = '1' or SPIXfer_done_int = '1') then
        Sync_Reset <= not(CPOL xor CPHA);
    else
        Sync_Reset <= '0';
    end if;
end process SCK_RESET_GEN_PROCESS;

-------------------------------------------------------------------------------
-- RATIO_NOT_EQUAL_4_GENERATE : Logic to be used when C_SCK_RATIO is not equal
--                              to 4
-------------------------------
RATIO_NOT_EQUAL_4_GENERATE: if(C_SCK_RATIO /= 4) generate
begin
-----
    -------------------------------------------------------------------------------
    -- SCK_O_SELECT_PROCESS : Select the idle state (CPOL bit) when not transfering
    --                        data else select the clock for slave device
    -------------------------
    SCK_O_NQ_4_SELECT_PROCESS: process(sck_o_int,
                                       CPOL,
                                       transfer_start,
                                       transfer_start_d1,
                                       Count(COUNT_WIDTH),
                                       xfer_done_fifo_0
                                       )is
    begin
            if((transfer_start = '1')    and
               (transfer_start_d1 = '1') and
               (Count(COUNT_WIDTH) = '0')and
               (xfer_done_fifo_0 = '0')
               ) then
                    sck_o_in <= sck_o_int;
            else
                    sck_o_in <= CPOL;
            end if;
    end process SCK_O_NQ_4_SELECT_PROCESS;
    ---------------------------------

    SCK_O_NQ_4_NO_STARTUP_USED_DM : if (C_USE_STARTUP = 0 and C_DUAL_MODE = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    slave_mode <= not (Mst_N_Slv);
    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
    SCK_O_NE_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (’0’ or ’1’)
          port map
                (
                 Q  => SCK_O_reg,   -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => sck_o_in     -- Data input
                );

    end generate SCK_O_NQ_4_NO_STARTUP_USED_DM;



    SCK_O_NQ_4_NO_STARTUP_USED: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 0) generate
    ----------------
    attribute IOB                         : string;
    attribute IOB of SCK_O_NE_4_FDRE_INST : label is "true";
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    slave_mode <= not (Mst_N_Slv);
    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
    SCK_O_NE_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (’0’ or ’1’)
          port map
                (
                 Q  => SCK_O_reg,   -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => sck_o_in     -- Data input
                );

    end generate SCK_O_NQ_4_NO_STARTUP_USED;

    SCK_O_NQ_4_NO_STARTUP_USED_EXT: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    slave_mode <= not (Mst_N_Slv);
    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
    SCK_O_NE_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (’0’ or ’1’)
          port map
                (
                 Q  => SCK_O_reg,   -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => sck_o_in     -- Data input
                );

    end generate SCK_O_NQ_4_NO_STARTUP_USED_EXT;



    -----------------------------

    SCK_O_NQ_4_STARTUP_USED: if (C_USE_STARTUP = 1) generate
    -------------
    begin
    -----
     ---------------------------------------------------------------------------
     -- SCK_O_FINAL_PROCESS : Register the final SCK_O_reg
     ------------------------
     SCK_O_NQ_4_FINAL_PROCESS: process(Bus2IP_Clk)
     -----
     begin
     -----
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
         --If Soft_Reset_op or slave Mode.Prevents SCK_O_reg to be generated in slave
            if((Soft_Reset_op = RESET_ACTIVE) or
               (Mst_N_Slv = '0')
              ) then
                 SCK_O_reg <= '0';
            else
                 SCK_O_reg <= sck_o_in;
            end if;
         end if;
     end process SCK_O_NQ_4_FINAL_PROCESS;
     -------------------------------------
    end generate SCK_O_NQ_4_STARTUP_USED;
    -------------------------------------
end generate RATIO_NOT_EQUAL_4_GENERATE;


-------------------------------------------------------------------------------
-- RATIO_OF_4_GENERATE : Logic to be used when C_SCK_RATIO is equal to 4
------------------------
RATIO_OF_4_GENERATE: if(C_SCK_RATIO = 4) generate
begin
-----
-------------------------------------------------------------------------------
-- SCK_O_FINAL_PROCESS : Select the idle state (CPOL bit) when not transfering
--                       data else select the clock for slave device
------------------------
-- A work around to reduce one clock cycle for sck_o generation. This would
-- allow for proper shifting of data bits into the slave device.
-- Removing the final stage F/F. Disadvantage of not registering final output
-------------------------------------------------------------------------------
   SCK_O_EQ_4_FINAL_PROCESS: process(Mst_N_Slv,
                                     sck_o_int,
                                     CPOL,
                                     transfer_start,
                                     transfer_start_d1,
                                     Count(COUNT_WIDTH),
                                     xfer_done_fifo_0
                                     )is
   -----
   begin
   -----
    if((Mst_N_Slv = '1')         and
       (transfer_start = '1')    and
       (transfer_start_d1 = '1') and
       (Count(COUNT_WIDTH) = '0')and
       (xfer_done_fifo_0 = '0')
      ) then
         SCK_O_1 <= sck_o_int;
    else
         SCK_O_1 <= CPOL and Mst_N_Slv;
    end if;
   end process SCK_O_EQ_4_FINAL_PROCESS;
   -------------------------------------

    SCK_O_EQ_4_NO_STARTUP_USED_DM : if (C_USE_STARTUP = 0 and C_DUAL_MODE = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    slave_mode <= not (Mst_N_Slv);

    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
    SCK_O_EQ_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (’0’ or ’1’)
          port map
                (
                 Q  => SCK_O_reg,       -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => SCK_O_1      -- Data input
                );

    end generate SCK_O_EQ_4_NO_STARTUP_USED_DM;



    SCK_O_EQ_4_NO_STARTUP_USED: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 0) generate
    ----------------
    attribute IOB                         : string;
    attribute IOB of SCK_O_EQ_4_FDRE_INST : label is "true";
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    slave_mode <= not (Mst_N_Slv);

    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
    SCK_O_EQ_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (’0’ or ’1’)
          port map
                (
                 Q  => SCK_O_reg,       -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => SCK_O_1      -- Data input
                );

    end generate SCK_O_EQ_4_NO_STARTUP_USED;


    SCK_O_EQ_4_NO_STARTUP_USED_EXT: if (C_USE_STARTUP = 0 and C_DUAL_MODE = 0 and C_STARTUP_EXT = 1) generate
    ----------------
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    slave_mode <= not (Mst_N_Slv);

    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk).
    SCK_O_EQ_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (’0’ or ’1’)
          port map
                (
                 Q  => SCK_O_reg,       -- Data output
                 C  => Bus2IP_Clk,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => slave_mode,  -- Synchronous reset input
                 D  => SCK_O_1      -- Data input
                );

    end generate SCK_O_EQ_4_NO_STARTUP_USED_EXT;

    -----------------------------

   SCK_O_EQ_4_STARTUP_USED: if (C_USE_STARTUP = 1) generate
   -------------
   begin
   -----
        ----------------------------------------------------------------------------
        -- SCK_RATIO_4_REG_PROCESS : The SCK is registered in SCK RATIO = 4 mode
        ----------------------------------------------------------------------------
        SCK_O_EQ_4_REG_PROCESS: process(Bus2IP_Clk)
        -----
        begin
        -----
                if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
                -- If Soft_Reset_op or slave Mode. Prevents SCK_O_reg to be generated in slave
                        if((Soft_Reset_op = RESET_ACTIVE) or
                           (Mst_N_Slv = '0')
                           ) then
                                SCK_O_reg <= '0';
                        else
                                SCK_O_reg <= SCK_O_1;
                        end if;
                end if;
        end process SCK_O_EQ_4_REG_PROCESS;
        -----------------------------------
   end generate SCK_O_EQ_4_STARTUP_USED;
   -------------------------------------

end generate RATIO_OF_4_GENERATE;

-------------------------------------------------------------------------------
-- LOADING_FIRST_ELEMENT_PROCESS : Combinatorial process to generate flag
--                                 when loading first data element in shift
--                                 register from transmit register/fifo
----------------------------------
LOADING_FIRST_ELEMENT_PROCESS: process(Soft_Reset_op,
                                       SPI_En,Mst_N_Slv,
                                       SS_Asserted,
                                       SS_Asserted_1dly,
                                       SR_3_MODF,
                                       transfer_start_pulse)is
begin
    if(Soft_Reset_op = RESET_ACTIVE) then
        Loading_SR_Reg_int <= '0';              --Clear flag
    elsif(SPI_En                 = '1'   and    --Enabled
          (
           ((Mst_N_Slv              = '1')  and  --Master configuration
            (SS_Asserted            = '1')  and
            (SS_Asserted_1dly       = '0')  and
            (SR_3_MODF              = '0')
           ) or
           ((Mst_N_Slv              = '0')   and  --Slave configuration
            ((transfer_start_pulse = '1'))
           )
          )
         )then
        Loading_SR_Reg_int <= '1';               --Set flag
    else
        Loading_SR_Reg_int <= '0';               --Clear flag
    end if;
end process LOADING_FIRST_ELEMENT_PROCESS;

-------------------------------------------------------------------------------
-- SELECT_OUT_PROCESS : This process sets SS active-low, one-hot encoded select
--                      bit. Changing SS is premitted during a transfer by
--                      hardware, but is to be prevented by software. In Auto
--                      mode SS_O reflects value of Slave_Select_Reg only
--                      when transfer is in progress, otherwise is SS_O is held
--                      high
-----------------------
SELECT_OUT_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
       if(Soft_Reset_op = RESET_ACTIVE) then
           SS_O                   <= (others => '1');
           SS_Asserted            <= '0';
           SS_Asserted_1dly       <= '0';
       elsif(transfer_start = '0') or (xfer_done_fifo_0 = '1') then    -- Tranfer not in progress
           if(Manual_SS_mode = '0') then   -- Auto SS assert
               SS_O   <= (others => '1');
           else
               for i in C_NUM_SS_BITS-1 downto 0 loop
                   SS_O(i) <= Slave_Select_Reg(C_NUM_SS_BITS-1-i);
               end loop;
           end if;
           SS_Asserted       <= '0';
           SS_Asserted_1dly  <= '0';
       else
           for i in C_NUM_SS_BITS-1 downto 0 loop
               SS_O(i) <= Slave_Select_Reg(C_NUM_SS_BITS-1-i);
           end loop;
           SS_Asserted       <= '1';
           SS_Asserted_1dly  <= SS_Asserted;
       end if;
    end if;
end process SELECT_OUT_PROCESS;

-------------------------------------------------------------------------------
-- MODF_STROBE_PROCESS : Strobe MODF signal when master is addressed as slave
------------------------
MODF_STROBE_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
       if((Soft_Reset_op = RESET_ACTIVE) or (SPISEL_sync = '1')) then
           MODF_strobe       <= '0';
           MODF_strobe_int   <= '0';
           Allow_MODF_Strobe <= '1';
       elsif((Mst_N_Slv = '1') and --In Master mode
             (SPISEL_sync = '0') and (Allow_MODF_Strobe = '1')) then
           MODF_strobe       <= '1';
           MODF_strobe_int   <= '1';
           Allow_MODF_Strobe <= '0';
       else
           MODF_strobe       <= '0';
           MODF_strobe_int   <= '0';
       end if;
    end if;
end process MODF_STROBE_PROCESS;

-------------------------------------------------------------------------------
-- SLAVE_MODF_STROBE_PROCESS : Strobe MODF signal when slave is addressed
--                             but not enabled.
------------------------------
SLAVE_MODF_STROBE_PROCESS: process(Bus2IP_Clk)
begin
    if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
       if((Soft_Reset_op = RESET_ACTIVE) or (SPISEL_sync = '1')) then
           Slave_MODF_strobe      <= '0';
           Allow_Slave_MODF_Strobe<= '1';
       elsif((Mst_N_Slv   = '0') and    --In Slave mode
             (SPI_En      = '0') and    --but not enabled
             (SPISEL_sync = '0') and
             (Allow_Slave_MODF_Strobe = '1')
             ) then
           Slave_MODF_strobe       <= '1';
           Allow_Slave_MODF_Strobe <= '0';
       else
           Slave_MODF_strobe       <= '0';
       end if;
    end if;
end process SLAVE_MODF_STROBE_PROCESS;
---------------------xxx------------------------------------------------------
end imp;


----  qspi_look_up_logic - entity/architecture pair
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
---- Filename:        qspi_look_up_logic.vhd
---- Version:         v3.0
---- Description:     Serial Peripheral Interface (SPI) Module for interfacing
----                  with a 32-bit AXI4 Bus.
----
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_unsigned.all;
    use ieee.numeric_std.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.log2;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.comp_defs.all;

library dist_mem_gen_v8_0_11;
    use dist_mem_gen_v8_0_11.all;

library xpm;

	-- Library declaration XilinxCoreLib
-- library XilinxCoreLib;

library unisim;
    use unisim.vcomponents.FDRE;
-------------------------------------------------------------------------------
entity qspi_look_up_logic is
        generic(
                C_FAMILY              : string;
                C_SPI_MODE            : integer;
                C_SELECT_XPM          : integer := 0;
                C_SPI_MEMORY          : integer;
                C_NUM_TRANSFER_BITS   : integer
        );
        port(
                EXT_SPI_CLK         : in std_logic;
                Rst_to_spi          : in std_logic;
                TXFIFO_RST          : in std_logic;
                --------------------
                DTR_FIFO_Data_Exists: in std_logic;
                Data_From_TxFIFO    : in std_logic_vector
                                                 (0 to (C_NUM_TRANSFER_BITS-1));
                pr_state_idle       : in std_logic;
                --------------------
                Data_Dir            : out std_logic;
                Data_Mode_1         : out std_logic;
                Data_Mode_0         : out std_logic;
                Data_Phase          : out std_logic;
                --------------------
                Quad_Phase          : out std_logic;
                --------------------
                Addr_Mode_1         : out std_logic;
                Addr_Mode_0         : out std_logic;
                Addr_Bit            : out std_logic;
                Addr_Phase          : out std_logic;
                --------------------
                CMD_Mode_1          : out std_logic;
                CMD_Mode_0          : out std_logic;
                CMD_Error           : out std_logic;
                ---------------------
                CMD_decoded         : out std_logic
        );
end entity qspi_look_up_logic;
-----------------------------
architecture imp of qspi_look_up_logic is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

component  xpm_memory_sprom
  generic (
  MEMORY_SIZE         : integer := 4096*32;
  MEMORY_PRIMITIVE    : string  := "auto";
  ECC_MODE            : string  := "no_ecc";
  MEMORY_INIT_FILE    : string  := "none";
  MEMORY_INIT_PARAM   : string  := "";
  WAKEUP_TIME         : string  := "disable_sleep";
  MESSAGE_CONTROL     : integer :=  0;

  READ_DATA_WIDTH_A   : integer := 32;
  ADDR_WIDTH_A        : integer := 12; 
  READ_RESET_VALUE_A  : string  := "0";
  READ_LATENCY_A      : integer :=  1

); 
  port (

  -- Common module ports
   sleep              : in std_logic;

  -- Port A module ports
   clka               : in std_logic;
   rsta               : in std_logic;
   ena                : in std_logic;
   regcea             : in std_logic;
   addra              : in std_logic_vector (ADDR_WIDTH_A-1 downto 0);  -- [ADDR_WIDTH_A-1:0]   
   injectsbiterra     : in std_logic;
   injectdbiterra     : in std_logic;
   douta              : out std_logic_vector (READ_DATA_WIDTH_A-1 downto 0);                -- [READ_DATA_WIDTH_A-1:0]  
   sbiterra           : out std_logic;
   dbiterra           : out std_logic

  );
end component;


-- constant declaration
constant C_LUT_DWIDTH : integer := 8;
constant C_LUT_DEPTH  : integer := 256;
-- function declaration
-- type declaration
-- signal declaration
--Dummy_Output_Signals-----


signal Local_rst : std_logic;
signal Dummy_3 : std_logic;
signal Dummy_2 : std_logic;
signal Dummy_1 : std_logic;
signal Dummy_0 : std_logic;
signal CMD_decoded_int : std_logic;
-----
begin
-----

Local_rst <= TXFIFO_RST or Rst_to_spi;

   -- LUT for C_SPI_MODE = 1 start  --

-------------------------------------------------------------------------------
-- QSPI_LOOK_UP_MODE_1_MEMORY_0: Dual mode. Mixed memories are supported.
-------------------------------
QSPI_LOOK_UP_MODE_1_MEMORY_0 : if (C_SPI_MODE = 1 and C_SPI_MEMORY = 0) generate
----------------------------
-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 11;

-- signal declaration
signal Look_up_op                : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal CMD_decoded_int_d1        : std_logic;
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;


---Dummy OUtput signals---------------
signal spo_1  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_1  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_1  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);

signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address           : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  --DTR_FIFO_Data_Exists_d4 <= '0';
                  CMD_decoded_int_d1      <= '0';                  
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and
                                             not DTR_FIFO_Data_Exists_d2;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                  --DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                  --DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                  --DTR_FIFO_Data_Exists_d4 <= DTR_FIFO_Data_Exists_d3;
                  --CMD_decoded_int         <= DTR_FIFO_Data_Exists_d2 and
                  --                           not(DTR_FIFO_Data_Exists_d3);
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------

     xpm_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_0 : if (C_SELECT_XPM = 1) generate
     xpm_memory_inst: xpm_memory_sprom  

                 generic map (
                         MEMORY_SIZE             => C_LOOK_UP_TABLE_WIDTH*C_LUT_DEPTH,
                         MEMORY_PRIMITIVE        =>  "lutram",
                         ECC_MODE                =>  "no_ecc",
                         MEMORY_INIT_FILE        => "mode_1_memory_0_mixed.mem",
                         MEMORY_INIT_PARAM       => "",
                         WAKEUP_TIME             => "disable_sleep",
                         MESSAGE_CONTROL         =>  0,
           
                         READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                         ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                         READ_RESET_VALUE_A      =>  "0",
                         READ_LATENCY_A          =>  1
                         )
                         port map (
                          -- Common module ports
                         sleep                   =>  '0',
                       
                        -- Port A module ports
                         clka                    => EXT_SPI_CLK,
                         rsta                    => Rst_to_spi, 
                         ena                     => '1', 
                         regcea                  => '1',
                         addra                   => Look_up_address,
                         injectsbiterra          => '0',
                         injectdbiterra          => '0',
                         douta                   => Look_up_op,
                         sbiterra                => open,
                         dbiterra                => open
                 );
     end generate;

     dist_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_0 : if (C_SELECT_XPM = 0) generate
     --C_SPI_MODE_1_MIXED_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_1_memory_0_mixed.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op   ,      -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "00000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_1,
						dpo             => dpo_1,
						qdpo            => qdpo_1
			   );
     end generate;
 -- look up table arrangement is as below

 -- 10       9           8           7          6           5           4        3       2          1          0
 -- Data_Dir Data Mode_1 Data Mode_0 Data_Phase Addr Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD Mode_0 CMD_ERROR
     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);  -- 10 14
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);  -- 9  13
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);  -- 8  12
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);  -- 7  11
     -------------
     Quad_Phase  <= '0';
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5);  -- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6);  -- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7);  -- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8);  -- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);  -- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10); -- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                    -- 0
     -------------
-----------------------------------------
end generate QSPI_LOOK_UP_MODE_1_MEMORY_0;
-----------------------------------------

-------------------------------------------------------------------------------
-- QSPI_LOOK_UP_MODE_1_MEMORY_1: This is Dual mode. Dedicated Winbond memories are supported.
--------------------------------
QSPI_LOOK_UP_MODE_1_MEMORY_1 : if (C_SPI_MODE = 1 and C_SPI_MEMORY = 1) generate
----------------------------
-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 11;
-- signal declaration
signal spo_2  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_2  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_2  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);


signal Look_up_op                : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
signal CMD_decoded_int_d1 : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;


signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address           : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  --DTR_FIFO_Data_Exists_d4 <= '0';
                  CMD_decoded_int_d1      <= '0';
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and not DTR_FIFO_Data_Exists_d2;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                --  DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                --  DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                  --DTR_FIFO_Data_Exists_d4 <= DTR_FIFO_Data_Exists_d3;
                --  CMD_decoded_int         <= DTR_FIFO_Data_Exists_d2 and
                --                             not(DTR_FIFO_Data_Exists_d3);
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------


     xpm_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_1 : if (C_SELECT_XPM = 1) generate
     xpm_memory_inst: xpm_memory_sprom  

                generic map (
                        MEMORY_SIZE             => C_LUT_DEPTH*C_LOOK_UP_TABLE_WIDTH,
                        MEMORY_PRIMITIVE        =>  "lutram",
                        ECC_MODE                =>  "no_ecc",
                        MEMORY_INIT_FILE        => "mode_1_memory_1_wb.mem",
                        MEMORY_INIT_PARAM       => "",
                        WAKEUP_TIME             => "disable_sleep",
                        MESSAGE_CONTROL         =>  0,
                  
                        READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                        ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                        READ_RESET_VALUE_A      =>  "0",
                        READ_LATENCY_A          =>  1
                        )
                        port map (
                         -- Common module ports
                        sleep                   =>  '0',
                      
                       -- Port A module ports
                        clka                    => EXT_SPI_CLK,
                        rsta                    => Rst_to_spi, 
                        ena                     => '1', 
                        regcea                  => '1',
                        addra                   => Look_up_address,
                        injectsbiterra          => '0',
                        injectdbiterra          => '0',
                        douta                   => Look_up_op,
                        sbiterra                => open,
                        dbiterra                => open
                   );
      end generate;

      dist_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_1 : if (C_SELECT_XPM = 0) generate

     --C_SPI_MODE_1_WB_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,       -- "virtex6",
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_1_memory_1_wb.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op ,       -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "00000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_2,
						dpo             => dpo_2,
						qdpo            => qdpo_2
						);
      end generate;
 -- look up table arrangement is as below

 -- 10       9           8           7          6           5           4        3       2          1          0
 -- Data_Dir Data Mode_1 Data Mode_0 Data_Phase Addr_Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD Mode_0 CMD_ERROR

     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);-- 10 14
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);-- 9 13
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);-- 8 12
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);-- 7 11
     -------------
     Quad_Phase   <= '0';
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5);  -- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6);  -- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7);  -- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8);  -- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);  -- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10); -- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                    -- 0
     -------------
-----------------------------------------
end generate QSPI_LOOK_UP_MODE_1_MEMORY_1;
-----------------------------------------

-------------------------------------------------------------------------------
-- QSPI_LOOK_UP_MODE_1_MEMORY_2: This is Dual mode. Dedicated Numonyx memories are supported.
--------------------------------
QSPI_LOOK_UP_MODE_1_MEMORY_2 : if (C_SPI_MODE = 1 and C_SPI_MEMORY = 2) generate
----------------------------

-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 11;
-- signal declaration
signal Look_up_op                : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal CMD_decoded_int_d1        : std_logic;
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;
signal spo_3  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_3  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_3  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);


signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address         : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  --DTR_FIFO_Data_Exists_d4 <= '0';
                  CMD_decoded_int_d1      <= '0';                  
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and not DTR_FIFO_Data_Exists_d2;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                  --DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                  --DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                  --DTR_FIFO_Data_Exists_d4 <= DTR_FIFO_Data_Exists_d3;
                  --CMD_decoded_int             <= DTR_FIFO_Data_Exists_d2 and
                  --                           not(DTR_FIFO_Data_Exists_d3);
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------


     xpm_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_2 : if (C_SELECT_XPM = 1) generate
     xpm_memory_inst: xpm_memory_sprom  

               generic map (
                       MEMORY_SIZE             => C_LUT_DEPTH*C_LOOK_UP_TABLE_WIDTH,
                       MEMORY_PRIMITIVE        =>  "lutram",
                       ECC_MODE                =>  "no_ecc",
                       MEMORY_INIT_FILE        => "mode_1_memory_2_nm.mem",
                       MEMORY_INIT_PARAM       => "",
                       WAKEUP_TIME             => "disable_sleep",
                       MESSAGE_CONTROL         =>  0,
                 
                       READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                       ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                       READ_RESET_VALUE_A      =>  "0",
                       READ_LATENCY_A          =>  1
                       )
                       port map (
                        -- Common module ports
                       sleep                   =>  '0',
                     
                      -- Port A module ports
                       clka                    => EXT_SPI_CLK,
                       rsta                    => Rst_to_spi, 
                       ena                     => '1', 
                       regcea                  => '1',
                       addra                   => Look_up_address,
                       injectsbiterra          => '0',
                       injectdbiterra          => '0',
                       douta                   => Look_up_op,
                       sbiterra                => open,
                       dbiterra                => open
                  );
     end generate;

     dist_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_2 : if (C_SELECT_XPM = 0) generate


     --C_SPI_MODE_1_NM_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,      -- "virtex6",
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_1_memory_2_nm.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op ,       -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "00000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_3,
						dpo             => dpo_3,
						qdpo            => qdpo_3
  );
end generate;
 -- look up table arrangement is as below

 -- 10          9           8          7           6           5        4        3       2          1          0
 -- Data_Dir Data_Mode_1 Data_Mode_0 Data_Phase Addr_Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD_Mode_0 CMD_ERROR


     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);-- 10 -- 14
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);-- 9  13
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);-- 8  12
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);-- 7  11
     -------------
     Quad_Phase  <= '0';
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5);  -- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6);  -- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7);  -- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8);  -- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);  -- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10); -- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                    -- 0
     -------------

-----------------------------------------
end generate QSPI_LOOK_UP_MODE_1_MEMORY_2;
-----------------------------------------
QSPI_LOOK_UP_MODE_1_MEMORY_3 : if (C_SPI_MODE = 1 and C_SPI_MEMORY = 3) generate
----------------------------

-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 11;
-- signal declaration
signal Look_up_op                : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal CMD_decoded_int_d1        : std_logic;
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;
signal spo_7  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_7  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_7  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);


signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address         : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  --DTR_FIFO_Data_Exists_d4 <= '0';
                  CMD_decoded_int_d1      <= '0';                  
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and not DTR_FIFO_Data_Exists_d2;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                  --DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                  --DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                  --DTR_FIFO_Data_Exists_d4 <= DTR_FIFO_Data_Exists_d3;
                  --CMD_decoded_int             <= DTR_FIFO_Data_Exists_d2 and
                  --                           not(DTR_FIFO_Data_Exists_d3);
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------

    xpm_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_3 : if (C_SELECT_XPM = 1) generate
    xpm_memory_inst: xpm_memory_sprom  

               generic map (
                       MEMORY_SIZE             => C_LOOK_UP_TABLE_WIDTH*C_LUT_DEPTH,
                       MEMORY_PRIMITIVE        =>  "lutram",
                       ECC_MODE                =>  "no_ecc",
                       MEMORY_INIT_FILE        =>  "mode_1_memory_3_sp.mem",
                       MEMORY_INIT_PARAM       => "",
                       WAKEUP_TIME             => "disable_sleep",
                       MESSAGE_CONTROL         =>  0,

                       READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                       ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                       READ_RESET_VALUE_A      =>  "0",
                       READ_LATENCY_A          =>  1
                       )
                       port map (
                        -- Common module ports
                       sleep                   =>  '0',
                     
                      -- Port A module ports
                       clka                    => EXT_SPI_CLK,
                       rsta                    => Rst_to_spi, 
                       ena                     => '1', 
                       regcea                  => '1',
                       addra                   => Look_up_address,
                       injectsbiterra          => '0',
                       injectdbiterra          => '0',
                       douta                   => Look_up_op,
                       sbiterra                => open,
                       dbiterra                => open
                  );
     end generate;
 
     dist_mem_gen_QSPI_LOOK_UP_MODE_1_MEMORY_3 : if (C_SELECT_XPM = 0) generate

     --C_SPI_MODE_1_NM_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,      -- "virtex6",
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_1_memory_3_sp.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op ,       -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "00000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_7,
						dpo             => dpo_7,
						qdpo            => qdpo_7
  );
end generate;
 -- look up table arrangement is as below

 -- 10          9           8          7           6           5        4        3       2          1          0
 -- Data_Dir Data_Mode_1 Data_Mode_0 Data_Phase Addr_Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD_Mode_0 CMD_ERROR


     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);-- 10 -- 14
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);-- 9  13
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);-- 8  12
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);-- 7  11
     -------------
     Quad_Phase  <= '0';
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5);  -- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6);  -- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7);  -- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8);  -- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);  -- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10); -- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                    -- 0
     -------------

-----------------------------------------
end generate QSPI_LOOK_UP_MODE_1_MEMORY_3;

   -- LUT for C_SPI_MODE = 1 ends   --

   -- LUT for C_SPI_MODE = 2 starts --

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- QSPI_LOOK_UP_MODE_2_MEMORY_0: This is Dual mode. Mixed mode memories are supported.
--------------------------------
QSPI_LOOK_UP_MODE_2_MEMORY_0 : if (C_SPI_MODE = 2 and C_SPI_MEMORY = 0) generate
----------------------------

-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 12;-- quad phase bit is added to support DQ3 = 1 in command phase for NM memories.
-- signal declaration
signal Look_up_op          : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal CMD_decoded_int_d1        : std_logic;
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;
signal spo_6  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_6  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_6  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);


signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address         : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  --DTR_FIFO_Data_Exists_d4 <= '0';
                  CMD_decoded_int_d1      <= '0';                  
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and
                                             not DTR_FIFO_Data_Exists_d2 and
                                             Pr_state_idle;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                  --DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                  --DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                  --DTR_FIFO_Data_Exists_d4 <= DTR_FIFO_Data_Exists_d3;
                  --CMD_decoded_int         <= DTR_FIFO_Data_Exists_d2      and
                  --                           not(DTR_FIFO_Data_Exists_d3) and
                  --                           Pr_state_idle;
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------

     xpm_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_0 : if (C_SELECT_XPM = 1) generate
     xpm_memory_inst: xpm_memory_sprom  

              generic map (
                      MEMORY_SIZE             => C_LOOK_UP_TABLE_WIDTH*C_LUT_DEPTH,
                      MEMORY_PRIMITIVE        =>  "lutram",
                      ECC_MODE                =>  "no_ecc",
                      MEMORY_INIT_FILE        =>  "mode_2_memory_0_mixed.mem",
                      MEMORY_INIT_PARAM       => "",
                      WAKEUP_TIME             => "disable_sleep",
                      MESSAGE_CONTROL         =>  0,

                      READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                      ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                      READ_RESET_VALUE_A      =>  "0",
                      READ_LATENCY_A          =>  1
                      )
                      port map (
                       -- Common module ports
                      sleep                   =>  '0',
                    
                     -- Port A module ports
                      clka                    => EXT_SPI_CLK,
                      rsta                    => Rst_to_spi, 
                      ena                     => '1', 
                      regcea                  => '1',
                      addra                   => Look_up_address,
                      injectsbiterra          => '0',
                      injectdbiterra          => '0',
                      douta                   => Look_up_op,
                      sbiterra                => open,
                      dbiterra                => open
                 );
     end generate;

     dist_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_0 : if (C_SELECT_XPM = 0) generate


     --C_SPI_MODE_2_MIXED_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_2_memory_0_mixed.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen core
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op ,        -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "000000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_6,
						dpo             => dpo_6,
						qdpo            => qdpo_6
   );
end generate;
 -- look up table arrangement is as below

 -- 11       10          9           8          7          6           5           4        3       2          1          0
 -- Data_Dir Data Mode_1 Data Mode_0 Data_Phase Quad_Phase Addr_Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD Mode_0 CMD Error

     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);-- 15
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);-- 14
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);-- 13
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);-- 12
     -------------
     Quad_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5); -- 7
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6);-- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7);-- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8);-- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);-- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10);-- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 11);-- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                   -- 0
     -------------
-----------------------------------------
end generate QSPI_LOOK_UP_MODE_2_MEMORY_0;
-----------------------------------------
-------------------------------------------------------------------------------
-- QSPI_LOOK_UP_MODE_2_MEMORY_1: This is Dual mode. Dedicated Winbond memories are supported.
--------------------------------
QSPI_LOOK_UP_MODE_2_MEMORY_1 : if (C_SPI_MODE = 2 and C_SPI_MEMORY = 1) generate
----------------------------

-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 11;
-- signal declaration
signal Look_up_op                : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal CMD_decoded_int_d1        : std_logic;
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;
signal spo_4  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_4  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_4  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);


signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address         : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  --DTR_FIFO_Data_Exists_d4 <= '0';
                  CMD_decoded_int_d1      <= '0';
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and
                                         not DTR_FIFO_Data_Exists_d2;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                 -- DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                 -- DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                 -- --DTR_FIFO_Data_Exists_d4 <= DTR_FIFO_Data_Exists_d3;
                 -- CMD_decoded_int         <= DTR_FIFO_Data_Exists_d2 and
                 --                            not(DTR_FIFO_Data_Exists_d3);
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------


     xpm_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_1 : if (C_SELECT_XPM = 1) generate
     xpm_memory_inst: xpm_memory_sprom  

               generic map (
                       MEMORY_SIZE             => C_LOOK_UP_TABLE_WIDTH*C_LUT_DEPTH,
                       MEMORY_PRIMITIVE        =>  "lutram",
                       ECC_MODE                =>  "no_ecc",
                       MEMORY_INIT_FILE        =>  "mode_2_memory_1_wb.mem",
                       MEMORY_INIT_PARAM       => "",
                       WAKEUP_TIME             => "disable_sleep",
                       MESSAGE_CONTROL         =>  0,

                       READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                       ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                       READ_RESET_VALUE_A      =>  "0",
                       READ_LATENCY_A          =>  1
                       )
                       port map (
                        -- Common module ports
                       sleep                   =>  '0',
                     
                      -- Port A module ports
                       clka                    => EXT_SPI_CLK,
                       rsta                    => Rst_to_spi, 
                       ena                     => '1', 
                       regcea                  => '1',
                       addra                   => Look_up_address,
                       injectsbiterra          => '0',
                       injectdbiterra          => '0',
                       douta                   => Look_up_op,
                       sbiterra                => open,
                       dbiterra                => open
             );
     end generate;

     dist_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_1 : if (C_SELECT_XPM = 0) generate

     --C_SPI_MODE_2_WB_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_2_memory_1_wb.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen core
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op  ,      -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "00000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_4,
						dpo             => dpo_4,
						qdpo            => qdpo_4
   );
end generate;

 -- look up table arrangement is as below

 -- 10       9           8          7           6           5           4        3       2          1          0
 -- Data_Dir Data Mode_1 Data Mode_0 Data_Phase Addr Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD Mode_0 CMD Error


     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);-- 10 -- 14
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);-- 9     13
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);-- 8     12
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);-- 7     11
     -------------
     Quad_Phase  <= '0';
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5);  -- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6); -- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7); -- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8); -- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);-- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10);-- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                   -- 0
     -------------

     -- Dummy_Bits <= (Dummy_3 and DTR_FIFO_Data_Exists) &
     --               (Dummy_2 and DTR_FIFO_Data_Exists) &
     --               (Dummy_1 and DTR_FIFO_Data_Exists) &
     --               (Dummy_0 and DTR_FIFO_Data_Exists);
-----------------------------------------
end generate QSPI_LOOK_UP_MODE_2_MEMORY_1;
-----------------------------------------
-------------------------------------------------------------------------------
-- QSPI_LOOK_UP_MODE_2_MEMORY_2: This is Dual mode. Dedicated Numonyx memories are supported.
--------------------------------
QSPI_LOOK_UP_MODE_2_MEMORY_2 : if (C_SPI_MODE = 2 and C_SPI_MEMORY = 2) generate
----------------------------

-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 12;-- quad phase bit is added to support DQ3 = 1 in command phase for NM memories.
-- signal declaration
signal Look_up_op                : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal CMD_decoded_int_d1        : std_logic;
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;
signal spo_5  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_5  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_5  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);


signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address         : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  CMD_decoded_int_d1      <= '0';
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and
                                         not DTR_FIFO_Data_Exists_d2 and
                                             Pr_state_idle;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                  --DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                  --DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                  --CMD_decoded_int         <= DTR_FIFO_Data_Exists_d2      and
                  --                           not(DTR_FIFO_Data_Exists_d3) and
                  --                           Pr_state_idle;
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------

     xpm_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_2 : if (C_SELECT_XPM = 1) generate
     xpm_memory_inst: xpm_memory_sprom  

               generic map (
                       MEMORY_SIZE             => C_LOOK_UP_TABLE_WIDTH*C_LUT_DEPTH,
                       MEMORY_PRIMITIVE        =>  "lutram",
                       ECC_MODE                =>  "no_ecc",
                       MEMORY_INIT_FILE        =>  "mode_2_memory_2_nm.mem",
                       MEMORY_INIT_PARAM       => "",
                       WAKEUP_TIME             => "disable_sleep",
                       MESSAGE_CONTROL         =>  0,

                       READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                       ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                       READ_RESET_VALUE_A      =>  "0",
                       READ_LATENCY_A          =>  1
                       )
                       port map (
                        -- Common module ports
                       sleep                   =>  '0',
                     
                      -- Port A module ports
                       clka                    => EXT_SPI_CLK,
                       rsta                    => Rst_to_spi, 
                       ena                     => '1', 
                       regcea                  => '1',
                       addra                   => Look_up_address,
                       injectsbiterra          => '0',
                       injectdbiterra          => '0',
                       douta                   => Look_up_op,
                       sbiterra                => open,
                       dbiterra                => open
      );
      end generate;

      dist_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_2 : if (C_SELECT_XPM = 0) generate

     --C_SPI_MODE_2_NM_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,       -- "virtex6",
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_2_memory_2_nm.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen core
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op,        -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "000000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_5,
						dpo             => dpo_5,
						qdpo            => qdpo_5
  );
end generate;
 -- look up table arrangement is as below
 -- 11       10          9           8          7          6           5           4        3       2          1          0
 -- Data_Dir Data Mode_1 Data Mode_0 Data_Phase Quad_Phase Addr_Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD Mode_0 CMD Error

     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);-- 11 -- 15
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);-- 10 -- 14
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);-- 9  -- 13
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);-- 8  -- 12
     -------------
     Quad_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5); -- 7
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6);-- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7);-- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8);-- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);-- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10);-- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 11);-- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                   -- 0
     -------------


-----------------------------------------
end generate QSPI_LOOK_UP_MODE_2_MEMORY_2;
-----------------------------------------
QSPI_LOOK_UP_MODE_2_MEMORY_3 : if (C_SPI_MODE = 2 and C_SPI_MEMORY = 3) generate
----------------------------

-- constant declaration
constant C_LOOK_UP_TABLE_WIDTH : integer := 12;-- quad phase bit is added to support DQ3 = 1 in command phase for NM memories.
-- signal declaration
signal Look_up_op                : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal CMD_decoded_int_d1        : std_logic;
signal DTR_FIFO_Data_Exists_d1   : std_logic;
signal DTR_FIFO_Data_Exists_d2   : std_logic;
signal DTR_FIFO_Data_Exists_d3   : std_logic;
--signal DTR_FIFO_Data_Exists_d4   : std_logic;
signal spo_8  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal dpo_8  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);
signal qdpo_8  : std_logic_vector(C_LOOK_UP_TABLE_WIDTH-1 downto 0);


signal Store_DTR_FIFO_First_Data : std_logic;
signal Look_up_address         : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

-----
begin
-----      _________
     -- __|            -- DTR_FIFO_Data_Exists
     --       ______
     -- _____|         -- DTR_FIFO_Data_Exists_d1
     --    __
     -- __|  |______   -- Store_DTR_FIFO_First_Data
     TRFIFO_DATA_EXIST_D1_PROCESS: process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if (EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
              if (Rst_to_spi = RESET_ACTIVE) then
                  DTR_FIFO_Data_Exists_d1 <= '0';
                  DTR_FIFO_Data_Exists_d2 <= '0';
                  DTR_FIFO_Data_Exists_d3 <= '0';
                  CMD_decoded_int_d1      <= '0';
                  CMD_decoded_int         <= '0';
              else
                  DTR_FIFO_Data_Exists_d1 <= DTR_FIFO_Data_Exists and pr_state_idle;
                  CMD_decoded_int_d1      <= DTR_FIFO_Data_Exists_d1 and
                                         not DTR_FIFO_Data_Exists_d2 and
                                             Pr_state_idle;
                  CMD_decoded_int         <= CMD_decoded_int_d1;
                  --DTR_FIFO_Data_Exists_d2 <= DTR_FIFO_Data_Exists_d1;
                  --DTR_FIFO_Data_Exists_d3 <= DTR_FIFO_Data_Exists_d2;
                  --CMD_decoded_int         <= DTR_FIFO_Data_Exists_d2      and
                  --                           not(DTR_FIFO_Data_Exists_d3) and
                  --                           Pr_state_idle;
              end if;
          end if;
     end process TRFIFO_DATA_EXIST_D1_PROCESS;
     -----------------------------------------
     CMD_decoded <= CMD_decoded_int;
     Store_DTR_FIFO_First_Data <= DTR_FIFO_Data_Exists         and
                                  not(DTR_FIFO_Data_Exists_d1) and
                                  Pr_state_idle;

     -----------------------------------------
     TXFIFO_ADDR_BITS_GENERATE: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     -----
     begin
     -----

     TXFIFO_FIRST_ENTRY_REG_I: component FDRE
             port map
             (
             Q  => Look_up_address(i)        ,--: out
             C  => EXT_SPI_CLK                ,--: in
             CE => Store_DTR_FIFO_First_Data ,--: in
             R  => Local_rst                 ,--: in
             D  => Data_From_TxFIFO(i)        --: in
             );

     end generate TXFIFO_ADDR_BITS_GENERATE;
     ---------------------------------------

     xpm_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_3 : if (C_SELECT_XPM = 1) generate
     xpm_memory_inst: xpm_memory_sprom  

               generic map (
                       MEMORY_SIZE             => C_LOOK_UP_TABLE_WIDTH*C_LUT_DEPTH,
                       MEMORY_PRIMITIVE        =>  "lutram",
                       ECC_MODE                =>  "no_ecc",
                       MEMORY_INIT_FILE        =>  "mode_2_memory_3_sp.mem",
                       MEMORY_INIT_PARAM       => "",
                       WAKEUP_TIME             => "disable_sleep",
                       MESSAGE_CONTROL         =>  0,
                 
                       READ_DATA_WIDTH_A       =>  C_LOOK_UP_TABLE_WIDTH,
                       ADDR_WIDTH_A            =>  C_LUT_DWIDTH, 
                       READ_RESET_VALUE_A      =>  "0",
                       READ_LATENCY_A          =>  1
                       )
                       port map (
                        -- Common module ports
                       sleep                   =>  '0',
                     
                      -- Port A module ports
                       clka                    => EXT_SPI_CLK,
                       rsta                    => Rst_to_spi, 
                       ena                     => '1', 
                       regcea                  => '1',
                       addra                   => Look_up_address,
                       injectsbiterra          => '0',
                       injectdbiterra          => '0',
                       douta                   => Look_up_op,
                       sbiterra                => open,
                       dbiterra                => open
      );
      end generate;

      dist_mem_gen_QSPI_LOOK_UP_MODE_2_MEMORY_3 : if (C_SELECT_XPM = 0) generate

     --C_SPI_MODE_2_NM_ROM_I: dist_mem_gen_v6_4
     C_SPI_MODE_1_MIXED_ROM_I: entity dist_mem_gen_v8_0_11.dist_mem_gen_v8_0_11
     -------------------
                generic map(
                        C_HAS_CLK               => 1,
                        C_READ_MIF              => 1,
                        C_HAS_QSPO              => 1,
                        C_ADDR_WIDTH            => C_LUT_DWIDTH,
                        C_WIDTH                 => C_LOOK_UP_TABLE_WIDTH,
                        C_FAMILY                => C_FAMILY,       -- "virtex6",
                        C_SYNC_ENABLE           => 1,
                        C_DEPTH                 => C_LUT_DEPTH,
                        C_HAS_QSPO_SRST         => 1,
                        C_MEM_INIT_FILE         => "mode_2_memory_3_sp.mif",
                        C_DEFAULT_DATA          => "0",
                        ------------------------
                        C_HAS_QDPO_CLK          => 0,
                        C_HAS_QDPO_CE           => 0,
                        C_PARSER_TYPE           => 1,
                        C_HAS_D                 => 0,
                        C_HAS_SPO               => 0,
                        C_REG_A_D_INPUTS        => 0,
                        C_HAS_WE                => 0,
                        C_PIPELINE_STAGES       => 0,
                        C_HAS_QDPO_RST          => 0,
                        C_REG_DPRA_INPUT        => 0,
                        C_QUALIFY_WE            => 0,
                        C_HAS_QDPO_SRST         => 0,
                        C_HAS_DPRA              => 0,
                        C_QCE_JOINED            => 0,
                        C_MEM_TYPE              => 0,
                        C_HAS_I_CE              => 0,
                        C_HAS_DPO               => 0,
                        -- C_HAS_SPRA              => 0, -- removed from dist mem gen core
                        C_HAS_QSPO_CE           => 0,
                        C_HAS_QSPO_RST          => 0,
                        C_HAS_QDPO              => 0
                        -------------------------
                )
                port map(
                        a               => Look_up_address , --         a,      -- in std_logic_vector(7 downto 0)
                        clk             => EXT_SPI_CLK      , --       clk,      -- in
                        qspo_srst       => Rst_to_spi   , -- qspo_srst,      -- in
                        qspo            => Look_up_op,        -- qspo            -- out std_logic_vector(9 downto 0)
                        d               => "000000000000", 
						dpra            => "00000000",
						we              => '0',
						i_ce            => '1',
						qspo_ce         => '1',
						qdpo_ce         => '1', 
						qdpo_clk        => '0',
						qspo_rst        => '0',
						qdpo_rst        => '0',
						qdpo_srst       => '0',
						spo             => spo_8,
						dpo             => dpo_8,
						qdpo            => qdpo_8
  );
end generate;
 -- look up table arrangement is as below
 -- 11       10          9           8          7          6           5           4        3       2          1          0
 -- Data_Dir Data Mode_1 Data Mode_0 Data_Phase Quad_Phase Addr_Mode_1 Addr_Mode_0 Addr_Bit Addr_Ph CMD_Mode_1 CMD Mode_0 CMD Error

     -------------
     Data_Dir     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 1);-- 11 -- 15
     Data_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 2);-- 10 -- 14
     Data_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 3);-- 9  -- 13
     Data_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 4);-- 8  -- 12
     -------------
     Quad_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 5); -- 7
     Addr_Mode_1  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 6);-- 6
     Addr_Mode_0  <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 7);-- 5
     Addr_Bit     <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 8);-- 4
     Addr_Phase   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 9);-- 3
     -------------
     CMD_Mode_1   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 10);-- 2
     CMD_Mode_0   <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - 11);-- 1
     CMD_Error    <= Look_up_op(C_LOOK_UP_TABLE_WIDTH - C_LOOK_UP_TABLE_WIDTH)
                     and CMD_decoded_int;                   -- 0
     -------------


-----------------------------------------
end generate QSPI_LOOK_UP_MODE_2_MEMORY_3;

---------------------
end architecture imp;
---------------------


-------------------------------------------------------------------------------
-- qspi_fifo_ifmodule.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_fifo_ifmodule.vhd
-- Version:         v3.0
-- Description:     Quad Serial Peripheral Interface (QSPI) Module for interfacing
--                  with a 32-bit axi Bus. FIFO Interface module
--
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;


-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------
--  C_NUM_TRANSFER_BITS         --  SPI Serial transfer width.
--                                  Can be 8, 16 or 32 bit wide
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------
-- SYSTEM
--  Bus2IP_Clk                  --      Bus to IP clock
--  Soft_Reset_op                       --      Soft_Reset_op Signal

-- SLAVE ATTACHMENT INTERFACE
--  Bus2IP_RcFIFO_RdCE          --      Bus2IP receive FIFO read CE
--  Bus2IP_TxFIFO_WrCE          --      Bus2IP transmit FIFO write CE
--  Rd_ce_reduce_ack_gen         --     commong logid to generate the write ACK
--  Wr_ce_reduce_ack_gen        --      commong logid to generate the write ACK
--  IP2Bus_RX_FIFO_Data                 --      Data to send on the bus
--  Transmit_ip2bus_error       --      Transmit FIFO error signal
--  Receive_ip2bus_error        --      Receive FIFO error signal

-- FIFO INTERFACE
--  Data_From_TxFIFO            --      Data from transmit FIFO
--  Tx_FIFO_Data_WithZero       --      Components to put zeros on input
--                                      to Shift Register when FIFO is empty
--  Data_From_Rc_FIFO            --      Receive FIFO data output
--  Rc_FIFO_Empty               --      Receive FIFO empty
--  Rc_FIFO_Full                --      Receive FIFO full
--  Rc_FIFO_Full_strobe         --      1 cycle wide receive FIFO full strobe
--  Tx_FIFO_Empty               --      Transmit FIFO empty
--  Tx_FIFO_Empty_strobe        --      1 cycle wide transmit FIFO full strobe
--  Tx_FIFO_Full                --      Transmit FIFO full
--  Tx_FIFO_Occpncy_MSB         --      Transmit FIFO occupancy register
--                                      MSB bit
--  Tx_FIFO_less_half           --      Transmit FIFO less than half empty

-- SPI MODULE INTERFACE

--  DRR_Overrun                 --      DRR Overrun bit
--  SPIXfer_done                --      SPI transfer done flag
--  DTR_Underrun_strobe         --      DTR Underrun Strobe bit
--  DTR_underrun                --      DTR underrun generation signal
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity qspi_fifo_ifmodule is
    generic
    (
       C_NUM_TRANSFER_BITS         : integer
       ----------------------------
    );
    port
    (
       Bus2IP_Clk           : in  std_logic;
       Soft_Reset_op        : in  std_logic;
       -- Slave attachment ports
       Bus2IP_RcFIFO_RdCE   : in  std_logic;
       Bus2IP_TxFIFO_WrCE   : in  std_logic;
       Rd_ce_reduce_ack_gen : in std_logic;

       -- FIFO ports
       Data_From_TxFIFO     : in std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
       Data_From_Rc_FIFO    : in std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
       Tx_FIFO_Data_WithZero: out std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
       IP2Bus_RX_FIFO_Data  : out std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
       ---------------------
       Rc_FIFO_Full         : in  std_logic;
       Rc_FIFO_Full_strobe  : out std_logic;
       ---------------------
       Tx_FIFO_Empty        : in  std_logic;
       Tx_FIFO_Empty_strobe : out std_logic;
       ---------------------
       Rc_FIFO_Empty        : in  std_logic;
       Receive_ip2bus_error : out std_logic;
       Tx_FIFO_Full         : in  std_logic;
       Transmit_ip2bus_error: out std_logic;
       ---------------------
       Tx_FIFO_Occpncy_MSB  : in  std_logic;
       Tx_FIFO_less_half    : out std_logic;
       ---------------------
       DTR_underrun         : in std_logic;
       DTR_Underrun_strobe  : out std_logic;
       ---------------------
       SPIXfer_done         : in std_logic;
       rready               : in std_logic
       --DRR_Overrun_reg      : out std_logic
       ---------------------
    );
end qspi_fifo_ifmodule;

-------------------------------------------------------------------------------
-- Architecture
---------------
architecture imp of qspi_fifo_ifmodule is
---------------------------------------------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- Signal Declarations
----------------------
-- signal drr_Overrun_i            :  std_logic;
signal rc_FIFO_Full_d1          :  std_logic;
signal dtr_Underrun_strobe_i    :  std_logic;
signal tx_FIFO_Empty_d1         :  std_logic;
signal tx_FIFO_Occpncy_MSB_d1   :  std_logic;
signal dtr_underrun_d1          :  std_logic;

signal RST_TxFIFO_ptr_int       : std_logic;
--signal DRR_Overrun_reg_int      : std_logic;
---------------------------------------------

begin
-----
--  Combinatorial operations
-------------------------------------------------------------------------------


  --  DRR_Overrun_reg <= DRR_Overrun_reg_int;
-------------------------------------------------------------------------------
--  SPI_RECEIVE_FIFO_RD_GENERATE : Read of SPI receive FIFO
----------------------------------
SPI_RECEIVE_FIFO_RD_GENERATE: for i in 0 to C_NUM_TRANSFER_BITS-1 generate
-----
begin
-----
     IP2Bus_RX_FIFO_Data(i) <= Data_From_Rc_FIFO(i) and
                              (
                                (Rd_ce_reduce_ack_gen or rready) and
                                Bus2IP_RcFIFO_RdCE
                               );
end generate SPI_RECEIVE_FIFO_RD_GENERATE;
-------------------------------------------------------------------------------
--  PUT_ZEROS_IN_SR_GENERATE : Put zeros on input to SR when FIFO is empty.
--                             Requested by software designers
------------------------------
PUT_ZEROS_IN_SR_GENERATE: for i in 0 to C_NUM_TRANSFER_BITS-1 generate
begin
-----
    Tx_FIFO_Data_WithZero(i) <= Data_From_TxFIFO(i) and (not Tx_FIFO_Empty);
end generate PUT_ZEROS_IN_SR_GENERATE;
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
--  RX_ERROR_ACK_REG_PROCESS : Strobe error when receive FIFO is empty.
-------------------------------- This signal will be OR'ed to generate IP2Bus_Error signal.
RX_ERROR_ACK_REG_PROCESS:process(Bus2IP_Clk) is
-----
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            Receive_ip2bus_error <= '0';
        else
            Receive_ip2bus_error <= Rc_FIFO_Empty and Bus2IP_RcFIFO_RdCE;
        end if;
    end if;
end process RX_ERROR_ACK_REG_PROCESS;
-------------------------------------------------------------------------------
--  TX_ERROR_ACK_REG_PROCESS : Strobe error when transmit FIFO is full
-------------------------------- This signal will be OR'ed to generate IP2Bus_Error signal.
TX_ERROR_ACK_REG_PROCESS:process(Bus2IP_Clk) is
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            Transmit_ip2bus_error <= '0';
        else
            Transmit_ip2bus_error <= Tx_FIFO_Full and Bus2IP_TxFIFO_WrCE;
        end if;
    end if;
end process TX_ERROR_ACK_REG_PROCESS;
-------------------------------------------------------------------------------

-- **********************************************************
-- Below logic will generate the inputs to the Interrupt bits
-- **********************************************************
-------------------------------------------------------------------------------
-- I_DRR_OVERRUN_REG_PROCESS:DRR overrun strobe-1 cycle strobe will be generated
-----------------------------
--DRR_OVERRUN_REG_PROCESS:process(Bus2IP_Clk) is
-------
--begin
-------
--    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
--        if (Soft_Reset_op = RESET_ACTIVE) then
--            DRR_Overrun_reg_int <= '0';
--        else
--            DRR_Overrun_reg_int <= not(DRR_Overrun_reg_int or Soft_Reset_op) and
--                                                                Rc_FIFO_Full and
--                                                                SPIXfer_done;
--        end if;
--    end if;
--end process DRR_OVERRUN_REG_PROCESS;
-------------------------------------------------------------------------------
--  RX_FIFO_STROBE_REG_PROCESS : Strobe when receive FIFO is full
----------------------------------
RX_FIFO_STROBE_REG_PROCESS:process(Bus2IP_Clk) is
begin
-----
if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            rc_FIFO_Full_d1 <= '0';
        else
            rc_FIFO_Full_d1 <= Rc_FIFO_Full;
        end if;
    end if;
end process RX_FIFO_STROBE_REG_PROCESS;
-----------------------------------------
Rc_FIFO_Full_strobe <= (not rc_FIFO_Full_d1) and Rc_FIFO_Full;


-- TX_FIFO_STROBE_REG_PROCESS : Strobe when transmit FIFO is empty
----------------------------------
TX_FIFO_STROBE_REG_PROCESS:process(Bus2IP_Clk)is
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            tx_FIFO_Empty_d1 <= '1';
        else
            tx_FIFO_Empty_d1 <= Tx_FIFO_Empty;
        end if;
    end if;
end process TX_FIFO_STROBE_REG_PROCESS;
-----------------------------------------
Tx_FIFO_Empty_strobe <= (not tx_FIFO_Empty_d1) and Tx_FIFO_Empty;

-------------------------------------------------------------------------------
--  DTR_UNDERRUN_REG_PROCESS_P : Strobe to interrupt for transmit data underrun
--                           which happens only in slave mode
-----------------------------
DTR_UNDERRUN_REG_PROCESS_P:process(Bus2IP_Clk)is

begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            dtr_underrun_d1 <= '0';
        else
            dtr_underrun_d1 <= DTR_underrun;
        end if;
    end if;
end process DTR_UNDERRUN_REG_PROCESS_P;
---------------------------------------
DTR_Underrun_strobe <= DTR_underrun and (not dtr_underrun_d1);

-------------------------------------------------------------------------------
--  TX_FIFO_HALFFULL_STROBE_REG_PROCESS_P : Strobe for when transmit FIFO is
--                                          less than half full
-------------------------------------------
TX_FIFO_HALFFULL_STROBE_REG_PROCESS_P:process(Bus2IP_Clk) is
-----
begin
-----
    if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
        if (Soft_Reset_op = RESET_ACTIVE) then
            tx_FIFO_Occpncy_MSB_d1 <= '0';
        else
            tx_FIFO_Occpncy_MSB_d1 <= Tx_FIFO_Occpncy_MSB;
        end if;
    end if;
end process TX_FIFO_HALFFULL_STROBE_REG_PROCESS_P;
--------------------------------------------------

Tx_FIFO_less_half <= tx_FIFO_Occpncy_MSB_d1 and (not Tx_FIFO_Occpncy_MSB);
--------------------------------------------------------------------------

end imp;
--------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- qspi_cntrl_reg.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_cntrl_reg.vhd
-- Version:         v3.0
-- Description:     control register module for axi quad spi. This module decides the
--                  behavior of the core in master/slave, CPOL/CPHA etc modes.
--
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

library unisim;
    use unisim.vcomponents.FDRE;
-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------

--  C_S_AXI_DATA_WIDTH                --      Width of the slave data bus
--  C_SPI_NUM_BITS_REG              --      Width of SPI registers

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------

-- SYSTEM

--  Bus2IP_Clk                  --      Bus to IP clock
--  Soft_Reset_op               --      Soft_Reset_op Signal

-- SLAVE ATTACHMENT INTERFACE
--  Wr_ce_reduce_ack_gen  --      common write ack generation logic input
--  Bus2IP_SPICR_data     --      Data written from the PLB bus
--  Bus2IP_SPICR_WrCE     --      Write CE for control register
--  Bus2IP_SPICR_RdCE     --      Read CE for control register
--  IP2Bus_SPICR_Data     --      Data to be send on the bus

-- SPI MODULE INTERFACE
--  Control_Register_Data       --      Data to be send on the bus
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity qspi_cntrl_reg is
      generic
      (
      ----------------------------
      C_S_AXI_DATA_WIDTH         : integer;       -- 32 bits
      ----------------------------
      -- Number of bits in register, 10 for control reg - to match old version
      C_SPI_NUM_BITS_REG         : integer;
      ----------------------------
      C_SPICR_REG_WIDTH          : integer;
      ----------------------------
      C_SPI_MODE                 : integer
      ----------------------------
      );
      port
      (
      Bus2IP_Clk                : in  std_logic;
      Soft_Reset_op             : in  std_logic;

      -- Slave attachment ports
      Wr_ce_reduce_ack_gen      : in  std_logic;
      Bus2IP_SPICR_WrCE         : in  std_logic;
      Bus2IP_SPICR_RdCE         : in  std_logic;
      Bus2IP_SPICR_data         : in  std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1));

      -- SPI module ports
      SPICR_0_LOOP              : out std_logic;
      SPICR_1_SPE               : out std_logic;
      SPICR_2_MASTER_N_SLV      : out std_logic;
      SPICR_3_CPOL              : out std_logic;
      SPICR_4_CPHA              : out std_logic;
      SPICR_5_TXFIFO_RST        : out std_logic;
      SPICR_6_RXFIFO_RST        : out std_logic;
      SPICR_7_SS                : out std_logic;
      SPICR_8_TR_INHIBIT        : out std_logic;
      SPICR_9_LSB               : out std_logic;

      --------------------------
      -- to Status Register
      SPISR_1_LOOP_Back_Error   : out std_logic;
      SPISR_2_MSB_Error         : out std_logic;
      SPISR_3_Slave_Mode_Error  : out std_logic;

      -- SPISR_4_XIP_Mode_On       : out std_logic;
      SPISR_4_CPOL_CPHA_Error   : out std_logic;

      IP2Bus_SPICR_Data         : out std_logic_vector(0 to (C_SPICR_REG_WIDTH-1));

      Control_bit_7_8           : out std_logic_vector(0 to 1) --(7 to 8)
      );
end qspi_cntrl_reg;

-------------------------------------------------------------------------------
-- Architecture
--------------------------------------
architecture imp of qspi_cntrl_reg is
-------------------------------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- Signal Declarations
----------------------
signal SPICR_data_int            : std_logic_vector(0 to (C_SPICR_REG_WIDTH-1));
signal SPICR_3_4_Reset          : std_logic;
signal Control_bit_7_8_int      : std_logic_vector(7 to 8);

signal temp_wr_ce : std_logic;
-----
begin
-----
----------------------------
--  Combinatorial operations
----------------------------
-- Control_Register_Data   <= SPICR_data_int;

-------------------------------------------------------
SPICR_0_LOOP            <= SPICR_data_int(C_SPICR_REG_WIDTH-1); -- as per the SPICR Fig 3 in DS this bit is @ 0th position
SPICR_1_SPE             <= SPICR_data_int(C_SPICR_REG_WIDTH-2); -- as per the SPICR Fig 3 in DS this bit is @ 1st position
SPICR_2_MASTER_N_SLV    <= SPICR_data_int(C_SPICR_REG_WIDTH-3); -- as per the SPICR Fig 3 in DS this bit is @ 2nd position
SPICR_3_CPOL            <= SPICR_data_int(C_SPICR_REG_WIDTH-4); -- as per the SPICR Fig 3 in DS this bit is @ 3rd position
SPICR_4_CPHA            <= SPICR_data_int(C_SPICR_REG_WIDTH-5); -- as per the SPICR Fig 3 in DS this bit is @ 4th position
SPICR_5_TXFIFO_RST      <= SPICR_data_int(C_SPICR_REG_WIDTH-6); -- as per the SPICR Fig 3 in DS this bit is @ 5th position
SPICR_6_RXFIFO_RST      <= SPICR_data_int(C_SPICR_REG_WIDTH-7); -- as per the SPICR Fig 3 in DS this bit is @ 6th position
SPICR_7_SS              <= SPICR_data_int(C_SPICR_REG_WIDTH-8); -- as per the SPICR Fig 3 in DS this bit is @ 7th position
SPICR_8_TR_INHIBIT      <= SPICR_data_int(C_SPICR_REG_WIDTH-9); -- as per the SPICR Fig 3 in DS this bit is @ 8th position
SPICR_9_LSB             <= SPICR_data_int(C_SPICR_REG_WIDTH-10);-- as per the SPICR Fig 3 in DS this bit is @ 9th position
-------------------------------------------------------


SPISR_DUAL_MODE_STATUS_GEN : if C_SPI_MODE = 1 or C_SPI_MODE = 2 generate
----------------------------
--signal ored_SPICR_7_12 : std_logic;
begin
-----
        --ored_SPICR_7_12 <= or_reduce(SPICR_data_int(7 to 12));

        -- C_SPICR_REG_WIDTH is of 10 bit wide
        SPISR_1_LOOP_Back_Error  <= SPICR_data_int(C_SPICR_REG_WIDTH-1);-- 9th bit in present SPICR

        SPISR_2_MSB_Error        <= SPICR_data_int(C_SPICR_REG_WIDTH-C_SPICR_REG_WIDTH);    -- 0th LSB bit in present SPICR

        SPISR_3_Slave_Mode_Error <= not SPICR_data_int(C_SPICR_REG_WIDTH-3); -- Mst_n_Slv 7th bit in control register - default is slave mode of operation

        SPISR_4_CPOL_CPHA_Error  <= SPICR_data_int(C_SPICR_REG_WIDTH-5) xor  -- bit 5-CPHA and 6-CPOL in present SPICR
                                    SPICR_data_int(C_SPICR_REG_WIDTH-4);-- CPOL-CPHA = 01 or 10 in control register

end generate SPISR_DUAL_MODE_STATUS_GEN;
----------------------------------------

SPISR_NO_DUAL_MODE_STATUS_GEN : if C_SPI_MODE = 0 generate
-------------------------------
begin
-----
        SPISR_1_LOOP_Back_Error  <= '0';
        SPISR_2_MSB_Error        <= '0';
        SPISR_3_Slave_Mode_Error <= '0';
        SPISR_4_CPOL_CPHA_Error  <= '0';

end generate SPISR_NO_DUAL_MODE_STATUS_GEN;
-------------------------------------------

    SPICR_REG_RD_GENERATE: for i in 0 to C_SPICR_REG_WIDTH-1 generate
    -----
    begin
    -----
        IP2Bus_SPICR_Data(i) <= SPICR_data_int(i) and Bus2IP_SPICR_RdCE;
    end generate SPICR_REG_RD_GENERATE;
    -----------------------------------

---------------------------------------------------------------
-- Bus2IP Data bit mapping - 0 to 21 - NA
-- 22    23    24    25    26      27   28   29     30  31
--
-- Control Register - 0 to 22 bit mapping
-- 0     1     2     3     4       5    6    7      8   9
-- LSB TRAN MANUAL RX FIFO TX FIFO CPHA CPOL MASTER SPE LOOP
--     INHI SLAVE  RST     RST
-- '0' '1'  '1'    '0'     '0'     '0'  '0'  '0'    '0' '0'
-----------------------------------------------------
-- AXI Data    31 downto 0                          |
-- valid bits in AXI start from LSB i.e. 0          |
-- Bus2IP_Data 0  to     31                         |
-- **** IMP Starts ****                             |
-- This is 1 is to 1 mapping with reverse bit order.|
-- **** IMP Ends   ****                             |
-- Bus2IP_Data 0 1 2 3 4 5 6 7  21 22--->31         |
-- Control Bits<-------NA--------> 0---->9          |
-----------------------------------------------------
--SPICR_NO_DUAL_MODE_WR_GEN: if C_SPI_MODE = 0 generate
---------------------------------
--begin
-----
--    SPICR_data_int(0 to 12) <= (others => '0');

--end generate SPICR_NO_DUAL_MODE_WR_GEN;
----------------------------------------------

    temp_wr_ce <= wr_ce_reduce_ack_gen and Bus2IP_SPICR_WrCE;

    -- --  SPICR_REG_0_PROCESS : Control Register Write Operation for bit 0 - LSB
    -- -----------------------------
    -- Behavioral Code **
    SPICR_REG_0_PROCESS:process(Bus2IP_Clk)
    -----
    begin
    -----
        if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
            if (Soft_Reset_op = RESET_ACTIVE) then
                SPICR_data_int(0) <= '0';
            elsif ((wr_ce_reduce_ack_gen  and Bus2IP_SPICR_WrCE)='1') then
                SPICR_data_int(0) <=
                        Bus2IP_SPICR_data(C_S_AXI_DATA_WIDTH-C_SPICR_REG_WIDTH);-- after 100 ps;
            end if;
        end if;
    end process SPICR_REG_0_PROCESS;
    --------------------------------

    CONTROL_REG_1_2_GENERATE: for i in 1 to 2 generate
    ------------------------
    begin
    -----
    -- SPICR_REG_1_2_PROCESS : Control Register Write Operation for bit 1_2 - TRAN_INHI and MANUAL_SLAVE
    -----------------------------
        SPICR_REG_1_2_PROCESS:process(Bus2IP_Clk)
        -----
        begin
        -----
            if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
                if (Soft_Reset_op = RESET_ACTIVE) then
                    SPICR_data_int(i) <= '1';
                elsif((wr_ce_reduce_ack_gen  and Bus2IP_SPICR_WrCE)='1') then
                    SPICR_data_int(i) <=
                      Bus2IP_SPICR_data(C_S_AXI_DATA_WIDTH-C_SPICR_REG_WIDTH+i);-- after 100 ps;
                end if;
            end if;
        end process SPICR_REG_1_2_PROCESS;
        ----------------------------------
    end generate CONTROL_REG_1_2_GENERATE;
    --------------------------------------

    -- the below reset signal is needed to de-assert the Tx/Rx FIFO reset signals.
    SPICR_3_4_Reset <= (not Bus2IP_SPICR_WrCE) or Soft_Reset_op;

    -- CONTROL_REG_3_4_GENERATE : Control Register Write Operation for bit 3_4 - Receive FIFO Reset and Transmit FIFO Reset
    -----------------------------
    CONTROL_REG_3_4_GENERATE: for i in 3 to 4 generate
    -----
    begin
    -----
        SPICR_REG_3_4_PROCESS:process(Bus2IP_Clk)
        -----
        begin
        -----
            if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
                if (SPICR_3_4_Reset = RESET_ACTIVE) then
                    SPICR_data_int(i) <= '0';
                elsif ((wr_ce_reduce_ack_gen  and Bus2IP_SPICR_WrCE)='1') then
                    SPICR_data_int(i) <=
                          Bus2IP_SPICR_data(C_S_AXI_DATA_WIDTH-C_SPICR_REG_WIDTH+i);-- after 100 ps;
                end if;
            end if;
        end process SPICR_REG_3_4_PROCESS;
        ----------------------------------
    end generate CONTROL_REG_3_4_GENERATE;
    --------------------------------------

    -- CONTROL_REG_5_9_GENERATE : Control Register Write Operation for bit 5:9 - CPHA, CPOL, MASTER, SPE, LOOP
    -----------------------------
    CONTROL_REG_5_9_GENERATE: for i in 5 to C_SPICR_REG_WIDTH-1 generate
    -----
    begin
    -----
        SPICR_REG_5_9_PROCESS:process(Bus2IP_Clk)
        -----
        begin
        -----
            if (Bus2IP_Clk'event and Bus2IP_Clk='1') then
                if (Soft_Reset_op = RESET_ACTIVE) then
                    SPICR_data_int(i) <= '0';
                elsif ((wr_ce_reduce_ack_gen  and Bus2IP_SPICR_WrCE)='1') then
                    SPICR_data_int(i) <=
                          Bus2IP_SPICR_data(C_S_AXI_DATA_WIDTH-C_SPICR_REG_WIDTH+i);-- after 100 ps;
                end if;
            end if;
        end process SPICR_REG_5_9_PROCESS;
        ----------------------------------
    end generate CONTROL_REG_5_9_GENERATE;
    --------------------------------------

--
     -- SPICR_REG_78_GENERATE: This logic is newly added to register _T signals
     -- ------------------------ in IOB. This logic simplifies the register method
     --                          for _T in IOB, without affecting functionality.

     SPICR_REG_78_GENERATE: for i in 7 to 8 generate
     -----
     begin
     -----
     SPI_TRISTATE_CONTROL_I: component FDRE
             port map
             (
             Q  => Control_bit_7_8_int(i)    ,-- out:
             C  => Bus2IP_Clk                ,--: in
             CE => Bus2IP_SPICR_WrCE         ,--: in
             R  => Soft_Reset_op             ,-- : in
             D  => Bus2IP_SPICR_data(C_S_AXI_DATA_WIDTH-C_SPICR_REG_WIDTH+i)    --: in
             );
     end generate SPICR_REG_78_GENERATE;
     -----------------------------------

Control_bit_7_8 <= Control_bit_7_8_int;
---------------------------------------

end imp;
--------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--  Address Decoder - entity/architecture pair
-------------------------------------------------------------------------------
--
-- ************************************************************************
-- ** DISCLAIMER OF LIABILITY                                            **
-- **                                                                    **
-- ** This file contains proprietary and confidential information of     **
-- ** Xilinx, Inc. ("Xilinx"), that is distributed under a license       **
-- ** from Xilinx, and may be used, copied and/or disclosed only         **
-- ** pursuant to the terms of a valid license agreement with Xilinx.    **
-- **                                                                    **
-- ** XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION              **
-- ** ("MATERIALS") "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER         **
-- ** EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING WITHOUT                **
-- ** LIMITATION, ANY WARRANTY WITH RESPECT TO NONINFRINGEMENT,          **
-- ** MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE. Xilinx      **
-- ** does not warrant that functions included in the Materials will     **
-- ** meet the requirements of Licensee, or that the operation of the    **
-- ** Materials will be uninterrupted or error-free, or that defects     **
-- ** in the Materials will be corrected. Furthermore, Xilinx does       **
-- ** not warrant or make any representations regarding use, or the      **
-- ** results of the use, of the Materials in terms of correctness,      **
-- ** accuracy, reliability or otherwise.                                **
-- **                                                                    **
-- ** Xilinx products are not designed or intended to be fail-safe,      **
-- ** or for use in any application requiring fail-safe performance,     **
-- ** such as life-support or safety devices or systems, Class III       **
-- ** medical devices, nuclear facilities, applications related to       **
-- ** the deployment of airbags, or any other applications that could    **
-- ** lead to death, personal injury or severe property or               **
-- ** environmental damage (individually and collectively, "critical     **
-- ** applications"). Customer assumes the sole risk and liability       **
-- ** of any use of Xilinx products in critical applications,            **
-- ** subject only to applicable laws and regulations governing          **
-- ** limitations on product liability.                                  **
-- **                                                                    **
-- ** Copyright 2010 Xilinx, Inc.                                        **
-- ** All rights reserved.                                               **
-- **                                                                    **
-- ** This disclaimer and copyright notice must be retained as part      **
-- ** of this file at all times.                                         **
-- ************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_address_decoder.vhd
-- Version:         v3.0
-- Description:     Address decoder utilizing unconstrained arrays for Base
--                  Address specification and ce number.
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library axi_lite_ipif_v3_0_4;
    use axi_lite_ipif_v3_0_4.axi_lite_ipif;
    use axi_lite_ipif_v3_0_4.ipif_pkg.all;
library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;

-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------
-- C_BUS_AWIDTH          -- Address bus width
-- C_S_AXI4_MIN_SIZE      -- Minimum address range of the IP
-- C_ARD_ADDR_RANGE_ARRAY-- Base /High Address Pair for each Address Range
-- C_ARD_NUM_CE_ARRAY    -- Desired number of chip enables for an address range
-- C_FAMILY              -- Target FPGA family
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------
-- Bus_clk               -- Clock
-- Bus_rst               -- Reset
-- Address_In_Erly       -- Adddress in
-- Address_Valid_Erly    -- Address is valid
-- Bus_RNW               -- Read or write registered
-- Bus_RNW_Erly          -- Read or Write
-- CS_CE_ld_enable       -- chip select and chip enable registered
-- Clear_CS_CE_Reg       -- Clear_CS_CE_Reg clear
-- RW_CE_ld_enable       -- Read or Write Chip Enable
-- CS_for_gaps           -- CS generation for the gaps between address ranges
-- CS_Out                -- Chip select
-- RdCE_Out              -- Read Chip enable
-- WrCE_Out              -- Write chip enable
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------

entity qspi_address_decoder is
    generic (
        C_BUS_AWIDTH          : integer := 32;
        C_S_AXI4_MIN_SIZE      : std_logic_vector(0 to 31) := X"000001FF";
        C_ARD_ADDR_RANGE_ARRAY: SLV64_ARRAY_TYPE :=
            (
             X"0000_0000_1000_0000", --  IP user0 base address
             X"0000_0000_1000_01FF", --  IP user0 high address
             X"0000_0000_1000_0200", --  IP user1 base address
             X"0000_0000_1000_02FF"  --  IP user1 high address
            );
        C_ARD_NUM_CE_ARRAY  : INTEGER_ARRAY_TYPE :=
            (
             8,     -- User0 CE Number
             1      -- User1 CE Number
            );
        C_FAMILY            : string  := "virtex7" -- "virtex6"
    );
  port (
        Bus_clk             : in  std_logic;
        Bus_rst             : in  std_logic;

        -- PLB Interface signals
        Address_In_Erly     : in  std_logic_vector(0 to C_BUS_AWIDTH-1);
        Address_Valid_Erly  : in  std_logic;
        Bus_RNW             : in  std_logic;
        Bus_RNW_Erly        : in  std_logic;

        -- Registering control signals
        CS_CE_ld_enable     : in  std_logic;
        Clear_CS_CE_Reg     : in  std_logic;
        RW_CE_ld_enable     : in  std_logic;
        CS_for_gaps         : out std_logic;
        -- Decode output signals
        CS_Out              : out std_logic_vector
                                (0 to ((C_ARD_ADDR_RANGE_ARRAY'LENGTH)/2)-1);
        RdCE_Out            : out std_logic_vector
                                (0 to calc_num_ce(C_ARD_NUM_CE_ARRAY)-1);
        WrCE_Out            : out std_logic_vector
                                (0 to calc_num_ce(C_ARD_NUM_CE_ARRAY)-1)
    );
end entity qspi_address_decoder;

-------------------------------------------------------------------------------
-- Architecture section
-------------------------------------------------------------------------------

architecture imp of qspi_address_decoder is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------


-- local type declarations ----------------------------------------------------
type decode_bit_array_type is Array(natural range 0 to (
                           (C_ARD_ADDR_RANGE_ARRAY'LENGTH)/2)-1) of
                           integer;

type short_addr_array_type is Array(natural range 0 to
                           C_ARD_ADDR_RANGE_ARRAY'LENGTH-1) of
                           std_logic_vector(0 to C_BUS_AWIDTH-1);
-------------------------------------------------------------------------------
-- Function Declarations
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- This function converts a 64 bit address range array to a AWIDTH bit
-- address range array.
-------------------------------------------------------------------------------
function slv64_2_slv_awidth(slv64_addr_array   : SLV64_ARRAY_TYPE;
                            awidth             : integer)
                        return short_addr_array_type is

    variable temp_addr   : std_logic_vector(0 to 63);
    variable slv_array   : short_addr_array_type;
    begin
        for array_index in 0 to slv64_addr_array'length-1 loop
            temp_addr := slv64_addr_array(array_index);
            slv_array(array_index) := temp_addr((64-awidth) to 63);
        end loop;
        return(slv_array);
    end function slv64_2_slv_awidth;

-------------------------------------------------------------------------------
--Function Addr_bits
--function to convert an address range (base address and an upper address)
--into the number of upper address bits needed for decoding a device
--select signal.  will handle slices and big or little endian
-------------------------------------------------------------------------------
function Addr_Bits (x,y : std_logic_vector(0 to C_BUS_AWIDTH-1))
                    return integer is
    variable addr_nor : std_logic_vector(0 to C_BUS_AWIDTH-1);
    begin
        addr_nor := x xor y;
        for i in 0 to C_BUS_AWIDTH-1 loop
            if addr_nor(i)='1' then
                return i;
            end if;
        end loop;
--coverage off
        return(C_BUS_AWIDTH);
--coverage on
    end function Addr_Bits;


-------------------------------------------------------------------------------
--Function Get_Addr_Bits
--function calculates the array which has the decode bits for the each address
--range.
-------------------------------------------------------------------------------
function Get_Addr_Bits (baseaddrs : short_addr_array_type)
                        return decode_bit_array_type is

    variable num_bits : decode_bit_array_type;
    begin
        for i in 0 to ((baseaddrs'length)/2)-1 loop

            num_bits(i) :=  Addr_Bits (baseaddrs(i*2),
                                       baseaddrs(i*2+1));
        end loop;
        return(num_bits);
    end function Get_Addr_Bits;


-------------------------------------------------------------------------------
-- NEEDED_ADDR_BITS
--
-- Function Description:
--  This function calculates the number of address bits required
-- to support the CE generation logic. This is determined by
-- multiplying the number of CEs for an address space by the
-- data width of the address space (in bytes). Each address
-- space entry is processed and the biggest of the spaces is
-- used to set the number of address bits required to be latched
-- and used for CE decoding. A minimum value of 1 is returned by
-- this function.
--
-------------------------------------------------------------------------------
function needed_addr_bits (ce_array   : INTEGER_ARRAY_TYPE)
                            return integer is

    constant NUM_CE_ENTRIES     : integer := CE_ARRAY'length;
    variable biggest            : integer := 2;
    variable req_ce_addr_size   : integer := 0;
    variable num_addr_bits      : integer := 0;
    begin

        for i in 0 to NUM_CE_ENTRIES-1 loop
            req_ce_addr_size := ce_array(i) * 4;
            if (req_ce_addr_size > biggest) Then
                biggest := req_ce_addr_size;
            end if;
        end loop;
        num_addr_bits := clog2(biggest);
        return(num_addr_bits);
    end function NEEDED_ADDR_BITS;

-----------------------------------------------------------------------------
-- Function calc_high_address
--
-- This function is used to calculate the high address of the each address
-- range
-----------------------------------------------------------------------------
 function calc_high_address (high_address : short_addr_array_type;
                index      : integer) return std_logic_vector is

    variable calc_high_addr : std_logic_vector(0 to C_BUS_AWIDTH-1);

 begin
   If (index = (C_ARD_ADDR_RANGE_ARRAY'length/2-1)) Then
     calc_high_addr := C_S_AXI4_MIN_SIZE(32-C_BUS_AWIDTH to 31);
   else
     calc_high_addr := high_address(index*2+2);
   end if;
   return(calc_high_addr);
 end function calc_high_address;

----------------------------------------------------------------------------
-- Constant Declarations
-------------------------------------------------------------------------------
constant ARD_ADDR_RANGE_ARRAY   : short_addr_array_type :=
                                    slv64_2_slv_awidth(C_ARD_ADDR_RANGE_ARRAY,
                                                       C_BUS_AWIDTH);

constant NUM_BASE_ADDRS         : integer := (C_ARD_ADDR_RANGE_ARRAY'length)/2;

constant DECODE_BITS            : decode_bit_array_type :=
                                    Get_Addr_Bits(ARD_ADDR_RANGE_ARRAY);

constant NUM_CE_SIGNALS         : integer :=
                                    calc_num_ce(C_ARD_NUM_CE_ARRAY);

constant NUM_S_H_ADDR_BITS      : integer :=
                                    needed_addr_bits(C_ARD_NUM_CE_ARRAY);
-------------------------------------------------------------------------------
-- Signal Declarations
-------------------------------------------------------------------------------
signal pselect_hit_i    : std_logic_vector
                            (0 to ((C_ARD_ADDR_RANGE_ARRAY'LENGTH)/2)-1);
signal cs_out_i         : std_logic_vector
                            (0 to ((C_ARD_ADDR_RANGE_ARRAY'LENGTH)/2)-1);
signal ce_expnd_i       : std_logic_vector(0 to NUM_CE_SIGNALS-1);
signal rdce_out_i       : std_logic_vector(0 to NUM_CE_SIGNALS-1);
signal wrce_out_i       : std_logic_vector(0 to NUM_CE_SIGNALS-1);

signal ce_out_i         : std_logic_vector(0 to NUM_CE_SIGNALS-1); --

signal cs_ce_clr        : std_logic;
signal addr_out_s_h     : std_logic_vector(0 to NUM_S_H_ADDR_BITS-1);

signal Bus_RNW_reg      : std_logic;
-------------------------------------------------------------------------------
-- Begin architecture
-------------------------------------------------------------------------------
begin -- architecture IMP


-- Register clears
cs_ce_clr       <= not Bus_rst or Clear_CS_CE_Reg;

addr_out_s_h    <= Address_In_Erly(C_BUS_AWIDTH-NUM_S_H_ADDR_BITS
                                   to C_BUS_AWIDTH-1);
-------------------------------------------------------------------------------
-- MEM_DECODE_GEN: Universal Address Decode Block
-------------------------------------------------------------------------------
MEM_DECODE_GEN: for bar_index in 0 to NUM_BASE_ADDRS-1 generate
---------------
constant CE_INDEX_START : integer
                        := calc_start_ce_index(C_ARD_NUM_CE_ARRAY,bar_index);
constant CE_ADDR_SIZE   : Integer range 0 to 15
                        := clog2(C_ARD_NUM_CE_ARRAY(bar_index));
constant OFFSET         : integer := 2;

constant BASE_ADDR_x    : std_logic_vector(0 to C_BUS_AWIDTH-1)
                        := ARD_ADDR_RANGE_ARRAY(bar_index*2+1);

constant HIGH_ADDR_X    : std_logic_vector(0 to C_BUS_AWIDTH-1)
                        := calc_high_address(ARD_ADDR_RANGE_ARRAY,bar_index);
--constant DECODE_BITS_0  : integer:= DECODE_BITS(0);
---------
begin
---------

    -- GEN_FOR_MULTI_CS: Below logic generates the CS for decoded address
    -- -----------------
    GEN_FOR_MULTI_CS : if C_ARD_ADDR_RANGE_ARRAY'length > 2 generate
            -- Instantiate the basic Base Address Decoders
            MEM_SELECT_I: entity axi_quad_spi_v3_2_9.pselect_f
                generic map
                (
                    C_AB     => DECODE_BITS(bar_index),
                    C_AW     => C_BUS_AWIDTH,
                    C_BAR    => ARD_ADDR_RANGE_ARRAY(bar_index*2),
                    C_FAMILY => C_FAMILY
                )
                port map
                (
                    A        => Address_In_Erly,            -- [in]
                    AValid   => Address_Valid_Erly,         -- [in]
                    CS       => pselect_hit_i(bar_index)    -- [out]
                );
    end generate GEN_FOR_MULTI_CS;

    -- GEN_FOR_ONE_CS: below logic decodes the CS for single address range
    -- ---------------
    GEN_FOR_ONE_CS : if C_ARD_ADDR_RANGE_ARRAY'length = 2 generate
            pselect_hit_i(bar_index) <= Address_Valid_Erly;
    end generate GEN_FOR_ONE_CS;


    -- Instantate backend registers for the Chip Selects
    BKEND_CS_REG : process(Bus_Clk)
            begin
                if(Bus_Clk'EVENT and Bus_Clk = '1')then
                  if(Bus_Rst='0' or Clear_CS_CE_Reg = '1')then
                    cs_out_i(bar_index) <= '0';
                  elsif(CS_CE_ld_enable='1')then
                    cs_out_i(bar_index) <= pselect_hit_i(bar_index);
                  end if;
                end if;
    end process BKEND_CS_REG;

    -------------------------------------------------------------------------
    -- PER_CE_GEN: Now expand the individual CEs for each base address.
    -------------------------------------------------------------------------
    PER_CE_GEN: for j in 0 to C_ARD_NUM_CE_ARRAY(bar_index) - 1 generate
    -----------
    begin
    -----------
        ----------------------------------------------------------------------
        -- CE decoders for multiple CE's
        ----------------------------------------------------------------------
        MULTIPLE_CES_THIS_CS_GEN : if CE_ADDR_SIZE > 0 generate
        constant BAR    : std_logic_vector(0 to CE_ADDR_SIZE-1) :=
                            std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
        begin
            CE_I : entity axi_quad_spi_v3_2_9.pselect_f
                generic map (
                    C_AB        => CE_ADDR_SIZE                             ,
                    C_AW        => CE_ADDR_SIZE                             ,
                    C_BAR       => BAR                                      ,
                    C_FAMILY    => C_FAMILY
                )
                port map (
                    A           => addr_out_s_h
                                    (NUM_S_H_ADDR_BITS-OFFSET-CE_ADDR_SIZE
                                    to NUM_S_H_ADDR_BITS - OFFSET - 1)      ,
                    AValid      => pselect_hit_i(bar_index)                 ,
                    CS          => ce_expnd_i(CE_INDEX_START+j)
                );
            end generate MULTIPLE_CES_THIS_CS_GEN;
            --------------------------------------
        ----------------------------------------------------------------------
        -- SINGLE_CE_THIS_CS_GEN: CE decoders for single CE
        ----------------------------------------------------------------------
        SINGLE_CE_THIS_CS_GEN : if CE_ADDR_SIZE = 0 generate
            ce_expnd_i(CE_INDEX_START+j) <= pselect_hit_i(bar_index);
        end generate;
        -------------
    end generate PER_CE_GEN;
    ------------------------
end generate MEM_DECODE_GEN;

    -- RNW_REG_P: Register the incoming RNW signal at the time of registering the
    --            address. This is  need to generate the CE's separately.

    RNW_REG_P:process(Bus_Clk)
    begin
    if(Bus_Clk'EVENT and Bus_Clk = '1')then
       if(RW_CE_ld_enable='1')then
        Bus_RNW_reg <= Bus_RNW_Erly;
       end if;
    end if;
    end process RNW_REG_P;

    ---------------------------------------------------------------------------
    -- GEN_BKEND_CE_REGISTERS
    -- This ForGen implements the backend registering for
    -- the CE, RdCE, and WrCE output buses.
    ---------------------------------------------------------------------------
GEN_BKEND_CE_REGISTERS : for ce_index in 0 to NUM_CE_SIGNALS-1 generate
signal rdce_expnd_i : std_logic_vector(0 to NUM_CE_SIGNALS-1);
signal wrce_expnd_i : std_logic_vector(0 to NUM_CE_SIGNALS-1);
------
begin
------


    BKEND_RDCE_REG : process(Bus_Clk)
        begin
            if(Bus_Clk'EVENT and Bus_Clk = '1')then
              if(cs_ce_clr='1')then
                ce_out_i(ce_index) <= '0';
              elsif(RW_CE_ld_enable='1')then
                ce_out_i(ce_index) <= ce_expnd_i(ce_index);
              end if;
            end if;
    end process BKEND_RDCE_REG;
    rdce_out_i(ce_index)   <= ce_out_i(ce_index) and Bus_RNW_reg;
    wrce_out_i(ce_index)   <= ce_out_i(ce_index) and not Bus_RNW_reg;

-------------------------------
end generate GEN_BKEND_CE_REGISTERS;
-------------------------------------------------------------------------------

CS_for_gaps <= '0'; -- Removed the GAP adecoder logic
---------------------------------
CS_Out       <= cs_out_i   ;
RdCE_Out     <= rdce_out_i ;
WrCE_Out     <= wrce_out_i ;

end architecture imp;



-------------------------------------------------------------------------------
-- qspi_dual_quad_mode.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_cntrl_reg.vhd
-- Version:         v3.0
-- Description:     This module does the mux/de-mux of the SPI
--                  signals such the QSPI device can be accessed
--                  one at a time
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

library unisim;
    use unisim.vcomponents.FDRE;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;

entity qspi_dual_quad_mode is
        generic
        (
                C_SUB_FAMILY             : string  ;
                ---------------------
                C_USE_STARTUP            : integer ;
                ---------------------
                C_SHARED_STARTUP    : integer range 0 to 1 := 0;
                ---------------------
                C_SPI_MODE               : integer
                ---------------------
        );
        port
        (
                Bus2IP_Clk     : in std_logic;
                reset2ip_reset : in std_logic; 
                DI             : out std_logic_vector(3 downto 0);-- output to logic
                DO             : in std_logic_vector(3 downto 0);-- input from logic
                DT             : in std_logic_vector(3 downto 0);
                SS             : in std_logic_vector (1 downto 0);
                SS_T           : in std_logic;
                SCK            : in std_logic;
                SCK_T          : in std_logic;
-- SPI_1 interface
                spi_1_do       : out std_logic_vector (3 downto 0); --pins that interface to SPI_1 interface
                spi_1_dt       : out std_logic_vector (3 downto 0); 
                spi_1_di       : in std_logic_vector (3 downto 0);
                spi_1_ss       : out std_logic ;
                spi_1_ss_t       : out std_logic ;
           ------------------------
           -- STARTUP INTERFACE
           ------------------------
                cfgclk  : out std_logic;       -- FGCLK        , -- 1-bit output: Configuration main clock output
                cfgmclk : out std_logic; -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
                eos     : out std_logic;  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
                preq    : out std_logic; -- REQ          , -- 1-bit output: PROGRAM request to fabric output
                clk     : in std_logic;   -- input
                gsr     : in std_logic;   -- input
                gts     : in std_logic;   -- input
                keyclearb : in std_logic;   -- input
                usrcclkts : in std_logic;   -- input
                usrdoneo : in std_logic;   -- input
                usrdonets : in std_logic   -- input


        );
end entity qspi_dual_quad_mode;

-- this module muxes, de-muxes the QSPI interface. One goes to STARTUP, other goes to
-- device connected on IOs.

architecture work of qspi_dual_quad_mode is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of work : architecture is "yes";
----------------------------------------------------------------------------------
signal di_int : std_logic_vector (3 downto 0);
signal do_int : std_logic_vector (3 downto 0);
signal dts_int : std_logic_vector (3 downto 0);
signal tmp : std_logic;
signal reset_invert : std_logic;
signal tmp_pack : std_logic;

begin

tmp <= '0';
tmp_pack <= '1';
spi_1_ss <= SS(1);
spi_1_ss_t <= SS_T;
spi_1_do <= DO when (SS = "01") else "0000";
spi_1_dt <= DT when (SS = "01") else "0000";
DI <= spi_1_di when (SS = "01") else di_int;


do_int <= DO when (SS = "10") else "0000";
dts_int <= DT when (SS = "10") else "0000";

reset_invert <= not reset2ip_reset;

  QSPI_STARTUP_BLOCK_I: entity axi_quad_spi_v3_2_9.qspi_startup_block
  ---------------------
  generic map
       (
               C_SUB_FAMILY     => C_SUB_FAMILY , -- support for V6/V7/K7/A7 families only
               -----------------
               C_USE_STARTUP    => 1,
               -----------------
               C_SHARED_STARTUP => 1,
               C_SPI_MODE       => C_SPI_MODE
               -----------------
       )
  port map
       (
               SCK_O          => SCK, -- : in std_logic; -- input from the qspi_mode_0_module
               IO1_I_startup  => tmp, --io1_i_sync,     -- : in std_logic; -- input from the top level port list
               IO1_Int        => open,-- : out std_logic
               Bus2IP_Clk     => Bus2IP_Clk,
               reset2ip_reset => reset_invert,
               CFGCLK         => cfgclk,       -- FGCLK        , -- 1-bit output: Configuration main clock output
               CFGMCLK        => cfgmclk, -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
               EOS            => eos,  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
               PREQ           => preq, -- REQ          , -- 1-bit output: PROGRAM request to fabric output
               DI             => di_int,    -- output
               DO             => do_int,    -- 4-bit input
               DTS            => dts_int,   -- 4-bit input
               FCSBO          => SS(0), --fcsbo_int, -- 1-bit input
               FCSBTS         => SS_T, --fcsbts_int,-- 1-bit input
               CLK            => clk,   -- 1-bit input, SetReset
               GSR            => gsr,   -- 1-bit input, SetReset
               GTS            => gts,   -- 1-bit input
               KEYCLEARB      => keyclearb, --1-bit input
               USRCCLKTS      => SCK_T, --usrcclkts, -- SRCCLKTS     , -- 1-bit input
               USRDONEO       => usrdoneo, -- SRDONEO      , -- 1-bit input
               USRDONETS      => usrdonets, -- SRDONETS       -- 1-bit input
               PACK           => tmp_pack


       );

end architecture work;




-------------------------------------------------------------------------------
-- axi_quad_spi.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_quad_spi.vhd
-- Version:         v3.0
-- Description:     This is the top-level design file for the AXI Quad SPI core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--
-- History:
-- ~~~~~~
--  SK 19/01/11  -- created v1.00.a version
-- ^^^^^^
-- 1. Created first version of the core.
-- ~~~~~~
-- ~~~~~~
--  SK       12/16/12      -- v3.0
--  1. up reved to major version for 2013.1 Vivado release. No logic updates.
--  2. Updated the version of AXI LITE IPIF to v2.0 in X.Y format
--  3. updated the proc common version to proc_common_v4_0_2
--  4. No Logic Updates
-- ^^^^^^
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.conv_std_logic_vector;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_signed.all;
    use ieee.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
    use ieee.std_logic_unsigned.all;


library axi_lite_ipif_v3_0_4;
    use axi_lite_ipif_v3_0_4.axi_lite_ipif;
    use axi_lite_ipif_v3_0_4.ipif_pkg.all;
library lib_cdc_v1_0_2;
	use lib_cdc_v1_0_2.cdc_sync;
	

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
library unisim;
    use unisim.vcomponents.FDRE;
    use unisim.vcomponents.FDR;
-------------------------------------------------------------------------------
entity cross_clk_sync_fifo_1 is
     generic (
             C_FAMILY                     : string;
             Async_Clk                    : integer;
             C_FIFO_DEPTH                 : integer;
             C_DATA_WIDTH                 : integer;
             --C_AXI4_CLK_PS                : integer;
             --C_EXT_SPI_CLK_PS             : integer;
             C_S_AXI_DATA_WIDTH           : integer;
             C_NUM_TRANSFER_BITS          : integer;
             --C_AXI_SPI_CLK_EQ_DIFF        : integer;
             C_NUM_SS_BITS                : integer
     );
     port (
              EXT_SPI_CLK               : in std_logic;
              Bus2IP_Clk                : in std_logic;
              Soft_Reset_op             : in std_logic;
              Rst_cdc_to_spi       : in std_logic;
              ----------------------------
              SPISR_0_CMD_Error_cdc_from_spi : in std_logic;
              SPISR_0_CMD_Error_cdc_to_axi  : out std_logic;
              ----------------------------------------
              spisel_d1_reg_cdc_from_spi     : in std_logic;
              spisel_d1_reg_cdc_to_axi      : out std_logic;
              ----------------------------------------
              spisel_pulse_cdc_from_spi      : in std_logic;
              spisel_pulse_cdc_to_axi       : out std_logic;
              ----------------------------
              Mst_N_Slv_mode_cdc_from_spi    : in std_logic;
              Mst_N_Slv_mode_cdc_to_axi     : out std_logic;
              ----------------------------
              slave_MODF_strobe_cdc_from_spi : in std_logic;
              slave_MODF_strobe_cdc_to_axi  : out std_logic;
              ----------------------------
              modf_strobe_cdc_from_spi       : in std_logic;
              modf_strobe_cdc_to_axi        : out std_logic;
              ----------------------------
              Rx_FIFO_Full_cdc_from_axi      : in std_logic;
              Rx_FIFO_Full_cdc_to_spi       : out std_logic;
              ----------------------------
              reset_RcFIFO_ptr_cdc_from_axi  : in std_logic;
              reset_RcFIFO_ptr_cdc_to_spi   : out std_logic;
              ----------------------------
              Rx_FIFO_Empty_cdc_from_axi     : in std_logic;
              Rx_FIFO_Empty_cdc_to_spi      : out std_logic;
              ----------------------------
              Tx_FIFO_Empty_cdc_from_spi     : in std_logic;
              Tx_FIFO_Empty_cdc_to_axi      : out std_logic;
              ----------------------------
              Tx_FIFO_Empty_SPISR_cdc_from_spi : in std_logic;
              Tx_FIFO_Empty_SPISR_cdc_to_axi  : out std_logic;
              ----------------------------
              Tx_FIFO_Full_cdc_from_axi      : in std_logic;
              Tx_FIFO_Full_cdc_to_spi       : out std_logic;
              ----------------------------
              spiXfer_done_cdc_from_spi      : in std_logic;
              spiXfer_done_cdc_to_axi       : out std_logic;
              ----------------------------
              dtr_underrun_cdc_from_spi      : in std_logic;
              dtr_underrun_cdc_to_axi       : out std_logic;
              ----------------------------
              SPICR_0_LOOP_cdc_from_axi      : in std_logic;
              SPICR_0_LOOP_cdc_to_spi       : out std_logic;
              ----------------------------
              SPICR_1_SPE_cdc_from_axi       : in std_logic;
              SPICR_1_SPE_cdc_to_spi        : out std_logic;
              ----------------------------
              SPICR_2_MST_N_SLV_cdc_from_axi : in std_logic;
              SPICR_2_MST_N_SLV_cdc_to_spi  : out std_logic;
              ----------------------------
              SPICR_3_CPOL_cdc_from_axi      : in std_logic;
              SPICR_3_CPOL_cdc_to_spi       : out std_logic;
              ----------------------------
              SPICR_4_CPHA_cdc_from_axi      : in std_logic;
              SPICR_4_CPHA_cdc_to_spi       : out std_logic;
              ----------------------------
              SPICR_5_TXFIFO_cdc_from_axi    : in std_logic;
              SPICR_5_TXFIFO_cdc_to_spi     : out std_logic;
              ----------------------------
              SPICR_6_RXFIFO_RST_cdc_from_axi: in std_logic;
              SPICR_6_RXFIFO_RST_cdc_to_spi : out std_logic;
              ----------------------------
              SPICR_7_SS_cdc_from_axi        : in std_logic;
              SPICR_7_SS_cdc_to_spi         : out std_logic;
              ----------------------------
              SPICR_8_TR_INHIBIT_cdc_from_axi: in std_logic;
              SPICR_8_TR_INHIBIT_cdc_to_spi : out std_logic;
              ----------------------------
              SPICR_9_LSB_cdc_from_axi       : in std_logic;
              SPICR_9_LSB_cdc_to_spi        : out std_logic;
              ----------------------------
              SPICR_bits_7_8_cdc_from_axi    : in std_logic_vector(1 downto 0); -- in std_logic_vector
              SPICR_bits_7_8_cdc_to_spi     : out std_logic_vector(1 downto 0);
              ----------------------------
              SR_3_modf_cdc_from_axi         : in std_logic;
              SR_3_modf_cdc_to_spi          : out std_logic;
              ----------------------------
              SPISSR_cdc_from_axi            : in std_logic_vector(0 to (C_NUM_SS_BITS-1));
              SPISSR_cdc_to_spi             : out std_logic_vector(0 to (C_NUM_SS_BITS-1));
              ----------------------------
              spiXfer_done_cdc_to_axi_1     : out std_logic;
              ----------------------------
              drr_Overrun_int_cdc_from_spi   : in std_logic;
              drr_Overrun_int_cdc_to_axi    : out std_logic
);
end entity cross_clk_sync_fifo_1;
-------------------------------------------------------------------------------
architecture imp of cross_clk_sync_fifo_1 is
----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------


signal SPISR_0_CMD_Error_cdc_from_spi_d1: std_logic;
signal SPISR_0_CMD_Error_cdc_from_spi_d2: std_logic;

signal spisel_d1_reg_cdc_from_spi_d1    : std_logic;
signal spisel_d1_reg_cdc_from_spi_d2    : std_logic;

signal spisel_pulse_cdc_from_spi_d1     : std_logic;
signal spisel_pulse_cdc_from_spi_d2     : std_logic;
signal spisel_pulse_cdc_from_spi_d3     : std_logic;-- 2/21/2012
signal spisel_pulse_cdc_from_spi_d4     : std_logic;
signal Mst_N_Slv_mode_cdc_from_spi_d1   : std_logic;
signal Mst_N_Slv_mode_cdc_from_spi_d2   : std_logic;

signal slave_MODF_strobe_cdc_from_spi_d1: std_logic;
signal slave_MODF_strobe_cdc_from_spi_d2: std_logic;
signal slave_MODF_strobe_cdc_from_spi_d3: std_logic; -- 2/21/2012
signal Slave_MODF_strobe_cdc_from_spi_int_2 : std_logic;

signal modf_strobe_cdc_from_spi_d1      : std_logic;
signal modf_strobe_cdc_from_spi_d2      : std_logic;
signal modf_strobe_cdc_from_spi_d3      : std_logic;

signal SPICR_6_RXFIFO_RST_cdc_from_axi_d1 : std_logic;
signal SPICR_6_RXFIFO_RST_cdc_from_axi_d2 : std_logic;

signal Rx_FIFO_Full_cdc_from_axi_d1       : std_logic;
signal Rx_FIFO_Full_cdc_from_axi_d2       : std_logic;

signal reset_RcFIFO_ptr_cdc_from_axi_d1   : std_logic;
signal reset_RcFIFO_ptr_cdc_from_axi_d2   : std_logic;

signal Rx_FIFO_Empty_cdc_from_axi_d1      : std_logic;
signal Rx_FIFO_Empty_cdc_from_axi_d2      : std_logic;

signal Tx_FIFO_Empty_cdc_from_spi_d1      : std_logic;
signal Tx_FIFO_Empty_cdc_from_spi_d2      : std_logic;
-- signal Tx_FIFO_Empty_cdc_from_spi_d2      : std_logic_vector(2 downto 0);

signal Tx_FIFO_Full_cdc_from_axi_d1       : std_logic;
signal Tx_FIFO_Full_cdc_from_axi_d2       : std_logic;

signal modf_strobe_cdc_to_axi_d1         : std_logic;
signal modf_strobe_cdc_to_axi_d2         : std_logic;
signal modf_strobe_cdc_from_spi_int_2 : std_logic;

signal spiXfer_done_cdc_from_spi_d1       : std_logic;
signal spiXfer_done_cdc_from_spi_d2       : std_logic;

signal dtr_underrun_cdc_from_spi_d1       : std_logic;
signal dtr_underrun_cdc_from_spi_d2       : std_logic;

signal SPICR_0_LOOP_cdc_from_axi_d1       : std_logic;
signal SPICR_0_LOOP_cdc_from_axi_d2       : std_logic;

signal SPICR_1_SPE_cdc_from_axi_d1        : std_logic;
signal SPICR_1_SPE_cdc_from_axi_d2        : std_logic;

signal SPICR_2_MST_N_SLV_cdc_from_axi_d1  : std_logic;
signal SPICR_2_MST_N_SLV_cdc_from_axi_d2  : std_logic;

signal SPICR_3_CPOL_cdc_from_axi_d1       : std_logic;
signal SPICR_3_CPOL_cdc_from_axi_d2       : std_logic;

signal SPICR_4_CPHA_cdc_from_axi_d1       : std_logic;
signal SPICR_4_CPHA_cdc_from_axi_d2       : std_logic;

signal SPICR_5_TXFIFO_cdc_from_axi_d1     : std_logic;
signal SPICR_5_TXFIFO_cdc_from_axi_d2     : std_logic;

signal SPICR_7_SS_cdc_from_axi_d1         : std_logic;
signal SPICR_7_SS_cdc_from_axi_d2         : std_logic;

signal SPICR_8_TR_INHIBIT_cdc_from_axi_d1 : std_logic;
signal SPICR_8_TR_INHIBIT_cdc_from_axi_d2 : std_logic;

signal SPICR_9_LSB_cdc_from_axi_d1        : std_logic;
signal SPICR_9_LSB_cdc_from_axi_d2        : std_logic;

signal SPICR_bits_7_8_cdc_from_axi_d1     : std_logic_vector(1 downto 0);
signal SPICR_bits_7_8_cdc_from_axi_d2     : std_logic_vector(1 downto 0);

signal SR_3_modf_cdc_from_axi_d1          : std_logic;
signal SR_3_modf_cdc_from_axi_d2          : std_logic;

signal SPISSR_cdc_from_axi_d1             : std_logic_vector(0 to (C_NUM_SS_BITS-1));
signal SPISSR_cdc_from_axi_d2             : std_logic_vector(0 to (C_NUM_SS_BITS-1));

     signal rx_fifo_full_int, RST_RX_FF   : std_logic;
     signal rx_fifo_full_int_2 : std_logic;

     signal RST_spiXfer_done_FF        : std_logic;
     signal spiXfer_done_d1            : std_logic;
     signal spiXfer_done_d2, spiXfer_done_d3           : std_logic;
     signal spiXfer_done_cdc_from_spi_int_2 : std_logic;
     signal spiXfer_done_cdc_from_spi_int   : std_logic;

     signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d1 : std_logic;
     signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d2 : std_logic;

     signal reset_RX_FIFO_Rst_pulse : std_logic;
     signal SPICR_RX_FIFO_Rst_en_d1 : std_logic;
     signal SPICR_RX_FIFO_Rst_en    : std_logic;
     signal spisel_pulse_cdc_from_spi_int_2 : std_logic;
     signal SPISSR_cdc_from_axi_d1_and_reduce : std_logic;
signal drr_Overrun_int_cdc_from_spi_d1 : std_logic;
signal drr_Overrun_int_cdc_from_spi_d2 : std_logic;
signal drr_Overrun_int_cdc_from_spi_d3 : std_logic;
signal drr_Overrun_int_cdc_from_spi_int_2 : std_logic;
signal SPICR_RX_FIFO_Rst_en_d2 : std_logic;



-- signal SPISR_0_CMD_Error_cdc_from_spi_d1: std_logic;
-- signal SPISR_0_CMD_Error_cdc_from_spi_d2: std_logic;

-- signal spisel_d1_reg_cdc_from_spi_d1    : std_logic;
-- signal spisel_d1_reg_cdc_from_spi_d2    : std_logic;

-- signal spisel_pulse_cdc_from_spi_d1     : std_logic;
-- signal spisel_pulse_cdc_from_spi_d2     : std_logic;
-- signal spisel_pulse_cdc_from_spi_d3     : std_logic;-- 2/21/2012

-- signal Mst_N_Slv_mode_cdc_from_spi_d1   : std_logic;
-- signal Mst_N_Slv_mode_cdc_from_spi_d2   : std_logic;

-- signal slave_MODF_strobe_cdc_from_spi_d1: std_logic;
-- signal slave_MODF_strobe_cdc_from_spi_d2: std_logic;
-- signal slave_MODF_strobe_cdc_from_spi_d3: std_logic; -- 2/21/2012
-- signal Slave_MODF_strobe_cdc_from_spi_int_2 : std_logic;

-- signal modf_strobe_cdc_from_spi_d1      : std_logic;
-- signal modf_strobe_cdc_from_spi_d2      : std_logic;
-- signal modf_strobe_cdc_from_spi_d3      : std_logic;

-- signal SPICR_6_RXFIFO_RST_cdc_from_axi_d1 : std_logic;
-- signal SPICR_6_RXFIFO_RST_cdc_from_axi_d2 : std_logic;

-- signal Rx_FIFO_Full_cdc_from_axi_d1       : std_logic;
-- signal Rx_FIFO_Full_cdc_from_axi_d2       : std_logic;

-- signal reset_RcFIFO_ptr_cdc_from_axi_d1   : std_logic;
-- signal reset_RcFIFO_ptr_cdc_from_axi_d2   : std_logic;

-- signal Rx_FIFO_Empty_cdc_from_axi_d1      : std_logic;
-- signal Rx_FIFO_Empty_cdc_from_axi_d2      : std_logic;

-- signal Tx_FIFO_Empty_cdc_from_spi_d1      : std_logic;
-- signal Tx_FIFO_Empty_cdc_from_spi_d2      : std_logic;
-- -- signal Tx_FIFO_Empty_cdc_from_spi_d2      : std_logic_vector(2 downto 0);

-- signal Tx_FIFO_Full_cdc_from_axi_d1       : std_logic;
-- signal Tx_FIFO_Full_cdc_from_axi_d2       : std_logic;

-- signal modf_strobe_cdc_to_axi_d1         : std_logic;
-- signal modf_strobe_cdc_to_axi_d2         : std_logic;
-- signal modf_strobe_cdc_from_spi_int_2 : std_logic;

-- signal spiXfer_done_cdc_from_spi_d1       : std_logic;
-- signal spiXfer_done_cdc_from_spi_d2       : std_logic;

-- signal dtr_underrun_cdc_from_spi_d1       : std_logic;
-- signal dtr_underrun_cdc_from_spi_d2       : std_logic;

-- signal SPICR_0_LOOP_cdc_from_axi_d1       : std_logic;
-- signal SPICR_0_LOOP_cdc_from_axi_d2       : std_logic;

-- signal SPICR_1_SPE_cdc_from_axi_d1        : std_logic;
-- signal SPICR_1_SPE_cdc_from_axi_d2        : std_logic;

-- signal SPICR_2_MST_N_SLV_cdc_from_axi_d1  : std_logic;
-- signal SPICR_2_MST_N_SLV_cdc_from_axi_d2  : std_logic;

-- signal SPICR_3_CPOL_cdc_from_axi_d1       : std_logic;
-- signal SPICR_3_CPOL_cdc_from_axi_d2       : std_logic;

-- signal SPICR_4_CPHA_cdc_from_axi_d1       : std_logic;
-- signal SPICR_4_CPHA_cdc_from_axi_d2       : std_logic;

-- signal SPICR_5_TXFIFO_cdc_from_axi_d1     : std_logic;
-- signal SPICR_5_TXFIFO_cdc_from_axi_d2     : std_logic;

-- signal SPICR_7_SS_cdc_from_axi_d1         : std_logic;
-- signal SPICR_7_SS_cdc_from_axi_d2         : std_logic;

-- signal SPICR_8_TR_INHIBIT_cdc_from_axi_d1 : std_logic;
-- signal SPICR_8_TR_INHIBIT_cdc_from_axi_d2 : std_logic;

-- signal SPICR_9_LSB_cdc_from_axi_d1        : std_logic;
-- signal SPICR_9_LSB_cdc_from_axi_d2        : std_logic;

-- signal SPICR_bits_7_8_cdc_from_axi_d1     : std_logic_vector(1 downto 0);
-- signal SPICR_bits_7_8_cdc_from_axi_d2     : std_logic_vector(1 downto 0);

-- signal SR_3_modf_cdc_from_axi_d1          : std_logic;
-- signal SR_3_modf_cdc_from_axi_d2          : std_logic;

-- signal SPISSR_cdc_from_axi_d1             : std_logic_vector(0 to (C_NUM_SS_BITS-1));
-- signal SPISSR_cdc_from_axi_d2             : std_logic_vector(0 to (C_NUM_SS_BITS-1));

     -- signal rx_fifo_full_int, RST_RX_FF   : std_logic;
     -- signal rx_fifo_full_int_2 : std_logic;

     -- signal RST_spiXfer_done_FF        : std_logic;
     -- signal spiXfer_done_d1            : std_logic;
     -- signal spiXfer_done_d2, spiXfer_done_d3           : std_logic;
     -- signal spiXfer_done_cdc_from_spi_int_2 : std_logic;
     -- signal spiXfer_done_cdc_from_spi_int   : std_logic;

     -- signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d1 : std_logic;
     -- signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d2 : std_logic;

     -- signal reset_RX_FIFO_Rst_pulse : std_logic;
     -- signal SPICR_RX_FIFO_Rst_en_d1 : std_logic;
     -- signal SPICR_RX_FIFO_Rst_en    : std_logic;
     -- signal spisel_pulse_cdc_from_spi_int_2 : std_logic;
     -- signal SPISSR_cdc_from_axi_d1_and_reduce : std_logic;
-- signal drr_Overrun_int_cdc_from_spi_d1 : std_logic;
-- signal drr_Overrun_int_cdc_from_spi_d2 : std_logic;
-- signal drr_Overrun_int_cdc_from_spi_d3 : std_logic;
-- signal drr_Overrun_int_cdc_from_spi_int_2 : std_logic;

--------------------------
-- attribute ASYNC_REG : string;
-- attribute ASYNC_REG of CMD_ERR_S2AX_1_CDC          : label is "TRUE";
-- attribute ASYNC_REG of SPISEL_D1_REG_S2AX_1_CDC    : label is "TRUE";
-- attribute ASYNC_REG of SPISEL_PULSE_S2AX_1_CDC     : label is "TRUE";
-- attribute ASYNC_REG of MST_N_SLV_MODE_S2AX_1_CDC   : label is "TRUE";
-- -- attribute ASYNC_REG of SLAVE_MODF_STROBE_SYNC_SPI_2_AXI_1 : label is "TRUE";
-- attribute ASYNC_REG of RX_FIFO_EMPTY_AX2S_1_CDC    : label is "TRUE";
-- attribute ASYNC_REG of TX_FIFO_EMPTY_S2AX_1_CDC    : label is "TRUE";
-- attribute ASYNC_REG of TX_FIFO_FULL_AX2S_1_CDC     : label is "TRUE";
-- attribute ASYNC_REG of SPIXFER_DONE_S2AX_1_CDC     : label is "TRUE";
-- attribute ASYNC_REG of RX_FIFO_RST_AX2S_1_CDC      : label is "TRUE";  -- 3/25/2013
-- attribute ASYNC_REG of RX_FIFO_FULL_S2AX_1_CDC     : label is "TRUE";  -- 3/25/2013
-- attribute ASYNC_REG of SYNC_SPIXFER_DONE_S2AX_1_CDC: label is "TRUE";  -- 3/25/2013
-- attribute ASYNC_REG of DTR_UNDERRUN_S2AX_1_CDC     : label is "TRUE";  -- 3/25/2013

-- attribute ASYNC_REG of SPICR_0_LOOP_AX2S_1_CDC         : label is "TRUE";
-- attribute ASYNC_REG of SPICR_1_SPE_AX2S_1_CDC          : label is "TRUE";
-- attribute ASYNC_REG of SPICR_2_MST_N_SLV_AX2S_1_CDC    : label is "TRUE";
-- attribute ASYNC_REG of SPICR_3_CPOL_AX2S_1_CDC         : label is "TRUE";
-- attribute ASYNC_REG of SPICR_4_CPHA_AX2S_1_CDC         : label is "TRUE";
-- attribute ASYNC_REG of SPICR_5_TXFIFO_AX2S_1_CDC       : label is "TRUE";
-- attribute ASYNC_REG of SPICR_6_RXFIFO_RST_AX2S_1_CDC   : label is "TRUE";
-- attribute ASYNC_REG of SPICR_7_SS_AX2S_1_CDC           : label is "TRUE";
-- attribute ASYNC_REG of SPICR_8_TR_INHIBIT_AX2S_1_CDC   : label is "TRUE";
-- attribute ASYNC_REG of SPICR_9_LSB_AX2S_1_CDC          : label is "TRUE";
-- attribute ASYNC_REG of SR_3_MODF_AX2S_1_CDC            : label is "TRUE";
-- attribute ASYNC_REG of SLV_MODF_STRB_S2AX_1_CDC        : label is "TRUE";
-- attribute ASYNC_REG of MODF_STROBE_S2AX_1_CDC          : label is "TRUE";
-- attribute ASYNC_REG of TX_EMPT_4_SPISR_S2AX_1_CDC      : label is "TRUE";
-- attribute ASYNC_REG of DRR_OVERRUN_S2AX_1_CDC          : label is "TRUE"; -- 3/25/2013

attribute KEEP : string;
attribute KEEP of SPISR_0_CMD_Error_cdc_from_spi_d2: signal is "TRUE";
attribute KEEP of spisel_d1_reg_cdc_from_spi_d2: signal is "TRUE";
attribute KEEP of spisel_pulse_cdc_from_spi_d2: signal is "TRUE";
attribute KEEP of spisel_pulse_cdc_from_spi_d1: signal is "TRUE";
attribute KEEP of Mst_N_Slv_mode_cdc_from_spi_d2: signal is "TRUE";
attribute KEEP of Slave_MODF_strobe_cdc_from_spi_d2: signal is "TRUE";
attribute KEEP of Slave_MODF_strobe_cdc_from_spi_d1: signal is "TRUE";
attribute KEEP of modf_strobe_cdc_from_spi_d2      : signal is "TRUE";
attribute KEEP of modf_strobe_cdc_from_spi_d1      : signal is "TRUE";

constant LOGIC_CHANGE : integer range 0 to 1 := 1;
constant MTBF_STAGES_AXI2S : integer range 0 to 6 := 3 ;
constant MTBF_STAGES_S2AXI : integer range 0 to 6 := 4 ;
-----
begin
-----
SPISSR_cdc_from_axi_d1_and_reduce <= and_reduce(SPISSR_cdc_from_axi_d2);

LOGIC_GENERATION_FDR : if (Async_Clk = 0) generate
--==============================================================================
     CMD_ERR_S2AX_1_CDC: component FDR
                   generic map(INIT => '0' -- added on 16th Feb
                   )port map (
                              Q  => SPISR_0_CMD_Error_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => SPISR_0_CMD_Error_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     CMD_ERR_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPISR_0_CMD_Error_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => SPISR_0_CMD_Error_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     SPISR_0_CMD_Error_cdc_to_axi <= SPISR_0_CMD_Error_cdc_from_spi_d2;
     -----------------------------------------------------------
--==============================================================================
     SPISEL_D1_REG_S2AX_1_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_d1_reg_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => spisel_d1_reg_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     SPISEL_D1_REG_S2AX_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_d1_reg_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => spisel_d1_reg_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );

     spisel_d1_reg_cdc_to_axi <= spisel_d1_reg_cdc_from_spi_d2;
     -------------------------------------------------
--==============================================================================

     SPISEL_PULSE_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_cdc_to_spi = '1') then
                        spisel_pulse_cdc_from_spi_int_2 <= '0';
                else
                        spisel_pulse_cdc_from_spi_int_2 <= --((not SPISSR_cdc_from_axi_d1_and_reduce) and
                                                      spisel_pulse_cdc_from_spi xor
                                                      spisel_pulse_cdc_from_spi_int_2;
                end if;
          end if;
     end process SPISEL_PULSE_STRETCH_1;

     SPISEL_PULSE_S2AX_1_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_pulse_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_int_2, -- spisel_pulse_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     SPISEL_PULSE_S2AX_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_pulse_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     SPISEL_PULSE_S2AX_3: component FDR    -- 2/21/2012
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_pulse_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );

     -- spisel_pulse_cdc_to_axi <= spisel_pulse_cdc_from_spi_d2 xor spisel_pulse_cdc_from_spi_d1;
     spisel_pulse_cdc_to_axi <= spisel_pulse_cdc_from_spi_d3 xor spisel_pulse_cdc_from_spi_d2; -- 2/21/2012
     -----------------------------------------------
--==============================================================================
     MST_N_SLV_MODE_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Mst_N_Slv_mode_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => Mst_N_Slv_mode_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     MST_N_SLV_MODE_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Mst_N_Slv_mode_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => Mst_N_Slv_mode_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );

     Mst_N_Slv_mode_cdc_to_axi <= Mst_N_Slv_mode_cdc_from_spi_d2;
     ---------------------------------------------------
--==============================================================================

    SLAVE_MODF_STROBE_STRETCH_1: process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
               if(Rst_cdc_to_spi = '1') then
                       Slave_MODF_strobe_cdc_from_spi_int_2 <= '0';
               else
                       Slave_MODF_strobe_cdc_from_spi_int_2 <= Slave_MODF_strobe_cdc_from_spi xor
                                                          Slave_MODF_strobe_cdc_from_spi_int_2;
               end if;
         end if;
    end process SLAVE_MODF_STROBE_STRETCH_1;
     
    SLV_MODF_STRB_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Slave_MODF_strobe_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => Slave_MODF_strobe_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
    SLV_MODF_STRB_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Slave_MODF_strobe_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => Slave_MODF_strobe_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
    SLV_MODF_STRB_S2AX_3: component FDR -- 2/21/2012
                   generic map(INIT => '0'
                   )port map (
                              Q  => Slave_MODF_strobe_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => Slave_MODF_strobe_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
    -- Slave_MODF_strobe_cdc_to_axi <= Slave_MODF_strobe_cdc_from_spi_d2 xor Slave_MODF_strobe_cdc_from_spi_d1; --spiXfer_done_cdc_from_spi_d2;
    Slave_MODF_strobe_cdc_to_axi <= Slave_MODF_strobe_cdc_from_spi_d3 xor Slave_MODF_strobe_cdc_from_spi_d2;-- 2/21/2012

--==============================================================================

    MODF_STROBE_STRETCH_1: process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
               if(Rst_cdc_to_spi = '1') then
                       modf_strobe_cdc_from_spi_int_2 <= '0';
               else
                       modf_strobe_cdc_from_spi_int_2 <= modf_strobe_cdc_from_spi xor
                                                     modf_strobe_cdc_from_spi_int_2;
               end if;
         end if;
    end process MODF_STROBE_STRETCH_1;
    
    MODF_STROBE_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => modf_strobe_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => modf_strobe_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
    MODF_STROBE_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => modf_strobe_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => modf_strobe_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
    MODF_STROBE_S2AX_3: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => modf_strobe_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => modf_strobe_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
    -- modf_strobe_cdc_to_axi <= modf_strobe_cdc_from_spi_d2 xor modf_strobe_cdc_from_spi_d1; --spiXfer_done_cdc_from_spi_d2;
    modf_strobe_cdc_to_axi <= modf_strobe_cdc_from_spi_d3 xor modf_strobe_cdc_from_spi_d2; -- 2/21/2012
    -----------------------------------------------
--==============================================================================

     RX_FIFO_EMPTY_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Rx_FIFO_Empty_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK, -- Bus2IP_Clk,
                              D  => Rx_FIFO_Empty_cdc_from_axi,
                              R  => Rst_cdc_to_spi   -- Soft_Reset_op
                            );
     RX_FIFO_EMPTY_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Rx_FIFO_Empty_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK, -- Bus2IP_Clk,
                              D  => Rx_FIFO_Empty_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi   -- Soft_Reset_op
                            );
     Rx_FIFO_Empty_cdc_to_spi <= Rx_FIFO_Empty_cdc_from_axi_d2;
     -------------------------------------------------
--==============================================================================

     TX_FIFO_EMPTY_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Tx_FIFO_Empty_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => Tx_FIFO_Empty_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     TX_FIFO_EMPTY_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Tx_FIFO_Empty_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => Tx_FIFO_Empty_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     Tx_FIFO_Empty_cdc_to_axi <= Tx_FIFO_Empty_cdc_from_spi_d2;
     -------------------------------------------------
--==============================================================================

     TX_EMPT_4_SPISR_S2AX_1_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => Tx_FIFO_Empty_SPISR_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => Tx_FIFO_Empty_SPISR_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     TX_EMPT_4_SPISR_S2AX_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => Tx_FIFO_Empty_SPISR_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => Tx_FIFO_Empty_SPISR_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
      Tx_FIFO_Empty_SPISR_cdc_to_axi <= Tx_FIFO_Empty_SPISR_cdc_from_spi_d2;
--==============================================================================

     TX_FIFO_FULL_AX2S_1_CDC: component FDR
                    generic map(INIT => '0'
                   )port map (
                              Q  => Tx_FIFO_Full_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK, -- Bus2IP_Clk,
                              D  => Tx_FIFO_Full_cdc_from_axi,
                              R  => Rst_cdc_to_spi   -- Soft_Reset_op
                            );
     TX_FIFO_FULL_AX2S_2: component FDR
                    generic map(INIT => '0'
                   )port map (
                              Q  => Tx_FIFO_Full_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK, -- Bus2IP_Clk,
                              D  => Tx_FIFO_Full_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi   -- Soft_Reset_op
                            );
     Tx_FIFO_Full_cdc_to_spi <= Tx_FIFO_Full_cdc_from_axi_d2;
     -----------------------------------------------
--==============================================================================
     SPIXFER_DONE_S2AX_1_CDC: component FDR
                    generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     SPIXFER_DONE_S2AX_2: component FDR
                    generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     spiXfer_done_cdc_to_axi <= spiXfer_done_cdc_from_spi_d2;
     -----------------------------------------------
     SPICR_RX_FIFO_Rst_en <= reset_RcFIFO_ptr_cdc_from_axi xor SPICR_RX_FIFO_Rst_en_d1;

     SPICR_RX_FIFO_RST_REG_SPI_DOMAIN_P:process(Bus2IP_Clk)is
     begin
     -----
          if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
              if(Soft_Reset_op = '1') then --  or reset_RX_FIFO_Rst_pulse = '1')then
                  SPICR_RX_FIFO_Rst_en_d1 <= '0';
              else
                  SPICR_RX_FIFO_Rst_en_d1 <= SPICR_RX_FIFO_Rst_en;
              end if;
          end if;
     end process SPICR_RX_FIFO_RST_REG_SPI_DOMAIN_P;
     -------------------------------------------------
     --reset_RcFIFO_ptr_cdc_to_spi <= reset_RcFIFO_ptr_cdc_from_axi_d2;
     RX_FIFO_RST_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => reset_RcFIFO_ptr_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_RX_FIFO_Rst_en_d1,
                              R  => Rst_cdc_to_spi
                            );
     RX_FIFO_RST_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => reset_RcFIFO_ptr_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => reset_RcFIFO_ptr_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     reset_RcFIFO_ptr_cdc_to_spi <= reset_RcFIFO_ptr_cdc_from_axi_d1 xor
                                reset_RcFIFO_ptr_cdc_from_axi_d2;
     --reset_RcFIFO_ptr_cdc_to_spi <= reset_RcFIFO_ptr_cdc_from_axi_d2;
     -----------------------------------------------------------

     ------------------------------------------
     RX_FIFO_FULL_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Rx_FIFO_Full_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => Rx_FIFO_Full_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     RX_FIFO_FULL_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Rx_FIFO_Full_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => Rx_FIFO_Full_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     Rx_FIFO_Full_cdc_to_spi <= Rx_FIFO_Full_cdc_from_axi_d2;

     ------------------------------------------
     SPI_XFER_DONE_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_cdc_to_spi = '1') then
                        spiXfer_done_cdc_from_spi_int_2 <= '0';
                else
                        spiXfer_done_cdc_from_spi_int_2 <= spiXfer_done_cdc_from_spi xor
                                                      spiXfer_done_cdc_from_spi_int_2;
                end if;
          end if;
     end process SPI_XFER_DONE_STRETCH_1;

     SYNC_SPIXFER_DONE_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_d1,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
     SYNC_SPIXFER_DONE_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_d2,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_d1,
                              R  => Soft_Reset_op
                            );
     SYNC_SPIXFER_DONE_S2AX_3: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_d3,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_d2,
                              R  => Soft_Reset_op
                            );
     spiXfer_done_cdc_to_axi_1 <= spiXfer_done_d2 xor spiXfer_done_d3;
     -------------------------------------------------------------------------
    DTR_UNDERRUN_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => dtr_underrun_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => dtr_underrun_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     DTR_UNDERRUN_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => dtr_underrun_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => dtr_underrun_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     dtr_underrun_cdc_to_axi <= dtr_underrun_cdc_from_spi_d2;
     -------------------------------------------------
     SPICR_0_LOOP_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_0_LOOP_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_0_LOOP_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_0_LOOP_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_0_LOOP_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_0_LOOP_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_0_LOOP_cdc_to_spi <= SPICR_0_LOOP_cdc_from_axi_d2;
     -----------------------------------------------

     SPICR_1_SPE_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_1_SPE_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_1_SPE_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_1_SPE_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_1_SPE_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_1_SPE_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_1_SPE_cdc_to_spi <= SPICR_1_SPE_cdc_from_axi_d2;
     ---------------------------------------------

     SPICR_2_MST_N_SLV_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_2_MST_N_SLV_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_2_MST_N_SLV_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_2_MST_N_SLV_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_2_MST_N_SLV_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_2_MST_N_SLV_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_2_MST_N_SLV_cdc_to_spi <= SPICR_2_MST_N_SLV_cdc_from_axi_d2;
     ---------------------------------------------------------

     SPICR_3_CPOL_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_3_CPOL_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_3_CPOL_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_3_CPOL_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_3_CPOL_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_3_CPOL_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_3_CPOL_cdc_to_spi <= SPICR_3_CPOL_cdc_from_axi_d2;
     -----------------------------------------------

     SPICR_4_CPHA_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_4_CPHA_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_4_CPHA_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_4_CPHA_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_4_CPHA_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_4_CPHA_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_4_CPHA_cdc_to_spi <= SPICR_4_CPHA_cdc_from_axi_d2;
     -----------------------------------------------

     SPICR_5_TXFIFO_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_5_TXFIFO_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_5_TXFIFO_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_5_TXFIFO_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_5_TXFIFO_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_5_TXFIFO_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_5_TXFIFO_cdc_to_spi <= SPICR_5_TXFIFO_cdc_from_axi_d2;
     ---------------------------------------------------

     SPICR_6_RXFIFO_RST_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_6_RXFIFO_RST_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_6_RXFIFO_RST_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_6_RXFIFO_RST_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_6_RXFIFO_RST_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_6_RXFIFO_RST_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_6_RXFIFO_RST_cdc_to_spi <= SPICR_6_RXFIFO_RST_cdc_from_axi_d2;
     -----------------------------------------------------------

     SPICR_7_SS_AX2S_1_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_7_SS_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_7_SS_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_7_SS_AX2S_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_7_SS_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_7_SS_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_7_SS_cdc_to_spi <= SPICR_7_SS_cdc_from_axi_d2;
     -------------------------------------------

     SPICR_8_TR_INHIBIT_AX2S_1_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_8_TR_INHIBIT_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_8_TR_INHIBIT_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_8_TR_INHIBIT_AX2S_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_8_TR_INHIBIT_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_8_TR_INHIBIT_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_8_TR_INHIBIT_cdc_to_spi <= SPICR_8_TR_INHIBIT_cdc_from_axi_d2;
     -----------------------------------------------------------

     SPICR_9_LSB_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_9_LSB_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_9_LSB_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_9_LSB_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_9_LSB_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_9_LSB_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SPICR_9_LSB_cdc_to_spi <= SPICR_9_LSB_cdc_from_axi_d2;
     ---------------------------------------------

     SPICR_BITS_7_8_SYNC_GEN: for i in 1 downto 0 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of SPICR_BITS_7_8_AX2S_1_CDC : label is "TRUE";
     begin
     -----
     SPICR_BITS_7_8_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_bits_7_8_cdc_from_axi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => SPICR_bits_7_8_cdc_from_axi(i),
                              R  => Rst_cdc_to_spi
                            );
     SPICR_BITS_7_8_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_bits_7_8_cdc_from_axi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => SPICR_bits_7_8_cdc_from_axi_d1(i),
                              R  => Rst_cdc_to_spi
                            );
     end generate SPICR_BITS_7_8_SYNC_GEN;
     -------------------------------------
     SPICR_bits_7_8_cdc_to_spi <= SPICR_bits_7_8_cdc_from_axi_d2;
     ---------------------------------------------------

     SR_3_MODF_AX2S_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SR_3_modf_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SR_3_modf_cdc_from_axi,
                              R  => Rst_cdc_to_spi
                            );
     SR_3_MODF_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SR_3_modf_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SR_3_modf_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     SR_3_modf_cdc_to_spi <= SR_3_modf_cdc_from_axi_d2;
     -----------------------------------------

     SPISSR_SYNC_GEN: for i in 0 to C_NUM_SS_BITS-1 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of SPISSR_AX2S_1_CDC : label is "TRUE";
     -----
     begin
     -----
     SPISSR_AX2S_1_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPISSR_cdc_from_axi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => SPISSR_cdc_from_axi(i),
                              R  => Rst_cdc_to_spi
                            );
     SPISSR_SYNC_AXI_2_SPI_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPISSR_cdc_from_axi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => SPISSR_cdc_from_axi_d1(i),
                              R  => Rst_cdc_to_spi
                            );
     end generate SPISSR_SYNC_GEN;

     SPISSR_cdc_to_spi <= SPISSR_cdc_from_axi_d2;
     -----------------------------------

     DRR_OVERRUN_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_cdc_to_spi = '1') then
                        drr_Overrun_int_cdc_from_spi_int_2 <= '0';
                else
                        drr_Overrun_int_cdc_from_spi_int_2 <= drr_Overrun_int_cdc_from_spi xor
                                                      drr_Overrun_int_cdc_from_spi_int_2;
                end if;
          end if;
     end process DRR_OVERRUN_STRETCH_1;

     DRR_OVERRUN_S2AX_1_CDC: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => drr_Overrun_int_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => drr_Overrun_int_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
     DRR_OVERRUN_S2AX_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => drr_Overrun_int_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => drr_Overrun_int_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     DRR_OVERRUN_S2AX_3: component FDR -- 2/21/2012
                   generic map(INIT => '0'
                   )port map (
                              Q  => drr_Overrun_int_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => drr_Overrun_int_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
    --drr_Overrun_int_cdc_to_axi <= drr_Overrun_int_cdc_from_spi_d2 xor drr_Overrun_int_cdc_from_spi_d1;
    drr_Overrun_int_cdc_to_axi <= drr_Overrun_int_cdc_from_spi_d3 xor drr_Overrun_int_cdc_from_spi_d2; -- 2/21/2012
	
 end generate LOGIC_GENERATION_FDR ;

 
 LOGIC_GENERATION_CDC : if Async_Clk = 1 generate
--==============================================================================

CMD_ERR_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPISR_0_CMD_Error_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => SPISR_0_CMD_Error_cdc_to_axi
    ); 
--==============================================================================

     
SPISEL_D1_REG_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => spisel_d1_reg_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => spisel_d1_reg_cdc_to_axi
    ); 

--==============================================================================

SPISEL_PULSE_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_cdc_to_spi = '1') then
                        spisel_pulse_cdc_from_spi_int_2 <= '0';
                else
                        spisel_pulse_cdc_from_spi_int_2 <= --((not SPISSR_cdc_from_axi_d1_and_reduce) and
                                                      spisel_pulse_cdc_from_spi xor
                                                      spisel_pulse_cdc_from_spi_int_2;
                end if;
          end if;
     end process SPISEL_PULSE_STRETCH_1;

     SPISEL_PULSE_S2AX_1_CDC: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_pulse_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_int_2, -- spisel_pulse_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     SPISEL_PULSE_S2AX_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_pulse_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     SPISEL_PULSE_S2AX_3: component FDR    -- 2/21/2012
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_pulse_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
    SPISEL_PULSE_S2AX_4: component FDR    -- 2/21/2012
                   generic map(INIT => '1'
                   )port map (
                              Q  => spisel_pulse_cdc_from_spi_d4,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_d3,
                              R  => Soft_Reset_op
                            );                        

     -- spisel_pulse_cdc_to_axi <= spisel_pulse_cdc_from_spi_d2 xor spisel_pulse_cdc_from_spi_d1;
     spisel_pulse_cdc_to_axi <= spisel_pulse_cdc_from_spi_d3 xor spisel_pulse_cdc_from_spi_d4;
--==============================================================================
    
MST_N_SLV_MODE_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => Mst_N_Slv_mode_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => Mst_N_Slv_mode_cdc_to_axi
    ); 
--==============================================================================
SLAVE_MODF_STROBE_STRETCH_1_CDC: process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
               if(Rst_cdc_to_spi = '1') then
                       Slave_MODF_strobe_cdc_from_spi_int_2 <= '0';
                       --Slave_MODF_strobe_cdc_from_spi_d1    <= '0';
               else
                       Slave_MODF_strobe_cdc_from_spi_int_2 <= Slave_MODF_strobe_cdc_from_spi xor
                                                          Slave_MODF_strobe_cdc_from_spi_int_2;
                       --Slave_MODF_strobe_cdc_from_spi_d1    <= Slave_MODF_strobe_cdc_from_spi_int_2;
               end if;
         end if;
    end process SLAVE_MODF_STROBE_STRETCH_1_CDC;
    
    SLV_MODF_STRB_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => Slave_MODF_strobe_cdc_from_spi_int_2,--Slave_MODF_strobe_cdc_from_spi_d1 ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out            => Slave_MODF_strobe_cdc_from_spi_d2
    ); 
	
	SLAVE_MODF_STROBE_STRETCH_1: process(Bus2IP_Clk)is
    begin
         if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
               
                       Slave_MODF_strobe_cdc_from_spi_d3 <= Slave_MODF_strobe_cdc_from_spi_d2 ;
               
         end if;
    end process SLAVE_MODF_STROBE_STRETCH_1;
	
    Slave_MODF_strobe_cdc_to_axi <= Slave_MODF_strobe_cdc_from_spi_d3 xor Slave_MODF_strobe_cdc_from_spi_d2;

--==============================================================================
MODF_STROBE_STRETCH_1_CDC: process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
               if(Rst_cdc_to_spi = '1') then
                       modf_strobe_cdc_from_spi_int_2 <= '0';
                      -- modf_strobe_cdc_from_spi_d1    <= '0';
               else
                       modf_strobe_cdc_from_spi_int_2 <= modf_strobe_cdc_from_spi xor
                                                     modf_strobe_cdc_from_spi_int_2;
                      -- modf_strobe_cdc_from_spi_d1    <= modf_strobe_cdc_from_spi_int_2;
               end if;
         end if;
    end process MODF_STROBE_STRETCH_1_CDC;

    MODF_STROBE_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => modf_strobe_cdc_from_spi_int_2,--modf_strobe_cdc_from_spi_d1 ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out            => modf_strobe_cdc_from_spi_d2
    ); 
	MODF_STROBE_STRETCH_1: process(Bus2IP_Clk)is
    begin
         if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
               
                       modf_strobe_cdc_from_spi_d3 <= modf_strobe_cdc_from_spi_d2;
               
         end if;
    end process MODF_STROBE_STRETCH_1;
    modf_strobe_cdc_to_axi <= modf_strobe_cdc_from_spi_d3 xor modf_strobe_cdc_from_spi_d2;

--==============================================================================

   

    RX_FIFO_EMPTY_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => Rx_FIFO_Empty_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => Rx_FIFO_Empty_cdc_to_spi
    ); 
--==============================================================================
    

    TX_FIFO_EMPTY_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => Tx_FIFO_Empty_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => Tx_FIFO_Empty_cdc_to_axi
    ); 
--==============================================================================

     TX_EMPT_4_SPISR_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => Tx_FIFO_Empty_SPISR_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => Tx_FIFO_Empty_SPISR_cdc_to_axi
    ); 
--==============================================================================
   

    TX_FIFO_FULL_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => Tx_FIFO_Full_cdc_from_axi ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => Tx_FIFO_Full_cdc_to_spi
    ); 
--==============================================================================
    

SPIXFER_DONE_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => spiXfer_done_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
		prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => spiXfer_done_cdc_to_axi
    ); 
--==============================================================================
    RX_FIFO_FULL_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => Rx_FIFO_Full_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => Rx_FIFO_Full_cdc_to_spi
    ); 
--==============================================================================

SPI_XFER_DONE_STRETCH_1_CDC: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_cdc_to_spi = '1') then
                        spiXfer_done_cdc_from_spi_int_2 <= '0';
                      --  spiXfer_done_d1            <= '0';
                else
                        spiXfer_done_cdc_from_spi_int_2 <= spiXfer_done_cdc_from_spi xor
                                                      spiXfer_done_cdc_from_spi_int_2;
                       -- spiXfer_done_d1            <= spiXfer_done_cdc_from_spi_int_2;
                end if;
          end if;
     end process SPI_XFER_DONE_STRETCH_1_CDC;
     
    SYNC_SPIXFER_DONE_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => spiXfer_done_cdc_from_spi_int_2,--spiXfer_done_cdc_from_spi_int_2,--spiXfer_done_d1 ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out            => spiXfer_done_d2
    ); 

SPI_XFER_DONE_STRETCH_1: process(Bus2IP_Clk)is
     begin
          if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
                
                        spiXfer_done_d3 <= spiXfer_done_d2;
                
          end if;
     end process SPI_XFER_DONE_STRETCH_1;
	 
    spiXfer_done_cdc_to_axi_1 <= spiXfer_done_d2 xor spiXfer_done_d3;
    
   --==============================================================================
   
    DTR_UNDERRUN_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => dtr_underrun_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => dtr_underrun_cdc_to_axi
    ); 
   --==============================================================================
    
    SPICR_0_LOOP_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 ,  -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => SPICR_0_LOOP_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
		prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_0_LOOP_cdc_to_spi
    ); 
    --==============================================================================
     
    SPICR_1_SPE_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => SPICR_1_SPE_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
		prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_1_SPE_cdc_to_spi
    ); 
    --==============================================================================

     
    SPICR_2_MST_N_SLV_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_2_MST_N_SLV_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
        prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_2_MST_N_SLV_cdc_to_spi
    ); 
    --==============================================================================
     
    SPICR_3_CPOL_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_3_CPOL_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_3_CPOL_cdc_to_spi
    ); 
     --==============================================================================
     
    SPICR_4_CPHA_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_4_CPHA_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_4_CPHA_cdc_to_spi
    ); 
     --==============================================================================
        
    SPICR_5_TXFIFO_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk  , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_5_TXFIFO_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
		prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_5_TXFIFO_cdc_to_spi
    ); 
  --==============================================================================
          
    SPICR_6_RXFIFO_RST_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_6_RXFIFO_RST_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_6_RXFIFO_RST_cdc_to_spi
    ); 
   --==============================================================================
     
    SPICR_7_SS_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op  ,
        prmry_in             => SPICR_7_SS_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_7_SS_cdc_to_spi
    ); 
    --==============================================================================
     
    SPICR_8_TR_INHIBIT_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op  ,
        prmry_in             => SPICR_8_TR_INHIBIT_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_8_TR_INHIBIT_cdc_to_spi
    ); 
   --==============================================================================
     
    SPICR_9_LSB_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op  ,
        prmry_in             => SPICR_9_LSB_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_9_LSB_cdc_to_spi
    ); 
   --==============================================================================
    
    SR_3_MODF_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SR_3_modf_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SR_3_modf_cdc_to_spi
    ); 
    --==============================================================================
     
    SPISSR_SYNC_GEN_CDC: for i in 0 to C_NUM_SS_BITS-1 generate
         attribute ASYNC_REG : string;
         attribute ASYNC_REG of SPISSR_AX2S_1_CDC : label is "TRUE";
         -----
     begin
    SPISSR_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk,
        prmry_resetn         => Soft_Reset_op,
        prmry_in             => SPISSR_cdc_from_axi(i),
        scndry_aclk          => EXT_SPI_CLK,
        prmry_vect_in        => (others => '0' ),		
        scndry_resetn        => Rst_cdc_to_spi,
        scndry_out           => SPISSR_cdc_from_axi_d2(i)
    );
     end generate SPISSR_SYNC_GEN_CDC;
     
     SPISSR_cdc_to_spi <= SPISSR_cdc_from_axi_d2;
    
     -----------------------------------
     DRR_OVERRUN_STRETCH_1_CDC: process(EXT_SPI_CLK)is
          begin
               if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                     if(Rst_cdc_to_spi = '1') then
                             drr_Overrun_int_cdc_from_spi_int_2 <= '0';
                            -- drr_Overrun_int_cdc_from_spi_d1    <= '0';
                     else
                             drr_Overrun_int_cdc_from_spi_int_2 <= drr_Overrun_int_cdc_from_spi xor
                                                      drr_Overrun_int_cdc_from_spi_int_2;
                             --drr_Overrun_int_cdc_from_spi_d1    <= drr_Overrun_int_cdc_from_spi_int_2;
                     end if;
               end if;
     end process DRR_OVERRUN_STRETCH_1_CDC;
     
	 DRR_OVERRUN_S2AX_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_cdc_to_spi ,
        prmry_in             => drr_Overrun_int_cdc_from_spi_int_2,--drr_Overrun_int_cdc_from_spi_d1 ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out            => drr_Overrun_int_cdc_from_spi_d2
    ); 
	
	DRR_OVERRUN_STRETCH_1: process(Bus2IP_Clk)is
          begin
               if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
                     
                             drr_Overrun_int_cdc_from_spi_d3 <= drr_Overrun_int_cdc_from_spi_d2;
                    
               end if;
     end process DRR_OVERRUN_STRETCH_1;
    drr_Overrun_int_cdc_to_axi <= drr_Overrun_int_cdc_from_spi_d3 xor drr_Overrun_int_cdc_from_spi_d2;
    -------------------------------------------------------------
    
    
SPICR_RX_FIFO_Rst_en <= reset_RcFIFO_ptr_cdc_from_axi xor SPICR_RX_FIFO_Rst_en_d1;

SPICR_RX_FIFO_RST_REG_SPI_DOMAIN_P_CDC:process(Bus2IP_Clk)is
     begin
     -----
          if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
              if(Soft_Reset_op = '1') then --  or reset_RX_FIFO_Rst_pulse = '1')then
                  SPICR_RX_FIFO_Rst_en_d1 <= '0';
              else
                  SPICR_RX_FIFO_Rst_en_d1 <= SPICR_RX_FIFO_Rst_en;
              end if;
          end if;
     end process SPICR_RX_FIFO_RST_REG_SPI_DOMAIN_P_CDC;
	 
	     -------------------------------------------------
RX_FIFO_RST_AX2S_1: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => 1      --AXI to SPI as already 2 stages included
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_RX_FIFO_Rst_en_d1 ,
        scndry_aclk          => EXT_SPI_CLK ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_cdc_to_spi ,
        scndry_out           => SPICR_RX_FIFO_Rst_en_d2
    ); 
     --reset_RcFIFO_ptr_cdc_to_spi <= reset_RcFIFO_ptr_cdc_from_axi_d2;
          
     RX_FIFO_RST_AX2S_1_CDC_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => reset_RcFIFO_ptr_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_RX_FIFO_Rst_en_d2,
                              R  => Rst_cdc_to_spi
                            );
     RX_FIFO_RST_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => reset_RcFIFO_ptr_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => reset_RcFIFO_ptr_cdc_from_axi_d1,
                              R  => Rst_cdc_to_spi
                            );
     reset_RcFIFO_ptr_cdc_to_spi <= reset_RcFIFO_ptr_cdc_from_axi_d1 xor
                                reset_RcFIFO_ptr_cdc_from_axi_d2;
     --reset_RcFIFO_ptr_cdc_to_spi <= reset_RcFIFO_ptr_cdc_from_axi_d2;
     
     ----------------------------------------------------------------------------------
     
   
	 
SPICR_BITS_7_8_SYNC_GEN_CDC: for i in 1 downto 0 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of SPICR_BITS_7_8_AX2S_1_CDC : label is "TRUE";
     begin
     -----
     SPICR_BITS_7_8_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
         generic map (
             C_CDC_TYPE                  => 1 , -- 1 is level synch
             C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
             C_SINGLE_BIT                => 1 , 
             C_FLOP_INPUT                => 0 ,
             C_VECTOR_WIDTH              => 1 ,
             C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
     		)
     
         port map (
             prmry_aclk           => Bus2IP_Clk , 
             prmry_resetn         => Soft_Reset_op ,
             prmry_in             => SPICR_bits_7_8_cdc_from_axi(i) ,
             scndry_aclk          => EXT_SPI_CLK ,
	     prmry_vect_in        => (others => '0' ),
             scndry_resetn        => Rst_cdc_to_spi ,
             scndry_out           => SPICR_bits_7_8_cdc_from_axi_d2(i)
    ); 
     end generate SPICR_BITS_7_8_SYNC_GEN_CDC;
     -------------------------------------
     SPICR_bits_7_8_cdc_to_spi <= SPICR_bits_7_8_cdc_from_axi_d2;
	 
SPISR_0_CMD_Error_cdc_from_spi_d2 <= '0';	 
spisel_d1_reg_cdc_from_spi_d2 <= '0';	 
Mst_N_Slv_mode_cdc_from_spi_d2 <= '0';	 
slave_MODF_strobe_cdc_from_spi_d1 <= '0';	 
modf_strobe_cdc_from_spi_d1 <= '0';	 
	 
	 end generate LOGIC_GENERATION_CDC ;

	 
end architecture imp;
---------------------



-------------------------------------------------------------------------------
-- cross_clk_sync_fifo_0.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        cross_clk_sync_fifo_0.vhd
-- Version:         v3.1
-- Description:     This is the CDC logic when FIFO = 0.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.conv_std_logic_vector;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_signed.all;
    use ieee.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
    use ieee.std_logic_unsigned.all;


library axi_lite_ipif_v3_0_4;
use axi_lite_ipif_v3_0_4.axi_lite_ipif;
use axi_lite_ipif_v3_0_4.ipif_pkg.all;
library lib_cdc_v1_0_2;
	use lib_cdc_v1_0_2.cdc_sync;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
library unisim;
    use unisim.vcomponents.FDRE;
    use unisim.vcomponents.FDR;
-------------------------------------------------------------------------------
entity cross_clk_sync_fifo_0 is
     generic (
                 C_NUM_TRANSFER_BITS : integer;
             Async_Clk             : integer;
             C_NUM_SS_BITS                : integer--;
             --C_AXI_SPI_CLK_EQ_DIFF             : integer
              );
     port (
              EXT_SPI_CLK               : in std_logic;
              Bus2IP_Clk                : in std_logic;
              Soft_Reset_op             : in std_logic;
              Rst_from_axi_cdc_to_spi       : in std_logic;
              ----------------------------
              tx_empty_signal_handshake_req     : in std_logic;
              tx_empty_signal_handshake_gnt     : out std_logic;
              Tx_FIFO_Empty_cdc_from_axi     : in std_logic;
              Tx_FIFO_Empty_cdc_to_spi      : out std_logic;
              ----------------------------------------------------------
              Tx_FIFO_Empty_SPISR_cdc_from_spi : in std_logic;
              Tx_FIFO_Empty_SPISR_cdc_to_axi  : out std_logic;
              ----------------------------------------------------------
              spisel_d1_reg_cdc_from_spi     : in std_logic; -- = spisel_pulse_cdc_from_spi_clk  , -- in
              spisel_d1_reg_cdc_to_axi      : out std_logic; -- = spisel_pulse_cdc_to_axi_clk   , -- out
              --------------------------:-------------------------------
              spisel_pulse_cdc_from_spi      : in std_logic; -- = spisel_pulse_cdc_from_spi_clk  , -- in
              spisel_pulse_cdc_to_axi       : out std_logic; -- = spisel_pulse_cdc_to_axi_clk   , -- out
              --------------------------:-------------------------------
              spiXfer_done_cdc_from_spi      : in std_logic; -- = spiXfer_done_cdc_from_spi_clk, -- in
              spiXfer_done_cdc_to_axi       : out std_logic; -- = spiXfer_done_cdc_to_axi_clk , -- out
              --------------------------:-------------------------------
              modf_strobe_cdc_from_spi       : in std_logic; -- = modf_strobe_cdc_from_spi_clk, -- in
              modf_strobe_cdc_to_axi        : out std_logic; -- = modf_strobe_cdc_to_axi_clk , -- out
              --------------------------:-------------------------------
              Slave_MODF_strobe_cdc_from_spi : in std_logic; -- = slave_MODF_strobe_cdc_from_spi_clk,-- in
              Slave_MODF_strobe_cdc_to_axi  : out std_logic; -- = slave_MODF_strobe_cdc_to_axi_clk      ,-- out
              --------------------------:-------------------------------
              receive_Data_cdc_from_spi      : in std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1)); -- = receive_Data_cdc_from_spi_clk, -- in
              receive_Data_cdc_to_axi       : out std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1)); -- = receive_data_cdc_to_axi_clk, -- out
              --------------------------:-------------------------------
              drr_Overrun_int_cdc_from_spi   : in std_logic;
              drr_Overrun_int_cdc_to_axi    : out std_logic;
              --------------------------:-------------------------------
              dtr_underrun_cdc_from_spi      : in std_logic; -- = dtr_underrun_cdc_from_spi_clk, -- in
              dtr_underrun_cdc_to_axi       : out std_logic; -- = dtr_underrun_cdc_to_axi_clk,  -- out
              --------------------------:-------------------------------
              transmit_Data_cdc_from_axi     : in std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1)); -- = transmit_Data_cdc_from_axi_clk, -- in
              transmit_Data_cdc_to_spi      : out std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1)); -- = transmit_Data_cdc_to_spi_clk   -- out
              ----------------------------
              SPICR_0_LOOP_cdc_from_axi      : in std_logic;
              SPICR_0_LOOP_cdc_to_spi       : out std_logic;
              ----------------------------
              SPICR_1_SPE_cdc_from_axi       : in std_logic;
              SPICR_1_SPE_cdc_to_spi        : out std_logic;
              ----------------------------
              SPICR_2_MST_N_SLV_cdc_from_axi : in std_logic;
              SPICR_2_MST_N_SLV_cdc_to_spi  : out std_logic;
              ----------------------------
              SPICR_3_CPOL_cdc_from_axi      : in std_logic;
              SPICR_3_CPOL_cdc_to_spi       : out std_logic;
              ----------------------------
              SPICR_4_CPHA_cdc_from_axi      : in std_logic;
              SPICR_4_CPHA_cdc_to_spi       : out std_logic;
              ----------------------------
              SPICR_5_TXFIFO_cdc_from_axi    : in std_logic;
              SPICR_5_TXFIFO_cdc_to_spi     : out std_logic;
              ----------------------------
              SPICR_6_RXFIFO_RST_cdc_from_axi: in std_logic;
              SPICR_6_RXFIFO_RST_cdc_to_spi : out std_logic;
              ----------------------------
              SPICR_7_SS_cdc_from_axi        : in std_logic;
              SPICR_7_SS_cdc_to_spi         : out std_logic;
              ----------------------------
              SPICR_8_TR_INHIBIT_cdc_from_axi: in std_logic;
              SPICR_8_TR_INHIBIT_cdc_to_spi : out std_logic;
              ----------------------------
              SPICR_9_LSB_cdc_from_axi       : in std_logic;
              SPICR_9_LSB_cdc_to_spi        : out std_logic;
              ----------------------------
              SPICR_bits_7_8_cdc_from_axi    : in std_logic_vector(1 downto 0); -- in std_logic_vector
              SPICR_bits_7_8_cdc_to_spi     : out std_logic_vector(1 downto 0);
              ----------------------------
              SR_3_modf_cdc_from_axi         : in std_logic;
              SR_3_modf_cdc_to_spi          : out std_logic;
              ----------------------------
              SPISSR_cdc_from_axi            : in std_logic_vector(0 to (C_NUM_SS_BITS-1));
              SPISSR_cdc_to_spi             : out std_logic_vector(0 to (C_NUM_SS_BITS-1))
              ----------------------------
     );
end entity cross_clk_sync_fifo_0;

architecture imp of cross_clk_sync_fifo_0 is
--------------------------------------------
----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------


-- signal declaration
signal spisel_d1_reg_cdc_from_spi_d1      : std_logic;
signal spisel_d1_reg_cdc_from_spi_d2      : std_logic;
signal spiXfer_done_cdc_from_spi_d1       : std_logic;
signal spiXfer_done_cdc_from_spi_d2       : std_logic;
signal modf_strobe_cdc_from_spi_d1        : std_logic;
signal modf_strobe_cdc_from_spi_d2        : std_logic;
signal modf_strobe_cdc_from_spi_d3        : std_logic;
signal Slave_MODF_strobe_cdc_from_spi_d1  : std_logic;
signal Slave_MODF_strobe_cdc_from_spi_d2  : std_logic;
signal Slave_MODF_strobe_cdc_from_spi_d3  : std_logic;
signal receive_Data_cdc_from_spi_d1       : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal receive_Data_cdc_from_spi_d2       : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal dtr_underrun_cdc_from_spi_d1       : std_logic;
signal dtr_underrun_cdc_from_spi_d2       : std_logic;
signal transmit_Data_cdc_from_axi_d1      : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal transmit_Data_cdc_from_axi_d2      : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

signal spisel_pulse_cdc_from_spi_d1       : std_logic;
signal spisel_pulse_cdc_from_spi_d2       : std_logic;
signal spisel_pulse_cdc_from_spi_d3       : std_logic;

signal SPICR_0_LOOP_cdc_from_axi_d1       : std_logic;
signal SPICR_0_LOOP_cdc_from_axi_d2       : std_logic;

signal SPICR_1_SPE_cdc_from_axi_d1        : std_logic;
signal SPICR_1_SPE_cdc_from_axi_d2        : std_logic;

signal SPICR_2_MST_N_SLV_cdc_from_axi_d1  : std_logic;
signal SPICR_2_MST_N_SLV_cdc_from_axi_d2  : std_logic;

signal SPICR_3_CPOL_cdc_from_axi_d1       : std_logic;
signal SPICR_3_CPOL_cdc_from_axi_d2       : std_logic;

signal SPICR_4_CPHA_cdc_from_axi_d1       : std_logic;
signal SPICR_4_CPHA_cdc_from_axi_d2       : std_logic;

signal SPICR_5_TXFIFO_cdc_from_axi_d1     : std_logic;
signal SPICR_5_TXFIFO_cdc_from_axi_d2     : std_logic;

signal SPICR_7_SS_cdc_from_axi_d1         : std_logic;
signal SPICR_7_SS_cdc_from_axi_d2         : std_logic;

signal SPICR_8_TR_INHIBIT_cdc_from_axi_d1 : std_logic;
signal SPICR_8_TR_INHIBIT_cdc_from_axi_d2 : std_logic;

signal SPICR_9_LSB_cdc_from_axi_d1        : std_logic;
signal SPICR_9_LSB_cdc_from_axi_d2        : std_logic;

signal SPICR_bits_7_8_cdc_from_axi_d1     : std_logic_vector(1 downto 0);
signal SPICR_bits_7_8_cdc_from_axi_d2     : std_logic_vector(1 downto 0);

signal SPICR_6_RXFIFO_RST_cdc_from_axi_d1 : std_logic;
signal SPICR_6_RXFIFO_RST_cdc_from_axi_d2 : std_logic;

signal Tx_FIFO_Empty_cdc_from_axi_d1      : std_logic;
signal Tx_FIFO_Empty_cdc_from_axi_d2      : std_logic;
signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d1 : std_logic;
signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d2 : std_logic;

signal drr_Overrun_int_cdc_from_spi_d1 : std_logic;
signal drr_Overrun_int_cdc_from_spi_d2 : std_logic;
signal drr_Overrun_int_cdc_from_spi_d3 : std_logic;
signal drr_Overrun_int_cdc_from_spi_d4 : std_logic;

signal SR_3_modf_cdc_from_axi_d1          : std_logic;
signal SR_3_modf_cdc_from_axi_d2          : std_logic;
signal SPISSR_cdc_from_axi_d1             : std_logic_vector(0 to (C_NUM_SS_BITS-1));
signal SPISSR_cdc_from_axi_d2             : std_logic_vector(0 to (C_NUM_SS_BITS-1));
     signal spiXfer_done_cdc_from_spi_int_2 : std_logic;
     signal spiXfer_done_d1            : std_logic;
     signal spiXfer_done_d2, spiXfer_done_d3           : std_logic;
     signal spisel_pulse_cdc_from_spi_int_2 : std_logic;
     signal Tx_FIFO_Empty_cdc_from_axi_int_2 : std_logic;
     signal Tx_FIFO_Empty_cdc_from_axi_d3 : std_logic;
     signal drr_Overrun_int_cdc_from_spi_int_2 : std_logic;
     signal Slave_MODF_strobe_cdc_from_spi_int_2 : std_logic;
    signal modf_strobe_cdc_from_spi_int_2 : std_logic;


    signal Tx_FIFO_Empty_cdc_to_spi_i : std_logic;
-- signal declaration
-- signal spisel_d1_reg_cdc_from_spi_d1      : std_logic;
-- signal spisel_d1_reg_cdc_from_spi_d2      : std_logic;
-- signal spiXfer_done_cdc_from_spi_d1       : std_logic;
-- signal spiXfer_done_cdc_from_spi_d2       : std_logic;
-- signal modf_strobe_cdc_from_spi_d1        : std_logic;
-- signal modf_strobe_cdc_from_spi_d2        : std_logic;
-- signal modf_strobe_cdc_from_spi_d3        : std_logic;
-- signal Slave_MODF_strobe_cdc_from_spi_d1  : std_logic;
-- signal Slave_MODF_strobe_cdc_from_spi_d2  : std_logic;
-- signal Slave_MODF_strobe_cdc_from_spi_d3  : std_logic;
-- signal receive_Data_cdc_from_spi_d1       : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
-- signal receive_Data_cdc_from_spi_d2       : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
-- signal dtr_underrun_cdc_from_spi_d1       : std_logic;
-- signal dtr_underrun_cdc_from_spi_d2       : std_logic;
-- signal transmit_Data_cdc_from_axi_d1      : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
-- signal transmit_Data_cdc_from_axi_d2      : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

-- signal spisel_pulse_cdc_from_spi_d1       : std_logic;
-- signal spisel_pulse_cdc_from_spi_d2       : std_logic;
-- signal spisel_pulse_cdc_from_spi_d3       : std_logic;

-- signal SPICR_0_LOOP_cdc_from_axi_d1       : std_logic;
-- signal SPICR_0_LOOP_cdc_from_axi_d2       : std_logic;

-- signal SPICR_1_SPE_cdc_from_axi_d1        : std_logic;
-- signal SPICR_1_SPE_cdc_from_axi_d2        : std_logic;

-- signal SPICR_2_MST_N_SLV_cdc_from_axi_d1  : std_logic;
-- signal SPICR_2_MST_N_SLV_cdc_from_axi_d2  : std_logic;

-- signal SPICR_3_CPOL_cdc_from_axi_d1       : std_logic;
-- signal SPICR_3_CPOL_cdc_from_axi_d2       : std_logic;

-- signal SPICR_4_CPHA_cdc_from_axi_d1       : std_logic;
-- signal SPICR_4_CPHA_cdc_from_axi_d2       : std_logic;

-- signal SPICR_5_TXFIFO_cdc_from_axi_d1     : std_logic;
-- signal SPICR_5_TXFIFO_cdc_from_axi_d2     : std_logic;

-- signal SPICR_7_SS_cdc_from_axi_d1         : std_logic;
-- signal SPICR_7_SS_cdc_from_axi_d2         : std_logic;

-- signal SPICR_8_TR_INHIBIT_cdc_from_axi_d1 : std_logic;
-- signal SPICR_8_TR_INHIBIT_cdc_from_axi_d2 : std_logic;

-- signal SPICR_9_LSB_cdc_from_axi_d1        : std_logic;
-- signal SPICR_9_LSB_cdc_from_axi_d2        : std_logic;

-- signal SPICR_bits_7_8_cdc_from_axi_d1     : std_logic_vector(1 downto 0);
-- signal SPICR_bits_7_8_cdc_from_axi_d2     : std_logic_vector(1 downto 0);

-- signal SPICR_6_RXFIFO_RST_cdc_from_axi_d1 : std_logic;
-- signal SPICR_6_RXFIFO_RST_cdc_from_axi_d2 : std_logic;

-- signal Tx_FIFO_Empty_cdc_from_axi_d1      : std_logic;
-- signal Tx_FIFO_Empty_cdc_from_axi_d2      : std_logic;

-- signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d1 : std_logic;
-- signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d2 : std_logic;
-- signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d3 : std_logic;
-- signal Tx_FIFO_Empty_SPISR_cdc_from_spi_d4 : std_logic;

-- signal drr_Overrun_int_cdc_from_spi_d1 : std_logic;
-- signal drr_Overrun_int_cdc_from_spi_d2 : std_logic;
-- signal drr_Overrun_int_cdc_from_spi_d3 : std_logic;

-- signal SR_3_modf_cdc_from_axi_d1          : std_logic;
-- signal SR_3_modf_cdc_from_axi_d2          : std_logic;
-- signal SPISSR_cdc_from_axi_d1             : std_logic_vector(0 to (C_NUM_SS_BITS-1));
-- signal SPISSR_cdc_from_axi_d2             : std_logic_vector(0 to (C_NUM_SS_BITS-1));
     -- signal spiXfer_done_cdc_from_spi_int_2 : std_logic;
     -- signal spiXfer_done_d1            : std_logic;
     -- signal spiXfer_done_d2, spiXfer_done_d3           : std_logic;
     -- signal spisel_pulse_cdc_from_spi_int_2 : std_logic;
     -- signal Tx_FIFO_Empty_cdc_from_axi_int_2 : std_logic;
     -- signal Tx_FIFO_Empty_cdc_from_axi_d3 : std_logic;
     -- signal drr_Overrun_int_cdc_from_spi_int_2 : std_logic;
     -- signal Slave_MODF_strobe_cdc_from_spi_int_2 : std_logic;
    -- signal modf_strobe_cdc_from_spi_int_2 : std_logic;


-- attribute ASYNC_REG : string;
-- attribute ASYNC_REG of SPISEL_D1_REG_SYNC_SPI_2_AXI_1 : label is "TRUE";
-- attribute ASYNC_REG of SYNC_SPIXFER_DONE_SYNC_SPI_2_AXI_1 : label is "TRUE";
-- attribute ASYNC_REG of TX_FIFO_EMPTY_SYNC_AXI_2_SPI_1     : label is "TRUE";
-- attribute ASYNC_REG of SLAVE_MODF_STROBE_SYNC_SPI_cdc_to_AXI_1: label is "TRUE";
-- attribute ASYNC_REG of MODF_STROBE_SYNC_SPI_cdc_to_AXI_1      : label is "TRUE";
-- attribute ASYNC_REG of DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_1      : label is "TRUE";
-- attribute ASYNC_REG of SPICR_9_LSB_AX2S_1                 : label is "TRUE";
-- attribute ASYNC_REG of SPICR_8_TR_INHIBIT_AX2S_1          : label is "TRUE";
-- attribute ASYNC_REG of SPICR_7_SS_AX2S_1                  : label is "TRUE";
-- attribute ASYNC_REG of SPICR_6_RXFIFO_RST_AX2S_1          : label is "TRUE";
-- attribute ASYNC_REG of SPICR_5_TXFIFO_AX2S_1              : label is "TRUE";
-- attribute ASYNC_REG of SPICR_4_CPHA_AX2S_1                : label is "TRUE";
-- attribute ASYNC_REG of SPICR_3_CPOL_AX2S_1                : label is "TRUE";
-- attribute ASYNC_REG of SPICR_2_MST_N_SLV_AX2S_1           : label is "TRUE";
-- attribute ASYNC_REG of SPICR_1_SPE_AX2S_1                 : label is "TRUE";
-- attribute ASYNC_REG of SPICR_0_LOOP_AX2S_1                : label is "TRUE";
-- attribute ASYNC_REG of SR_3_MODF_AX2S_1                   : label is "TRUE";

constant LOGIC_CHANGE : integer range 0 to 1 := 1;
constant MTBF_STAGES_AXI2S : integer range 0 to 6 := 3 ;
constant MTBF_STAGES_S2AXI : integer range 0 to 6 := 4 ;



-----
begin
-----
-- SPI_AXI_EQUAL_GEN: AXI and SPI domain clocks are same
---------------------
--SPI_AXI_EQUAL_GEN: if C_AXI_SPI_CLK_EQ_DIFF = 0 generate
-----
--begin

-----

LOGIC_GENERATION_FDR : if (Async_Clk =0) generate

     TX_FIFO_EMPTY_FOR_SPISR_SYNC_SPI_2_AXI: process(Bus2IP_Clk) is
     begin
     -----
          if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
              if(Soft_Reset_op = '1')then
                  Tx_FIFO_Empty_SPISR_cdc_from_spi_d1 <= '1';
                  Tx_FIFO_Empty_SPISR_cdc_from_spi_d2 <= '1';
              else
                  Tx_FIFO_Empty_SPISR_cdc_from_spi_d1 <= Tx_FIFO_Empty_SPISR_cdc_from_spi;
                  Tx_FIFO_Empty_SPISR_cdc_from_spi_d2 <= Tx_FIFO_Empty_SPISR_cdc_from_spi_d1;
              end if;
          end if;
     end process TX_FIFO_EMPTY_FOR_SPISR_SYNC_SPI_2_AXI;
     -----------------------------------------
     Tx_FIFO_Empty_SPISR_cdc_to_axi <= Tx_FIFO_Empty_SPISR_cdc_from_spi_d2;
     -------------------------------------------------

         TX_FIFO_EMPTY_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_from_axi_cdc_to_spi = '1') then
                        Tx_FIFO_Empty_cdc_from_axi_int_2 <= '1';
                else
                        Tx_FIFO_Empty_cdc_from_axi_int_2 <= Tx_FIFO_Empty_cdc_from_axi xor
                                                      Tx_FIFO_Empty_cdc_from_axi_int_2;
                end if;
          end if;
     end process TX_FIFO_EMPTY_STRETCH_1;

     TX_FIFO_EMPTY_SYNC_AXI_2_SPI_1: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => Tx_FIFO_Empty_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => Tx_FIFO_Empty_cdc_from_axi_int_2,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     TX_FIFO_EMPTY_SYNC_AXI_2_SPI_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => Tx_FIFO_Empty_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => Tx_FIFO_Empty_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );

--     Tx_FIFO_Empty_cdc_to_spi <= Tx_FIFO_Empty_cdc_from_axi_d2 xor Tx_FIFO_Empty_cdc_from_axi_d1;

     TX_FIFO_EMPTY_SYNC_AXI_2_SPI_3: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => Tx_FIFO_Empty_cdc_from_axi_d3,
                              C  => EXT_SPI_CLK,
                              D  => Tx_FIFO_Empty_cdc_from_axi_d2,
                              R  => Rst_from_axi_cdc_to_spi
                            );

       Tx_FIFO_Empty_cdc_to_spi <= Tx_FIFO_Empty_cdc_from_axi_d2 xor Tx_FIFO_Empty_cdc_from_axi_d3;
     -------------------------------------------------

     SPISEL_D1_REG_SYNC_SPI_2_AXI_1: component FDR
                   port map (
                              Q  => spisel_d1_reg_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => spisel_d1_reg_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     SPISEL_D1_REG_SYNC_SPI_2_AXI_2: component FDR
                   port map (
                              Q  => spisel_d1_reg_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => spisel_d1_reg_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );

     spisel_d1_reg_cdc_to_axi <= spisel_d1_reg_cdc_from_spi_d2;

    SPISEL_PULSE_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_from_axi_cdc_to_spi = '1') then
                        spisel_pulse_cdc_from_spi_int_2 <= '0';
                else
                        spisel_pulse_cdc_from_spi_int_2 <= spisel_pulse_cdc_from_spi xor
                                                      spisel_pulse_cdc_from_spi_int_2;
                end if;
          end if;
     end process SPISEL_PULSE_STRETCH_1;
   SPISEL_PULSE_SPI_2_AXI_1: component FDR
                   port map (
                              Q  => spisel_pulse_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
     SPISEL_PULSE_SPI_2_AXI_2: component FDR
                   port map (
                              Q  => spisel_pulse_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     SPISEL_PULSE_SPI_2_AXI_3: component FDR
                   port map (
                              Q  => spisel_pulse_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => spisel_pulse_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
spisel_pulse_cdc_to_axi <= spisel_pulse_cdc_from_spi_d2 xor spisel_pulse_cdc_from_spi_d3;
    ---------------------------------------------
         SPI_XFER_DONE_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_from_axi_cdc_to_spi = '1') then
                        spiXfer_done_cdc_from_spi_int_2 <= '0';
                else
                        spiXfer_done_cdc_from_spi_int_2 <= spiXfer_done_cdc_from_spi xor
                                                      spiXfer_done_cdc_from_spi_int_2;
                end if;
          end if;
     end process SPI_XFER_DONE_STRETCH_1;

     SYNC_SPIXFER_DONE_SYNC_SPI_2_AXI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_d1,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
     SYNC_SPIXFER_DONE_SYNC_SPI_2_AXI_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_d2,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_d1,
                              R  => Soft_Reset_op
                            );
     SYNC_SPIXFER_DONE_SYNC_SPI_2_AXI_3: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => spiXfer_done_d3,
                              C  => Bus2IP_Clk,
                              D  => spiXfer_done_d2,
                              R  => Soft_Reset_op
                            );
    spiXfer_done_cdc_to_axi <= spiXfer_done_d2 xor spiXfer_done_d3; --spiXfer_done_cdc_from_spi_d2;
    -----------------------------------------------

    MODF_STROBE_STRETCH_1: process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
               if(Rst_from_axi_cdc_to_spi = '1') then
                       modf_strobe_cdc_from_spi_int_2 <= '0';
               else
                       modf_strobe_cdc_from_spi_int_2 <= modf_strobe_cdc_from_spi xor
                                                     modf_strobe_cdc_from_spi_int_2;
               end if;
         end if;
    end process MODF_STROBE_STRETCH_1;
     MODF_STROBE_SYNC_SPI_cdc_to_AXI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => modf_strobe_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => modf_strobe_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
     MODF_STROBE_SYNC_SPI_cdc_to_AXI_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => modf_strobe_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => modf_strobe_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     MODF_STROBE_SYNC_SPI_cdc_to_AXI_3: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => modf_strobe_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => modf_strobe_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
    modf_strobe_cdc_to_axi <= modf_strobe_cdc_from_spi_d2 xor modf_strobe_cdc_from_spi_d3; --spiXfer_done_cdc_from_spi_d2;
    ---------------------------------------------------------
    SLAVE_MODF_STROBE_STRETCH_1: process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
               if(Rst_from_axi_cdc_to_spi = '1') then
                       Slave_MODF_strobe_cdc_from_spi_int_2 <= '0';
               else
                       Slave_MODF_strobe_cdc_from_spi_int_2 <= Slave_MODF_strobe_cdc_from_spi xor
                                                     Slave_MODF_strobe_cdc_from_spi_int_2;
               end if;
         end if;
    end process SLAVE_MODF_STROBE_STRETCH_1;
     SLAVE_MODF_STROBE_SYNC_SPI_cdc_to_AXI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Slave_MODF_strobe_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => Slave_MODF_strobe_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
     SLAVE_MODF_STROBE_SYNC_SPI_cdc_to_AXI_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Slave_MODF_strobe_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => Slave_MODF_strobe_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
      SLAVE_MODF_STROBE_SYNC_SPI_cdc_to_AXI_3: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => Slave_MODF_strobe_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => Slave_MODF_strobe_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
   Slave_MODF_strobe_cdc_to_axi <= Slave_MODF_strobe_cdc_from_spi_d2 xor
                               Slave_MODF_strobe_cdc_from_spi_d3; --spiXfer_done_cdc_from_spi_d2;
    -----------------------------------------------

    ---------------------------------------------------------

    RECEIVE_DATA_SYNC_SPI_cdc_to_AXI_P: process(Bus2IP_Clk) is
    -------------------------
    begin
    -----
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1')then
             receive_Data_cdc_from_spi_d1 <= receive_Data_cdc_from_spi;
             receive_Data_cdc_from_spi_d2 <= receive_Data_cdc_from_spi_d1;
         end if;
    end process RECEIVE_DATA_SYNC_SPI_cdc_to_AXI_P;
    -------------------------------------------
    receive_Data_cdc_to_axi <= receive_Data_cdc_from_spi_d2;
    -----------------------------------------------
     DRR_OVERRUN_STRETCH_1: process(EXT_SPI_CLK)is
     begin
          if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                if(Rst_from_axi_cdc_to_spi = '1') then
                        drr_Overrun_int_cdc_from_spi_int_2 <= '0';
                else
                        drr_Overrun_int_cdc_from_spi_int_2 <= drr_Overrun_int_cdc_from_spi xor
                                                      drr_Overrun_int_cdc_from_spi_int_2;
                end if;
          end if;
     end process DRR_OVERRUN_STRETCH_1;

     DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => drr_Overrun_int_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => drr_Overrun_int_cdc_from_spi_int_2,
                              R  => Soft_Reset_op
                            );
     DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => drr_Overrun_int_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => drr_Overrun_int_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );
     DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_3: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => drr_Overrun_int_cdc_from_spi_d3,
                              C  => Bus2IP_Clk,
                              D  => drr_Overrun_int_cdc_from_spi_d2,
                              R  => Soft_Reset_op
                            );
    drr_Overrun_int_cdc_to_axi <= drr_Overrun_int_cdc_from_spi_d2 xor drr_Overrun_int_cdc_from_spi_d3; --spiXfer_done_cdc_from_spi_d2;
    -----------------------------------------------
     DTR_UNDERRUN_SYNC_SPI_2_AXI_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => dtr_underrun_cdc_from_spi_d1,
                              C  => Bus2IP_Clk,
                              D  => dtr_underrun_cdc_from_spi,
                              R  => Soft_Reset_op
                            );
     DTR_UNDERRUN_SYNC_SPI_2_AXI_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => dtr_underrun_cdc_from_spi_d2,
                              C  => Bus2IP_Clk,
                              D  => dtr_underrun_cdc_from_spi_d1,
                              R  => Soft_Reset_op
                            );

    dtr_underrun_cdc_to_axi <= dtr_underrun_cdc_from_spi_d2;
    -----------------------------------------------

TR_DATA_SYNC_AX2SP_GEN: for i in 0 to (C_NUM_TRANSFER_BITS-1) generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of TR_DATA_SYNC_AX2SP_1: label is "TRUE";
     -----
     begin
     -----
     TR_DATA_SYNC_AX2SP_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => transmit_Data_cdc_from_axi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => transmit_Data_cdc_from_axi(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     TR_DATA_SYNC_AX2SP_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => transmit_Data_cdc_from_axi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => transmit_Data_cdc_from_axi_d1(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
end generate TR_DATA_SYNC_AX2SP_GEN;

transmit_Data_cdc_to_spi <= transmit_Data_cdc_from_axi_d2;
-----------------------------------------------

     SPICR_0_LOOP_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_0_LOOP_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_0_LOOP_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_0_LOOP_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_0_LOOP_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_0_LOOP_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );

     SPICR_0_LOOP_cdc_to_spi <= SPICR_0_LOOP_cdc_from_axi_d2;
     -----------------------------------------------

     SPICR_1_SPE_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_1_SPE_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_1_SPE_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_1_SPE_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_1_SPE_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_1_SPE_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_1_SPE_cdc_to_spi <= SPICR_1_SPE_cdc_from_axi_d2;
     ---------------------------------------------

          SPICR_2_MST_N_SLV_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_2_MST_N_SLV_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_2_MST_N_SLV_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_2_MST_N_SLV_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_2_MST_N_SLV_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_2_MST_N_SLV_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_2_MST_N_SLV_cdc_to_spi <= SPICR_2_MST_N_SLV_cdc_from_axi_d2;
     ---------------------------------------------------------

     SPICR_3_CPOL_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_3_CPOL_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_3_CPOL_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_3_CPOL_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_3_CPOL_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_3_CPOL_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_3_CPOL_cdc_to_spi <= SPICR_3_CPOL_cdc_from_axi_d2;
     -----------------------------------------------
     SPICR_4_CPHA_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_4_CPHA_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_4_CPHA_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_4_CPHA_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_4_CPHA_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_4_CPHA_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_4_CPHA_cdc_to_spi <= SPICR_4_CPHA_cdc_from_axi_d2;
     -----------------------------------------------
     SPICR_5_TXFIFO_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_5_TXFIFO_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_5_TXFIFO_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_5_TXFIFO_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_5_TXFIFO_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_5_TXFIFO_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_5_TXFIFO_cdc_to_spi <= SPICR_5_TXFIFO_cdc_from_axi_d2;
     ---------------------------------------------------
     SPICR_6_RXFIFO_RST_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_6_RXFIFO_RST_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_6_RXFIFO_RST_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_6_RXFIFO_RST_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_6_RXFIFO_RST_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_6_RXFIFO_RST_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_6_RXFIFO_RST_cdc_to_spi <= SPICR_6_RXFIFO_RST_cdc_from_axi_d2;
     -----------------------------------------------------------
     SPICR_7_SS_AX2S_1: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_7_SS_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_7_SS_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_7_SS_AX2S_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_7_SS_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_7_SS_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_7_SS_cdc_to_spi <= SPICR_7_SS_cdc_from_axi_d2;
     -------------------------------------------
     SPICR_8_TR_INHIBIT_AX2S_1: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_8_TR_INHIBIT_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_8_TR_INHIBIT_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_8_TR_INHIBIT_AX2S_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPICR_8_TR_INHIBIT_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_8_TR_INHIBIT_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_8_TR_INHIBIT_cdc_to_spi <= SPICR_8_TR_INHIBIT_cdc_from_axi_d2;
     -----------------------------------------------------------
          SPICR_9_LSB_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_9_LSB_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_9_LSB_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_9_LSB_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_9_LSB_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SPICR_9_LSB_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_9_LSB_cdc_to_spi <= SPICR_9_LSB_cdc_from_axi_d2;
     ---------------------------------------------
          SPICR_BITS_7_8_SYNC_GEN: for i in 1 downto 0 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of SPICR_BITS_7_8_AX2S_1 : label is "TRUE";
     begin
     -----
     SPICR_BITS_7_8_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_bits_7_8_cdc_from_axi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => SPICR_bits_7_8_cdc_from_axi(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPICR_BITS_7_8_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SPICR_bits_7_8_cdc_from_axi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => SPICR_bits_7_8_cdc_from_axi_d1(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     end generate SPICR_BITS_7_8_SYNC_GEN;
     -------------------------------------
     SPICR_bits_7_8_cdc_to_spi <= SPICR_bits_7_8_cdc_from_axi_d2;
     ---------------------------------------------------
     SR_3_MODF_AX2S_1: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SR_3_modf_cdc_from_axi_d1,
                              C  => EXT_SPI_CLK,
                              D  => SR_3_modf_cdc_from_axi,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SR_3_MODF_AX2S_2: component FDR
                   generic map(INIT => '0'
                   )port map (
                              Q  => SR_3_modf_cdc_from_axi_d2,
                              C  => EXT_SPI_CLK,
                              D  => SR_3_modf_cdc_from_axi_d1,
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SR_3_modf_cdc_to_spi <= SR_3_modf_cdc_from_axi_d2;
     -----------------------------------------

     SPISSR_SYNC_GEN: for i in 0 to C_NUM_SS_BITS-1 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of SPISSR_AX2S_1                  : label is "TRUE";
     -----
     begin
     -----
     SPISSR_AX2S_1: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPISSR_cdc_from_axi_d1(i),
                              C  => EXT_SPI_CLK,
                              D  => SPISSR_cdc_from_axi(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     SPISSR_SYNC_AXI_2_SPI_2: component FDR
                   generic map(INIT => '1'
                   )port map (
                              Q  => SPISSR_cdc_from_axi_d2(i),
                              C  => EXT_SPI_CLK,
                              D  => SPISSR_cdc_from_axi_d1(i),
                              R  => Rst_from_axi_cdc_to_spi
                            );
     end generate SPISSR_SYNC_GEN;

     SPISSR_cdc_to_spi <= SPISSR_cdc_from_axi_d2;
     -----------------------------------
     
     end generate LOGIC_GENERATION_FDR ;
     
--============================================================================================================
	 
LOGIC_GENERATION_CDC : if (Async_Clk =1) generate 

--============================================================================================================    
	
-- Tx_FIFO_Empty_cdc_from_axi <= Tx_FIFO_Empty_cdc_from_axi;
-- Tx_FIFO_Empty_cdc_to_spi       <= Tx_FIFO_Empty_cdc_cdc_to_spi;

-- Tx_FIFO_Empty_SPISR_cdc_from_spi <= Tx_FIFO_Empty_SPISR_cdc_from_spi;
-- Tx_FIFO_Empty_SPISR_cdc_to_axi       <= Tx_FIFO_Empty_SPISR_cdc_cdc_to_axi;

-- spisel_d1_reg_cdc_from_spi <= spisel_d1_reg_cdc_from_spi;
-- spisel_d1_reg_cdc_to_axi      <= spisel_d1_reg_cdc_cdc_to_axi;

-- spisel_pulse_cdc_from_spi <= spisel_pulse_cdc_from_spi;
-- spisel_pulse_cdc_to_axi       <= spisel_pulse_cdc_cdc_to_axi;

-- spiXfer_done_cdc_from_spi <= spiXfer_done_cdc_from_spi;
-- spiXfer_done_cdc_to_axi       <= spiXfer_done_cdc_cdc_to_axi;

-- modf_strobe_cdc_from_spi <= modf_strobe_cdc_from_spi;
-- modf_strobe_cdc_to_axi       <= modf_strobe_cdc_cdc_to_axi;

-- Slave_MODF_strobe_cdc_from_spi <= Slave_MODF_strobe_cdc_from_spi;
-- Slave_MODF_strobe_cdc_to_axi       <= Slave_MODF_strobe_cdc_cdc_to_axi;

-- receive_Data_cdc_from_spi <= receive_Data_cdc_from_spi;
-- receive_Data_cdc_to_axi       <= receive_Data_cdc_cdc_to_axi;

-- drr_Overrun_int_cdc_from_spi <= drr_Overrun_int_cdc_from_spi;
-- drr_Overrun_int_cdc_to_axi       <= drr_Overrun_int_cdc_cdc_to_axi;

-- dtr_underrun_cdc_from_spi <= dtr_underrun_cdc_from_spi;
-- dtr_underrun_cdc_to_axi       <= dtr_underrun_cdc_cdc_to_axi;

-- transmit_Data_cdc_from_axi <= transmit_Data_cdc_from_axi;
-- transmit_Data_cdc_to_spi       <= transmit_Data_cdc_cdc_to_spi;

-- SPICR_0_LOOP_cdc_from_axi <= SPICR_0_LOOP_cdc_from_axi;
-- SPICR_0_LOOP_cdc_to_spi       <= SPICR_0_LOOP_cdc_cdc_to_spi;

-- SPICR_1_SPE_cdc_from_axi <= SPICR_1_SPE_cdc_from_axi;
-- SPICR_1_SPE_cdc_to_spi       <= SPICR_1_SPE_cdc_cdc_to_spi;

-- SPICR_2_MST_N_SLV_cdc_from_axi <= SPICR_2_MST_N_SLV_cdc_from_axi;
-- SPICR_2_MST_N_SLV_cdc_to_spi       <= SPICR_2_MST_N_SLV_cdc_cdc_to_spi;

-- SPICR_3_CPOL_cdc_from_axi <= SPICR_3_CPOL_cdc_from_axi;
-- SPICR_3_CPOL_cdc_to_spi       <= SPICR_3_CPOL_cdc_cdc_to_spi;

-- SPICR_4_CPHA_cdc_from_axi <= SPICR_4_CPHA_cdc_from_axi;
-- SPICR_4_CPHA_cdc_to_spi      <= SPICR_4_CPHA_cdc_cdc_to_spi;

-- SPICR_5_TXFIFO_cdc_from_axi <= SPICR_5_TXFIFO_cdc_from_axi;
-- SPICR_5_TXFIFO_cdc_to_spi       <= SPICR_5_TXFIFO_cdc_cdc_to_spi;

-- SPICR_6_RXFIFO_RST_cdc_from_axi <= SPICR_6_RXFIFO_RST_cdc_from_axi;
-- SPICR_6_RXFIFO_RST_cdc_to_spi       <= SPICR_6_RXFIFO_RST_cdc_cdc_to_spi;

-- SPICR_7_SS_cdc_from_axi <= SPICR_7_SS_cdc_from_axi;
-- SPICR_7_SS_cdc_to_spi       <= SPICR_7_SS_cdc_cdc_to_spi;

-- SPICR_8_TR_INHIBIT_cdc_from_axi <= SPICR_8_TR_INHIBIT_cdc_from_axi;
-- SPICR_8_TR_INHIBIT_cdc_to_spi       <= SPICR_8_TR_INHIBIT_cdc_cdc_to_spi;

-- SPICR_9_LSB_cdc_from_axi <= SPICR_9_LSB_cdc_from_axi;
-- SPICR_9_LSB_cdc_to_spi       <= SPICR_9_LSB_cdc_cdc_to_spi;

-- SPICR_bits_7_8_cdc_from_axi <= SPICR_bits_7_8_cdc_from_axi;
-- SPICR_bits_7_8_cdc_to_spi       <= SPICR_bits_7_8_cdc_cdc_to_spi;

-- SR_3_modf_cdc_from_axi <= SR_3_modf_cdc_from_axi;
-- SR_3_modf_cdc_to_spi       <= SR_3_modf_cdc_cdc_to_spi;

-- SPISSR_cdc_from_axi <= SPISSR_cdc_from_axi;
-- SPISSR_cdc_to_spi       <= SPISSR_cdc_cdc_to_spi;

--============================================================================================================    
	
	-- all the signals pass through FF with reset before CDC_SYNC module to initialise the value of the signal 
	-- at its reset state. As many signals coming from bram have initial value of XX.
	
	
	
	
       
    TX_FIFO_EMPTY_FOR_SPISR_SYNC_SPI_2_AXI_CDC : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 ,   -- 1 is level synch
        C_RESET_STATE               => 0 ,   -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => Tx_FIFO_Empty_SPISR_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	    prmry_vect_in        => (others => '0') ,
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => Tx_FIFO_Empty_SPISR_cdc_to_axi
    ); 
     
--------------------------------------------------------------------------------------------------------------
----  --  TX_FIFO_EMPTY_STRETCH_1: process(Bus2IP_Clk)is
----  --   begin
----  --        if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
----  --              if(Soft_Reset_op = '1') then
----  --                      Tx_FIFO_Empty_cdc_from_axi_int_2 <= '1';
----  --              else
----  --                      Tx_FIFO_Empty_cdc_from_axi_int_2 <= Tx_FIFO_Empty_cdc_from_axi xor
----  --                                                    Tx_FIFO_Empty_cdc_from_axi_int_2;
----  --              end if;
----  --        end if;
----  --   end process TX_FIFO_EMPTY_STRETCH_1;
----
----    TX_FIFO_EMPTY_SYNC_AXI_2_SPI_CDC : entity lib_cdc_v1_0_2.cdc_sync
----    generic map (
----        C_CDC_TYPE                  => 1, -- 2 is ack based level sync
----        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
----        C_SINGLE_BIT                => 1 , 
----        C_FLOP_INPUT                => 0 ,
----        C_VECTOR_WIDTH              => 1 ,
----        C_MTBF_STAGES               => MTBF_STAGES_AXI2S   
----		)
----
----    port map (
----        prmry_aclk           => Bus2IP_Clk , 
----        prmry_resetn         => Soft_Reset_op ,
----        prmry_in             => Tx_FIFO_Empty_cdc_from_axi,--Tx_FIFO_Empty_cdc_from_axi_int_2,--Tx_FIFO_Empty_cdc_from_axi_d1 ,
----        scndry_aclk          => EXT_SPI_CLK ,
----	    prmry_vect_in        => (others => '0' ),
----        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
----        scndry_out            => Tx_FIFO_Empty_cdc_from_axi_d2 --Tx_FIFO_Empty_cdc_from_axi_d2--Tx_FIFO_Empty_cdc_to_spi
----        --scndry_out            => Tx_FIFO_Empty_cdc_to_spi --Tx_FIFO_Empty_cdc_from_axi_d2--Tx_FIFO_Empty_cdc_to_spi
----       );
----	   
------	   TX_FIFO_EMPTY_STRETCH_1_CDC: process(EXT_SPI_CLK)is
------         begin
------              if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
------                    
------                            Tx_FIFO_Empty_cdc_from_axi_d3 <= Tx_FIFO_Empty_cdc_from_axi_d2;                          
------                    
------              end if;
------     end process TX_FIFO_EMPTY_STRETCH_1_CDC;
------     Tx_FIFO_Empty_cdc_to_spi <= Tx_FIFO_Empty_cdc_from_axi_d2 xor Tx_FIFO_Empty_cdc_from_axi_d3;
----
----	   TX_FIFO_EMPTY_STRETCH_1_CDC: process(EXT_SPI_CLK)is
----         begin
----              if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
----                    
----                            Tx_FIFO_Empty_cdc_from_axi_d3 <= Tx_FIFO_Empty_cdc_from_axi_d2;                          
----                    
----              end if;
----     end process TX_FIFO_EMPTY_STRETCH_1_CDC;
----     Tx_FIFO_Empty_cdc_to_spi <= Tx_FIFO_Empty_cdc_from_axi_d2 or Tx_FIFO_Empty_cdc_from_axi_d3;


    Tx_FIFO_Empty_cdc_to_spi <= Tx_FIFO_Empty_cdc_to_spi_i;



    TX_FIFO_EMPTY_HANDSHAKE_REQ_AXI_2_SPI_CDC : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1, -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S   
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => tx_empty_signal_handshake_req,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => Tx_FIFO_Empty_cdc_to_spi_i 
       );



    TX_FIFO_EMPTY_HANDSHAKE_GNT_SPI_2_AXI_CDC : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1, -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S   
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => Tx_FIFO_Empty_cdc_to_spi_i,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => tx_empty_signal_handshake_gnt 
       );




	----------------------------------------------------------------------------------------------------------
	
	
   
	SPISEL_D1_REG_SYNC_SPI_2_AXI_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 ,  -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => spisel_d1_reg_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
        prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => spisel_d1_reg_cdc_to_axi
    );			
    -----------------------------------------------------------------------------------------------------------
    
   SPISEL_PULSE_STRETCH_1_CDC: process(EXT_SPI_CLK)is
         begin
              if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                    if(Rst_from_axi_cdc_to_spi = '1') then
                            spisel_pulse_cdc_from_spi_int_2 <= '0';
                            --spisel_pulse_cdc_from_spi_d1    <= '0';
                    else
                            spisel_pulse_cdc_from_spi_int_2 <= spisel_pulse_cdc_from_spi xor
                                                      spisel_pulse_cdc_from_spi_int_2;
                            --spisel_pulse_cdc_from_spi_d1    <= spisel_pulse_cdc_from_spi_int_2;                          
                    end if;
              end if;
     end process SPISEL_PULSE_STRETCH_1_CDC;

	SPISEL_PULSE_SPI_2_AXI_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI   
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => spisel_pulse_cdc_from_spi_int_2 ,
        scndry_aclk          => Bus2IP_Clk ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out            => spisel_pulse_cdc_from_spi_d2
    );
	SPISEL_PULSE_STRETCH_1: process(Bus2IP_Clk)is
         begin
              if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
                    
                            spisel_pulse_cdc_from_spi_d3 <= spisel_pulse_cdc_from_spi_d2;
                                                    
                    
              end if;
     end process SPISEL_PULSE_STRETCH_1;
	 spisel_pulse_cdc_to_axi <= spisel_pulse_cdc_from_spi_d2 xor spisel_pulse_cdc_from_spi_d3;
    --------------------------------------------------------------------------------------------------------------
	 SPI_XFER_DONE_STRETCH_1_CDC: process(EXT_SPI_CLK)is
	      begin
	           if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
	                 if(Rst_from_axi_cdc_to_spi = '1') then
	                         spiXfer_done_cdc_from_spi_int_2 <= '0';
	                        -- spiXfer_done_d2            <= '0';
	                 else
	                         spiXfer_done_cdc_from_spi_int_2 <= spiXfer_done_cdc_from_spi xor
                                                      spiXfer_done_cdc_from_spi_int_2;
                                -- spiXfer_done_d2            <= spiXfer_done_cdc_from_spi_int_2;
	                 end if;
	           end if;
     end process SPI_XFER_DONE_STRETCH_1_CDC;
	  
	 SYNC_SPIXFER_DONE_SYNC_SPI_2_AXI_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 ,-- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI  
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => spiXfer_done_cdc_from_spi_int_2,--spiXfer_done_d2 ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => spiXfer_done_d2--spiXfer_done_cdc_to_axi
    );
	
	SPI_XFER_DONE_STRETCH_1: process(Bus2IP_Clk)is
	      begin
	           if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
	                 
	                         spiXfer_done_d3 <= spiXfer_done_d2 ;
	                 
	           end if;
     end process SPI_XFER_DONE_STRETCH_1;
     spiXfer_done_cdc_to_axi <= spiXfer_done_d2 xor spiXfer_done_d3;
	 --------------------------------------------------------------------------------------------------------------
	
	MODF_STROBE_STRETCH_1_CDC: process(EXT_SPI_CLK)is
	    begin
	         if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
	               if(Rst_from_axi_cdc_to_spi = '1') then
	                       modf_strobe_cdc_from_spi_int_2 <= '0';
	                       --modf_strobe_cdc_from_spi_d1    <= '0';
	               else
	                       modf_strobe_cdc_from_spi_int_2 <= modf_strobe_cdc_from_spi xor
                                                     modf_strobe_cdc_from_spi_int_2;
                              -- modf_strobe_cdc_from_spi_d1    <= modf_strobe_cdc_from_spi_int_2;
	               end if;
	         end if;
    end process MODF_STROBE_STRETCH_1_CDC;
	
	
	MODF_STROBE_SYNC_SPI_cdc_to_AXI_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => modf_strobe_cdc_from_spi_int_2,--modf_strobe_cdc_from_spi_d1 ,
        scndry_aclk          => Bus2IP_Clk ,
	    prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out            => modf_strobe_cdc_from_spi_d2--modf_strobe_cdc_to_axi
    );
	
	MODF_STROBE_STRETCH_1: process(Bus2IP_Clk)is
	    begin
	         if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
	               
	                       modf_strobe_cdc_from_spi_d3 <= modf_strobe_cdc_from_spi_d2 ;
	               
	         end if;
    end process MODF_STROBE_STRETCH_1;
    modf_strobe_cdc_to_axi <= modf_strobe_cdc_from_spi_d2 xor modf_strobe_cdc_from_spi_d3;
    ----------------------------------------------------------------------------------------------------------------
     
     SLAVE_MODF_STROBE_STRETCH_1_CDC: process(EXT_SPI_CLK)is
         begin
              if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                    if(Rst_from_axi_cdc_to_spi = '1') then
                            Slave_MODF_strobe_cdc_from_spi_int_2 <= '0';
    --                        Slave_MODF_strobe_cdc_from_spi_d1    <= '0';
                    else
                            Slave_MODF_strobe_cdc_from_spi_int_2 <= Slave_MODF_strobe_cdc_from_spi xor
                                                     Slave_MODF_strobe_cdc_from_spi_int_2;
     --                       Slave_MODF_strobe_cdc_from_spi_d1    <= Slave_MODF_strobe_cdc_from_spi_int_2;
                    end if;
              end if;
    end process SLAVE_MODF_STROBE_STRETCH_1_CDC;
	
     SLAVE_MODF_STROBE_SYNC_SPI_cdc_to_AXI_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => Slave_MODF_strobe_cdc_from_spi_int_2 ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => Slave_MODF_strobe_cdc_from_spi_d2
    ); 
    
         SLAVE_MODF_STROBE_STRETCH_1: process(Bus2IP_Clk)is
             begin
                  if(Bus2IP_Clk'event and Bus2IP_Clk= '1') then
                        
                                Slave_MODF_strobe_cdc_from_spi_d3 <= Slave_MODF_strobe_cdc_from_spi_d2 ;
         
                        
                  end if;
    end process SLAVE_MODF_STROBE_STRETCH_1;
       Slave_MODF_strobe_cdc_to_axi <= Slave_MODF_strobe_cdc_from_spi_d2 xor
                               Slave_MODF_strobe_cdc_from_spi_d3;  
    -----------------------------------------------------------------------------------------------------

     RECEIVE_DATA_SYNC_SPI_cdc_to_AXI_P_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 0 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => C_NUM_TRANSFER_BITS ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK,
        prmry_resetn         => Rst_from_axi_cdc_to_spi,
        prmry_vect_in        => receive_Data_cdc_from_spi,
        scndry_aclk          => Bus2IP_Clk,
        prmry_in               => '0',
        scndry_resetn        => Soft_Reset_op,
        scndry_vect_out      => receive_Data_cdc_to_axi
    );        
    -------------------------------------------------------------------------------------------------------
    DRR_OVERRUN_STRETCH_1: process(EXT_SPI_CLK)is
         begin
              if(EXT_SPI_CLK'event and EXT_SPI_CLK= '1') then
                    if(Rst_from_axi_cdc_to_spi = '1') then
                            drr_Overrun_int_cdc_from_spi_int_2 <= '0';
                    else
                            drr_Overrun_int_cdc_from_spi_int_2 <= drr_Overrun_int_cdc_from_spi xor
                                                          drr_Overrun_int_cdc_from_spi_int_2;
                    end if;
              end if;
         end process DRR_OVERRUN_STRETCH_1;
    
         DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_1: component FDR
                       generic map(INIT => '0'
                       )port map (
                                  Q  => drr_Overrun_int_cdc_from_spi_d1,
                                  C  => Bus2IP_Clk,
                                  D  => drr_Overrun_int_cdc_from_spi_int_2,
                                  R  => Soft_Reset_op
                                );
         DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_2: component FDR
                       generic map(INIT => '0'
                       )port map (
                                  Q  => drr_Overrun_int_cdc_from_spi_d2,
                                  C  => Bus2IP_Clk,
                                  D  => drr_Overrun_int_cdc_from_spi_d1,
                                  R  => Soft_Reset_op
                                );
         DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_3: component FDR
                       generic map(INIT => '0'
                       )port map (
                                  Q  => drr_Overrun_int_cdc_from_spi_d3,
                                  C  => Bus2IP_Clk,
                                  D  => drr_Overrun_int_cdc_from_spi_d2,
                                  R  => Soft_Reset_op
                                );
         DRR_OVERRUN_SYNC_SPI_cdc_to_AXI_4: component FDR
                       generic map(INIT => '0'
                       )port map (
                                  Q  => drr_Overrun_int_cdc_from_spi_d4,
                                  C  => Bus2IP_Clk,
                                  D  => drr_Overrun_int_cdc_from_spi_d3,
                                  R  => Soft_Reset_op
                                );                       
    drr_Overrun_int_cdc_to_axi <= drr_Overrun_int_cdc_from_spi_d4 xor drr_Overrun_int_cdc_from_spi_d3;
    
    
    
    -------------------------------------------------------------------------------------------------------

    
     DTR_UNDERRUN_SYNC_SPI_2_AXI_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 ,-- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_S2AXI 
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => Rst_from_axi_cdc_to_spi ,
        prmry_in             => dtr_underrun_cdc_from_spi ,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Soft_Reset_op ,
        scndry_out           => dtr_underrun_cdc_to_axi
    );
    -------------------------------------------------------------------------------------------------------
      
     SPICR_0_LOOP_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_0_LOOP_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
        prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_0_LOOP_cdc_to_spi
    );
    ------------------------------------------------------------------------------------------------------

	SPICR_1_SPE_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_1_SPE_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_1_SPE_cdc_to_spi
    );
	----------------------------------------------------------------------------------------------------
	
     
     SPICR_2_MST_N_SLV_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_2_MST_N_SLV_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_2_MST_N_SLV_cdc_to_spi
    );
     --------------------------------------------------------------------------------------------------
     
     SPICR_3_CPOL_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_3_CPOL_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
        prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_3_CPOL_cdc_to_spi
    );
    --------------------------------------------------------------------------------------------------
     
     SPICR_4_CPHA_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_4_CPHA_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_4_CPHA_cdc_to_spi
    );
    --------------------------------------------------------------------------------------------------
         
    SPICR_5_TXFIFO_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_5_TXFIFO_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
        prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_5_TXFIFO_cdc_to_spi
    );
    --------------------------------------------------------------------------------------------------
     
    SPICR_6_RXFIFO_RST_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_6_RXFIFO_RST_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_6_RXFIFO_RST_cdc_to_spi
    );
     --------------------------------------------------------------------------------------------------
     
     
    SPICR_7_SS_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_7_SS_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_7_SS_cdc_to_spi
    );
    --------------------------------------------------------------------------------------------------
        
    SPICR_8_TR_INHIBIT_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_8_TR_INHIBIT_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_8_TR_INHIBIT_cdc_to_spi
    );
     --------------------------------------------------------------------------------------------------
          
    SPICR_9_LSB_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SPICR_9_LSB_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
        prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SPICR_9_LSB_cdc_to_spi
    );
	-----------------------------------------------------------------------------------------------------
     
     TR_DATA_SYNC_AX2SP_GEN_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 0 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => C_NUM_TRANSFER_BITS ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk,
        prmry_resetn         => Soft_Reset_op,
        prmry_vect_in        => transmit_Data_cdc_from_axi,
        scndry_aclk          => EXT_SPI_CLK, 
	prmry_in             => '0' ,
        scndry_resetn        => Rst_from_axi_cdc_to_spi,
        scndry_vect_out      => transmit_Data_cdc_to_spi
    );        
	--------------------------------------------------------------------------------------------------
     
    SR_3_MODF_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => Soft_Reset_op ,
        prmry_in             => SR_3_modf_cdc_from_axi ,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => Rst_from_axi_cdc_to_spi ,
        scndry_out           => SR_3_modf_cdc_to_spi
    );
    -----------------------------------------------------------------------------------------------------

     SPISSR_SYNC_GEN_CDC: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 0 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => C_NUM_SS_BITS ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
		)

    port map (
        prmry_aclk           => Bus2IP_Clk,
        prmry_resetn         => Soft_Reset_op,
        prmry_vect_in        => SPISSR_cdc_from_axi,
        scndry_aclk          => EXT_SPI_CLK, 
	    prmry_in             => '0' ,
        scndry_resetn        => Rst_from_axi_cdc_to_spi,
        scndry_vect_out      => SPISSR_cdc_to_spi
    );
	---------------------------------------------
	
    
	
     SPICR_BITS_7_8_SYNC_GEN_CDC: for i in 1 downto 0 generate
     attribute ASYNC_REG : string;
     attribute ASYNC_REG of SPICR_BITS_7_8_AX2S_1_CDC : label is "TRUE";
     begin
    SPICR_BITS_7_8_AX2S_1_CDC: entity lib_cdc_v1_0_2.cdc_sync
    	    generic map (
    	        C_CDC_TYPE                  => 1 , -- 1 is level synch
    	        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
    	        C_SINGLE_BIT                => 1 , 
    	        C_FLOP_INPUT                => 0 ,
    	        C_VECTOR_WIDTH              => 1 ,
    	        C_MTBF_STAGES               => MTBF_STAGES_AXI2S 
    			)
    	
    	    port map (
	        	        prmry_aclk           => Bus2IP_Clk,
	        	        prmry_resetn         => Soft_Reset_op,
	        	        prmry_in             => SPICR_bits_7_8_cdc_from_axi(i),
	        	        scndry_aclk          => EXT_SPI_CLK, 
				prmry_vect_in        => (others => '0' ),
	        	        scndry_resetn        => Rst_from_axi_cdc_to_spi,
	        	        scndry_out           => SPICR_bits_7_8_cdc_from_axi_d2(i)
	    );
         -----------------------------------------
        end generate SPICR_BITS_7_8_SYNC_GEN_CDC;
	 	SPICR_bits_7_8_cdc_to_spi <= SPICR_bits_7_8_cdc_from_axi_d2; 	 	 
	end generate LOGIC_GENERATION_CDC;
end architecture imp;




-------------------------------------------------------------------------------
--  SPI Status Register Module - entity/architecture pair
-------------------------------------------------------------------------------
-- 
-- *******************************************************************
-- ** (c) Copyright [2010] - [2011] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        xip_status_reg.vhd
-- Version:         v3.0
-- Description:     Serial Peripheral Interface (SPI) Module for interfacing
--                  with a 32-bit AXI4 Bus. The file defines the logic for 
--                  status register in XIP mode.   
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.log2;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

library unisim;
    use unisim.vcomponents.FDRE;
-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------

-- C_SPI_NUM_BITS_REG              -- Width of SPI registers
-- C_S_AXI_DATA_WIDTH                -- Native data bus width 32 bits only
-- C_NUM_SS_BITS               -- Number of bits in slave select
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------

-- SYSTEM
--  Bus2IP_Clk                  --  Bus to IP clock
--  Soft_Reset_op                       --  Soft_Reset_op Signal

-- STATUS REGISTER RELATED SIGNALS
--================================
-- REGISTER/FIFO INTERFACE
-- Bus2IP_SPISR_RdCE      --  Status register Read Chip Enable
-- IP2Bus_SPISR_Data      --  Status register data to PLB based on PLB read

-- SR_3_modf                   --  Mode fault error status flag
-- SR_4_Tx_Full                --  Transmit register full status flag
-- SR_5_Tx_Empty               --  Transmit register empty status flag
-- SR_6_Rx_Full                --  Receive register full status flag
-- SR_7_Rx_Empty               --  Receive register empty stauts flag
-- ModeFault_Strobe            --  Mode fault strobe

-- SLAVE REGISTER RELATED SIGNALS
--===============================
-- Bus2IP_SPISSR_WrCE    -- slave select register write chip enable
-- Bus2IP_SPISSR_RdCE    -- slave select register read chip enable
-- Bus2IP_SPISSR_Data        -- slave register data from PLB Bus
-- IP2Bus_SPISSR_Data        -- Data from slave select register during PLB rd
-- SPISSR_Data_reg_op      -- Data to SPI Module
-- Wr_ce_reduce_ack_gen         -- commaon write ack generation signal
-- Rd_ce_reduce_ack_gen         -- commaon read ack generation signal

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity xip_status_reg is
    generic
    (
        C_S_AXI_DATA_WIDTH      : integer;       -- 32 bits
        ------------------------
        C_XIP_SPISR_REG_WIDTH       : integer
    );
    port
    (
       Bus2IP_Clk               : in  std_logic;
       Soft_Reset_op            : in  std_logic;
       --------------------------
       XIPSR_AXI_TR_ERR         : in std_logic; -- bit 4 of XIPSR
       XIPSR_CPHA_CPOL_ERR      : in std_logic; -- bit 3 of XIPSR
       XIPSR_MST_MODF_ERR       : in std_logic; -- bit 2 of XIPSR
       XIPSR_AXI_RX_FULL        : in std_logic; -- bit 1 of XIPSR
       XIPSR_AXI_RX_EMPTY 	    : in std_logic; -- bit 0 of XIPSR
       --------------------------
       Bus2IP_XIPSR_WrCE        : in std_logic;                             
       Bus2IP_XIPSR_RdCE        : in std_logic;
       --------------------------
       --IP2Bus_XIPSR_RdAck       : out std_logic;
       --IP2Bus_XIPSR_WrAck       : out std_logic;
       IP2Bus_XIPSR_Data        : out std_logic_vector((C_XIP_SPISR_REG_WIDTH-1) downto 0);
       ip2Bus_RdAck             : in std_logic
   );
end xip_status_reg;
-------------------------------------------------------------------------------
-- Architecture
---------------
architecture imp of xip_status_reg is
----------------------------------------------------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- Signal Declarations
----------------------
signal XIPSR_data_int                 : std_logic_vector(C_XIP_SPISR_REG_WIDTH-1 downto 0);
--signal ip2Bus_RdAck_core_reg          : std_logic;
--signal ip2Bus_RdAck_core_reg_d1       : std_logic;
--signal ip2Bus_WrAck_core_reg          : std_logic;
--signal ip2Bus_WrAck_core_reg_d1       : std_logic;
----------------------
begin
-----
-- XIPSR  - 31 -- -- 5 4                  3         2       1     0    
--          <-- NA --> AXI                CPOL_CPHA MODF    Rx    Rx   
--                     Transaction Error  Error     Error   Full  Empty
-- Default             0                  0	    0       0     0    
-------------------------------------------------------------------------------
--XIPSR_CMD_ERR <= '0';
---------------------------------------
XIPSR_DATA_STORE_P:process(Bus2IP_Clk)is
begin
-----
     if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
         if(Soft_Reset_op = RESET_ACTIVE) then
             XIPSR_data_int((C_XIP_SPISR_REG_WIDTH-1) downto 0)<= (others => '0');
	 elsif(ip2Bus_RdAck = '1') then
             XIPSR_data_int((C_XIP_SPISR_REG_WIDTH-1) downto 0)<= (others => '0');
         else
             XIPSR_data_int((C_XIP_SPISR_REG_WIDTH-1) downto 0) 
	                   <= XIPSR_AXI_TR_ERR     & -- bit 4
			              XIPSR_CPHA_CPOL_ERR  & 
			              XIPSR_MST_MODF_ERR   &
			              XIPSR_AXI_RX_FULL    &
			              XIPSR_AXI_RX_EMPTY   ; -- bit 0
         end if;
     end if;
end process XIPSR_DATA_STORE_P;
--------------------------------------------------
XIPSR_REG_RD_GENERATE: for i in C_XIP_SPISR_REG_WIDTH-1 downto 0 generate
-----
begin
-----
    IP2Bus_XIPSR_Data(i) <= XIPSR_data_int(i) and Bus2IP_XIPSR_RdCE ; --and ip2Bus_RdAck_core_reg;
end generate XIPSR_REG_RD_GENERATE;
-----------------------------------
---------------------------------------------------------------------------------
end imp;
--------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- xip_cntrl_reg.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        xip_cntrl_reg.vhd
-- Version:         v3.0
-- Description:     control register module for axi quad spi in XIP mode.
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_unsigned.all;
    use ieee.numeric_std.all;
    use ieee.std_logic_misc.all;

use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

--library unisim;
--    use unisim.vcomponents.FDRE;
-------------------------------------------------------------------------------
--                     Definition of Generics
-------------------------------------------------------------------------------

--  C_S_AXI_DATA_WIDTH                --      Width of the slave data bus
--  C_XIP_SPICR_REG_WIDTH                 --      Width of SPI registers

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--                  Definition of Ports
-------------------------------------------------------------------------------

-- SYSTEM

--  Bus2IP_Clk                  --      Bus to IP clock
--  Soft_Reset_op               --      Soft_Reset_op Signal

-- SLAVE ATTACHMENT INTERFACE
--  Wr_ce_reduce_ack_gen  --      common write ack generation logic input
--  Bus2IP_XIPCR_data     --      Data written from the PLB bus
--  Bus2IP_XIPCR_WrCE     --      Write CE for control register
--  Bus2IP_XIPCR_RdCE     --      Read CE for control register
--  IP2Bus_XIPCR_Data     --      Data to be send on the bus

-- SPI MODULE INTERFACE
--  Control_Register_Data       --      Data to be send on the bus
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Entity Declaration
-------------------------------------------------------------------------------
entity xip_cntrl_reg is
      generic
      (
      ----------------------------
      C_S_AXI_DATA_WIDTH         : integer;       -- 32 bits
      ----------------------------
      -- Number of bits in register,10 for control reg - 8 for cmd + 2 CPOL/CPHA
      C_XIP_SPICR_REG_WIDTH          : integer;
      ----------------------------
      C_SPI_MODE                 : integer
      ----------------------------
      );
      port
      (
      Bus2IP_Clk                : in  std_logic;
      Soft_Reset_op             : in  std_logic;

      -- Slave attachment ports
      Bus2IP_XIPCR_WrCE         : in  std_logic;
      Bus2IP_XIPCR_RdCE         : in  std_logic;
      Bus2IP_XIPCR_data         : in  std_logic_vector((C_S_AXI_DATA_WIDTH-1) downto 0);

      ip2Bus_RdAck_core         : in  std_logic;
      ip2Bus_WrAck_core         : in  std_logic;

      XIPCR_1_CPOL              : out std_logic;
      XIPCR_0_CPHA              : out std_logic;
      --------------------------
      IP2Bus_XIPCR_Data         : out std_logic_vector((C_XIP_SPICR_REG_WIDTH-1) downto 0);
      --------------------------
      TO_XIPSR_CPHA_CPOL_ERR    : out std_logic
      );
end xip_cntrl_reg;

-------------------------------------------------------------------------------
-- Architecture
--------------------------------------
architecture imp of xip_cntrl_reg is
-------------------------------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- Signal Declarations
----------------------
signal XIPCR_data_int                 : std_logic_vector((C_XIP_SPICR_REG_WIDTH-1) downto 0);
         
-----
begin
-----
---------------------------------------
XIPCR_CPHA_CPOL_STORE_P:process(Bus2IP_Clk)is
begin
-----
     if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
         if(Soft_Reset_op = RESET_ACTIVE) then
             XIPCR_data_int((C_XIP_SPICR_REG_WIDTH-1) downto (C_XIP_SPICR_REG_WIDTH-C_XIP_SPICR_REG_WIDTH)) 
                           <= "00";
         elsif(ip2Bus_WrAck_core = '1') and (Bus2IP_XIPCR_WrCE = '1')then
             XIPCR_data_int((C_XIP_SPICR_REG_WIDTH-1) downto (0)) 
                           <= Bus2IP_XIPCR_data
                           ((C_XIP_SPICR_REG_WIDTH-1) downto (0));
         end if;
     end if;
end process XIPCR_CPHA_CPOL_STORE_P;
------------------------------------

XIPCR_1_CPOL <=	XIPCR_data_int(C_XIP_SPICR_REG_WIDTH-1);
XIPCR_0_CPHA <= XIPCR_data_int(0);
XIPCR_REG_RD_GENERATE: for i in C_XIP_SPICR_REG_WIDTH-1 downto 0 generate
-----
begin
-----
    IP2Bus_XIPCR_Data(i) <= XIPCR_data_int(i) and Bus2IP_XIPCR_RdCE;
end generate XIPCR_REG_RD_GENERATE;
-----------------------------------

TO_XIPSR_CPHA_CPOL_ERR <= (XIPCR_data_int(C_XIP_SPICR_REG_WIDTH-1)) xor 
                          (XIPCR_data_int(C_XIP_SPICR_REG_WIDTH-C_XIP_SPICR_REG_WIDTH));
end imp;
--------------------------------------------------------------------------------


-------------------------------------------------------------------------------
--  qspi_core_interface Module - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        qspi_core_interface.vhd
-- Version:         v3.0
-- Description:     Serial Peripheral Interface (SPI) Module for interfacing
--                  with a 32-bit AXI bus.
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_unsigned.all;
    use ieee.numeric_std.all;
    use ieee.std_logic_misc.all;

use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

Library UNISIM;
use UNISIM.vcomponents.all;

library axi_lite_ipif_v3_0_4;
use axi_lite_ipif_v3_0_4.axi_lite_ipif;
use axi_lite_ipif_v3_0_4.ipif_pkg.all;
library lib_fifo_v1_0_6;
    use lib_fifo_v1_0_6.async_fifo_fg;
library lib_srl_fifo_v1_0_2;
    use lib_srl_fifo_v1_0_2.srl_fifo_f;
	
library lib_cdc_v1_0_2;
	use lib_cdc_v1_0_2.cdc_sync;
library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.log2;
   -- use lib_pkg_v1_0_2.lib_pkg.clog2;
    use lib_pkg_v1_0_2.lib_pkg.max2;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;



library interrupt_control_v3_1_4;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
-------------------------------------------------------------------------------

entity qspi_core_interface is
generic(
        C_FAMILY              : string;
        C_SUB_FAMILY          : string;
        C_SELECT_XPM          : integer := 1;
        C_UC_FAMILY           : integer;
        C_S_AXI_DATA_WIDTH    : integer;
        Async_Clk             : integer;
        ----------------------
        -- local parameters
        C_NUM_CE_SIGNALS      : integer;
        ----------------------
        -- SPI parameters
        --C_AXI4_CLK_PS         : integer;
        --C_EXT_SPI_CLK_PS      : integer;
        C_FIFO_DEPTH          : integer;
        C_SCK_RATIO           : integer;
        C_NUM_SS_BITS         : integer;
        C_NUM_TRANSFER_BITS   : integer;
        C_SPI_MODE            : integer;
        C_USE_STARTUP         : integer;
        C_SPI_MEMORY          : integer;
        C_SHARED_STARTUP    : integer range 0 to 1 := 0;
        C_TYPE_OF_AXI4_INTERFACE : integer;
        ----------------------
        -- local constants
        C_FIFO_EXIST          : integer;
        C_SPI_NUM_BITS_REG    : integer;
        C_OCCUPANCY_NUM_BITS  : integer;
        ----------------------
        -- local constants
        C_IP_INTR_MODE_ARRAY  : INTEGER_ARRAY_TYPE;
        ----------------------
        -- local constants
        C_SPICR_REG_WIDTH     : integer;
        C_SPISR_REG_WIDTH     : integer;
        C_LSB_STUP            : integer;
        C_DUAL_MODE           : integer;
        C_STARTUP_EXT         : integer
       );
   port(
        EXT_SPI_CLK      : in std_logic;
        ------------------------------------------------
        Bus2IP_Clk       : in std_logic;
        Bus2IP_Reset     : in std_logic;
        ------------------------------------------------
        Bus2IP_BE        : in std_logic_vector(0 to ((C_S_AXI_DATA_WIDTH/8)-1));
        Bus2IP_RdCE      : in std_logic_vector(0 to (C_NUM_CE_SIGNALS-1));
        Bus2IP_WrCE      : in std_logic_vector(0 to (C_NUM_CE_SIGNALS-1));
        Bus2IP_Data      : in std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1));
        ------------------------------------------------
        IP2Bus_Data      : out std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1));
        IP2Bus_WrAck     : out std_logic;
        IP2Bus_RdAck     : out std_logic;
        IP2Bus_Error     : out std_logic;
        ------------------------------------------------
        burst_tr         : in std_logic;
        rready           : in std_logic;
        WVALID           : in std_logic;
        --SPI Ports
        SCK_I            : in  std_logic;
        SCK_O            : out std_logic;
        SCK_T            : out std_logic;
        ------------------------------------------------
        IO0_I            : in  std_logic;
        IO0_O            : out std_logic;
        IO0_T            : out std_logic;
        ------------------------------------------------
        IO1_I            : in  std_logic;
        IO1_O            : out std_logic;
        IO1_T            : out std_logic;
        ------------------------------------------------
        IO2_I            : in  std_logic;
        IO2_O            : out std_logic;
        IO2_T            : out std_logic;
        ------------------------------------------------
        IO3_I            : in  std_logic;
        IO3_O            : out std_logic;
        IO3_T            : out std_logic;
        ------------------------------------------------
        SPISEL           : in  std_logic;
        ------------------------------------------------
        SS_I             : in  std_logic_vector((C_NUM_SS_BITS-1) downto C_LSB_STUP);
        SS_O             : out std_logic_vector((C_NUM_SS_BITS-1) downto C_LSB_STUP);
        SS_T             : out std_logic;
        ------------------------------------------------
        IP2INTC_Irpt     : out std_logic;
        ------------------------------------------------
	   ------------------------
	   -- STARTUP INTERFACE
	   ------------------------
	   cfgclk  : out std_logic;       -- FGCLK        , -- 1-bit output: Configuration main clock output
       cfgmclk : out std_logic; -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
       eos     : out std_logic;  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
       preq    : out std_logic; -- REQ          , -- 1-bit output: PROGRAM request to fabric output
       di      : out std_logic_vector(1 downto 0); 	   -- output
       dts      : in std_logic_vector(1 downto 0); 	   -- input
       do      : in std_logic_vector(1 downto 0); 	   -- input
      -- fcsbo   : in std_logic;   -- input
      -- fcsbts  : in std_logic;   -- input
       clk     : in std_logic;   -- input
       gsr     : in std_logic;   -- input
       gts     : in std_logic;   -- input
       keyclearb : in std_logic;   -- input
       pack     : in std_logic;   -- input
       usrcclkts : in std_logic;   -- input
       usrdoneo : in std_logic;   -- input
       usrdonets : in std_logic   -- input
       );

end entity qspi_core_interface;

-------------------------------------------------------------------------------
------------
architecture imp of qspi_core_interface is
------------

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

-- function definition
----------------------
function clog2(x : positive) return natural is
  variable r  : natural := 0;
  variable rp : natural := 1; -- rp tracks the value 2**r
begin 
  while rp < x loop -- Termination condition T: x <= 2**r
    -- Loop invariant L: 2**(r-1) < x
    r := r + 1;
    if rp > integer'high - rp then exit; end if;  -- If doubling rp overflows
      -- the integer range, the doubled value would exceed x, so safe to exit.
    rp := rp + rp;
  end loop;
  -- L and T  <->  2**(r-1) < x <= 2**r  <->  (r-1) < log2(x) <= r
  return r; --
end clog2;

-------------------------------------------------------------------------------
-- constant definition

constant NEW_LOGIC : integer := 0;
-- These constants are indices into the "CE" arrays for the various registers.
 constant INTR_LO  : natural :=  0;
 constant INTR_HI  : natural := 15;
 constant SWRESET  : natural := 16;    -- at address C_BASEADDR + 40 h
 constant SPICR    : natural := 24; -- 17;    -- at address C_BASEADDR + 60 h
 constant SPISR    : natural := 25; -- 18;
 constant SPIDTR   : natural := 26; -- 19;
 constant SPIDRR   : natural := 27; -- 20;
 constant SPISSR   : natural := 28; -- 21;
 constant SPITFOR  : natural := 29; -- 22;
 constant SPIRFOR  : natural := 30; -- 23;    -- at address C_BASEADDR + 78 h

 constant REG_HOLE : natural := 31; -- 24;    -- at address C_BASEADDR + 7C h
 --Startup Signals
signal str_IO0_I : std_logic;
signal str_IO0_O : std_logic;
signal str_IO0_T : std_logic;
signal str_IO1_I : std_logic;
signal str_IO1_O : std_logic;
signal str_IO1_T : std_logic;
signal di_int  : std_logic_vector(3 downto 0); 	   -- output
signal di_int_sync  : std_logic_vector(3 downto 0); 	   -- output
signal dts_int : std_logic_vector(3 downto 0); 	   -- input
signal do_int  : std_logic_vector(3 downto 0); 	   -- input

 
 
 --SPI MODULE SIGNALS
 signal spiXfer_done_int         : std_logic;
 signal dtr_underrun_int         : std_logic;
 signal modf_strobe_int          : std_logic;
 signal slave_MODF_strobe_int    : std_logic;

 --OR REGISTER/FIFO SIGNALS
 --TO/FROM REG/FIFO DATA
 signal receive_Data_int       : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
 signal transmit_Data_int      : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

 --Extra bit required for signal Register_Data_ctrl
 signal register_Data_cntrl_int :std_logic_vector(0 to (C_SPI_NUM_BITS_REG+1));
 signal register_Data_slvsel_int:std_logic_vector(0 to (C_NUM_SS_BITS-1));

 signal IP2Bus_SPICR_Data_int  :std_logic_vector(0 to (C_SPICR_REG_WIDTH-1));
 signal IP2Bus_SPISR_Data_int  :std_logic_vector(0 to (C_SPISR_REG_WIDTH-1));

 signal IP2Bus_Receive_Reg_Data_int :std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
 signal IP2Bus_Data_received_int:
                                  std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1));
 signal IP2Bus_SPISSR_Data_int  : std_logic_vector(0 to (C_NUM_SS_BITS-1));
 signal IP2Bus_Tx_FIFO_OCC_Reg_Data_int:
                                std_logic_vector(0 to (C_OCCUPANCY_NUM_BITS-1));

 signal IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1:
                            std_logic_vector((C_OCCUPANCY_NUM_BITS-1) downto 0);
 signal IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1:
                            std_logic_vector((C_OCCUPANCY_NUM_BITS-1) downto 0);


 signal IP2Bus_Rx_FIFO_OCC_Reg_Data_int:
                                std_logic_vector(0 to (C_OCCUPANCY_NUM_BITS-1));

 --STATUS REGISTER SIGNALS
 signal sr_3_MODF_int            : std_logic;
 signal Tx_FIFO_Full_int         : std_logic;
 signal sr_5_Tx_Empty_int        : std_logic;
 signal tx_empty_signal_handshake_req        : std_logic;
 signal tx_empty_signal_handshake_gnt        : std_logic;
 signal sr_6_Rx_Full_int         : std_logic;
 signal Rc_FIFO_Empty_int        : std_logic;

 --RECEIVE AND TRANSMIT REGISTER SIGNALS
 signal drr_Overrun_int          : std_logic;
 signal dtr_Underrun_strobe_int  : std_logic;
 --FIFO SIGNALS
 signal rc_FIFO_Full_strobe_int  : std_logic;
 signal rc_FIFO_occ_Reversed_int :std_logic_vector
                                                ((C_OCCUPANCY_NUM_BITS-1) downto 0);
 signal rc_FIFO_occ_Reversed_int_2 :std_logic_vector
                                            ((C_OCCUPANCY_NUM_BITS-1) downto 0);

 signal rc_FIFO_Data_Out_int     : std_logic_vector
                                            (0 to (C_NUM_TRANSFER_BITS-1));

 signal sr_6_Rx_Full_int_1       : std_logic;
 signal FIFO_Empty_rx_1          : std_logic;
 signal FIFO_Empty_rx            : std_logic;

 signal data_Exists_RcFIFO_int   : std_logic;
 signal tx_FIFO_Empty_strobe_int : std_logic;
 signal tx_FIFO_occ_Reversed_int : std_logic_vector
                                            ((C_OCCUPANCY_NUM_BITS-1) downto 0);
 signal tx_FIFO_occ_Reversed_int_2 : std_logic_vector
                                            ((C_OCCUPANCY_NUM_BITS-1) downto 0);

 signal data_Exists_TxFIFO_int   : std_logic;
 signal data_Exists_TxFIFO_int_1 : std_logic;

 signal data_From_TxFIFO_int     : std_logic_vector
                                                 (0 to (C_NUM_TRANSFER_BITS-1));
 signal tx_FIFO_less_half_int    : std_logic;

 signal Tx_FIFO_Full_int_1       : std_logic;
 signal FIFO_Empty_tx            : std_logic;
 signal data_From_TxFIFO_int_1   : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

 signal tx_occ_msb               : std_logic;
 signal tx_occ_msb_1             : std_logic:= '0';
 signal tx_occ_msb_2             : std_logic;
 signal tx_occ_msb_3             : std_logic;
 signal tx_occ_msb_4             : std_logic;

 signal reset_TxFIFO_ptr_int     : std_logic;
 signal reset_TxFIFO_ptr_int_to_spi     : std_logic;
 signal reset_RcFIFO_ptr_int     : std_logic;
 signal reset_RcFIFO_ptr_to_spi_clk : std_logic;
 signal ip2Bus_Data_Reg_int      : std_logic_vector
                                                  (0 to (C_S_AXI_DATA_WIDTH-1));
 signal ip2Bus_Data_occupancy_int: std_logic_vector
                                                  (0 to (C_S_AXI_DATA_WIDTH-1));
 signal ip2Bus_Data_SS_int       : std_logic_vector
                                                  (0 to (C_S_AXI_DATA_WIDTH-1));

 -- interface between signals on instance basis
 signal bus2IP_Reset_int         : std_logic;

 signal bus2IP_Data_for_interrupt_core  : std_logic_vector
                                                    (0 to C_S_AXI_DATA_WIDTH-1);

 signal ip2Bus_Error_int         : std_logic;
 signal ip2Bus_WrAck_int         : std_logic;-- := '0';
 signal ip2Bus_RdAck_int         : std_logic;-- := '0';
 signal ip2Bus_IntrEvent_int     : std_logic_vector
                                         (0 to (C_IP_INTR_MODE_ARRAY'length-1));
 signal transmit_ip2bus_error    : std_logic;
 signal receive_ip2bus_error     : std_logic;

 -- SOFT RESET SIGNALS
 signal reset2ip_reset_int       : std_logic;
 signal rst_ip2bus_wrack         : std_logic;
 signal rst_ip2bus_error         : std_logic;
 signal rst_ip2bus_rdack         : std_logic;

 -- INTERRUPT SIGNALS
 signal intr_ip2bus_data         : std_logic_vector
                                                  (0 to (C_S_AXI_DATA_WIDTH-1));
 signal intr_ip2bus_rdack        : std_logic;
 signal intr_ip2bus_wrack        : std_logic;
 signal intr_ip2bus_error        : std_logic;
 signal ip2bus_error_RdWr        : std_logic;
 --

 signal wr_ce_reduce_ack_gen: std_logic;
 --
 signal rd_ce_reduce_ack_gen     : std_logic;
 --
 signal control_bit_7_8_int      : std_logic_vector(0 to 1);
 signal spisel_pulse_o_int       : std_logic;
 signal Interrupt_WrCE_sig      : std_logic_vector(0 to 1);
 signal IPIF_Lvl_Interrupts_sig       : std_logic;
 signal spisel_d1_reg            : std_logic;
 signal Mst_N_Slv_mode           : std_logic;
-----
 signal bus2ip_intr_rdce         : std_logic_vector(INTR_LO to INTR_HI);
 signal bus2ip_intr_wrce         : std_logic_vector(INTR_LO to INTR_HI);

 signal ip2Bus_RdAck_intr_reg_hole      : std_logic;
 signal ip2Bus_RdAck_intr_reg_hole_d1   : std_logic;
 signal ip2Bus_WrAck_intr_reg_hole      : std_logic;
 signal ip2Bus_WrAck_intr_reg_hole_d1   : std_logic;
 signal intr_controller_rd_ce_or_reduce : std_logic;
 signal intr_controller_wr_ce_or_reduce : std_logic;

 signal wr_ce_or_reduce_core_cmb        : std_logic;
 signal ip2Bus_WrAck_core_reg_d1        : std_logic;
 signal ip2Bus_WrAck_core_reg           : std_logic;

 signal rd_ce_or_reduce_core_cmb        : std_logic;
 signal ip2Bus_RdAck_core_reg_d1        : std_logic;
 signal ip2Bus_RdAck_core_reg           : std_logic;

 signal SPISR_0_CMD_Error_int           : std_logic;
 signal SPISR_1_LOOP_Back_Error_int     : std_logic;
 signal SPISR_2_MSB_Error_int           : std_logic;
 signal SPISR_3_Slave_Mode_Error_int    : std_logic;
 signal SPISR_4_CPOL_CPHA_Error_int     : std_logic;
 signal SPISR_Ext_SPISEL_slave_int      : std_logic;

 signal SPICR_5_TXFIFO_RST_int          : std_logic;
-- signal SPICR_6_RXFIFO_RST_int          : std_logic;


 signal pr_state_idle_int              : std_logic;
 signal Quad_Phase_int                 : std_logic;

signal SPICR_0_LOOP_frm_axi      :std_logic;
signal SPICR_0_LOOP_to_spi       :std_logic;

signal SPICR_1_SPE_frm_axi       :std_logic;
signal SPICR_1_SPE_to_spi        :std_logic;

signal SPICR_2_MST_N_SLV_frm_axi :std_logic;
signal SPICR_2_MST_N_SLV_to_spi  :std_logic;

signal SPICR_3_CPOL_frm_axi      :std_logic;
signal SPICR_3_CPOL_to_spi       :std_logic;

signal SPICR_4_CPHA_frm_axi      :std_logic;
signal SPICR_4_CPHA_to_spi       :std_logic;

signal SPICR_5_TXFIFO_frm_axi    :std_logic;
signal SPICR_5_TXFIFO_to_spi     :std_logic;

--signal SPICR_6_RXFIFO_RST_frm_axi:std_logic;
--signal SPICR_6_RXFIFO_RST_to_spi :std_logic;

signal SPICR_7_SS_frm_axi        :std_logic;
signal SPICR_7_SS_to_spi         :std_logic;

signal SPICR_8_TR_INHIBIT_frm_axi:std_logic;
signal SPICR_8_TR_INHIBIT_to_spi :std_logic;

signal SPICR_9_LSB_frm_axi       :std_logic;
signal SPICR_9_LSB_to_spi        :std_logic;

signal SPICR_bits_7_8_frm_spi    :std_logic;
signal SPICR_bits_7_8_to_axi     :std_logic;

signal Rx_FIFO_Empty                  : std_logic;
signal Rx_FIFO_Empty_Synced_in_SPI_domain                  : std_logic;
signal rx_fifo_full_to_spi_clk        : std_logic;
signal tx_fifo_empty_to_axi_clk       : std_logic;
signal tx_fifo_full                   : std_logic;
signal spisel_d1_reg_to_axi_clk       : std_logic;
signal spicr_bits_7_8_frm_axi_clk     : std_logic_vector(1 downto 0);
signal spicr_8_tr_inhibit_to_spi_clk  : std_logic;
signal spicr_9_lsb_to_spi_clk         : std_logic;
signal spicr_bits_7_8_to_spi_clk      : std_logic_vector(0 to 1);
signal spicr_0_loop_frm_axi_clk       : std_logic;
signal spicr_1_spe_frm_axi_clk        : std_logic;
signal spicr_2_mst_n_slv_frm_axi_clk  : std_logic;
signal spicr_3_cpol_frm_axi_clk       : std_logic;
signal spicr_4_cpha_frm_axi_clk       : std_logic;
signal spicr_5_txfifo_rst_frm_axi_clk : std_logic;
signal spicr_6_rxfifo_rst_frm_axi_clk : std_logic;
signal spicr_7_ss_frm_axi_clk         : std_logic;
signal spicr_8_tr_inhibit_frm_axi_clk : std_logic;
signal spicr_9_lsb_frm_axi_clk        : std_logic;



signal Tx_FIFO_wr_ack_1 : std_logic;
signal rst_to_spi_int                 : std_logic;

signal spicr_0_loop_to_spi_clk        : std_logic;
signal spicr_1_spe_to_spi_clk         : std_logic;
signal spicr_2_mas_n_slv_to_spi_clk    : std_logic;
signal spicr_3_cpol_to_spi_clk        : std_logic;
signal spicr_4_cpha_to_spi_clk        : std_logic;
signal spicr_5_txfifo_rst_to_spi_clk   : std_logic;
signal spicr_6_rxfifo_rst_to_spi_clk   : std_logic;
signal spicr_7_ss_to_spi_clk          : std_logic;

signal sr_3_modf_to_spi_clk           : std_logic;
signal sr_3_modf_frm_axi_clk          : std_logic;

signal data_from_txfifo               : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));

signal Bus2IP_WrCE_d1 : std_logic;
signal Bus2IP_WrCE_d2 : std_logic;
signal Bus2IP_WrCE_d3 : std_logic;

signal Bus2IP_WrCE_pulse_1 : std_logic;
signal Bus2IP_WrCE_pulse_2 : std_logic;
signal Bus2IP_WrCE_pulse_3 : std_logic;


signal data_to_txfifo                 : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal tx_fifo_wr_ack                 : std_logic;
-- signal ext_spi_clk                 : std_logic;

signal tx_fifo_rd_ack_open            : std_logic;

signal tx_fifo_empty                  : std_logic;
signal tx_fifo_almost_full            : std_logic;
signal tx_fifo_almost_empty           : std_logic;
signal tx_fifo_occ_reversed           : std_logic_vector((C_OCCUPANCY_NUM_BITS-1) downto 0);
signal c_wr_count_width               : std_logic;


signal rx_fifo_wr_ack_open            : std_logic;
signal data_from_rx_fifo              : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal rx_fifo_rd_ack                 : std_logic;
signal rx_fifo_full                   : std_logic;

signal rx_fifo_almost_full            : std_logic;
signal rx_fifo_almost_empty           : std_logic;
signal rx_fifo_occ_reversed           : std_logic_vector((C_OCCUPANCY_NUM_BITS-1) downto 0);


signal SPISSR_frm_axi_clk : std_logic_vector(0 to (C_NUM_SS_BITS-1));
signal modf_strobe_frm_spi_clk : std_logic;
signal modf_strobe_to_axi_clk  : std_logic;
signal dtr_underrun_frm_spi_clk : std_logic;
signal dtr_underrun_to_axi_clk  : std_logic;

signal data_to_rx_fifo                : std_logic_vector
                                                 (0 to (C_NUM_TRANSFER_BITS-1));
signal spisel_d1_reg_frm_spi_clk : std_logic;

signal Mst_N_Slv_mode_frm_spi_clk: std_logic;
signal Mst_N_Slv_mode_to_axi_clk : std_logic;
signal SPICR_2_MST_N_SLV_to_spi_clk : std_logic;
signal spicr_5_txfifo_frm_axi_clk : std_logic;
signal spicr_5_txfifo_to_spi_clk: std_logic;
signal reset_RcFIFO_ptr_frm_axi_clk : std_logic;
-- signal reset_RcFIFO_ptr_to_spi_clk  : std_logic;
signal Data_To_Rx_FIFO_1    : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal SPIXfer_done_Rx_Wr_en, SPIXfer_done_rd_tx_en: std_logic;

signal Tx_FIFO_Empty_SPISR_frm_spi_clk : std_logic;
signal Tx_FIFO_Empty_SPISR_to_axi_clk  : std_logic;
signal Tx_FIFO_Empty_frm_spi_clk    : std_logic;
signal Rx_FIFO_Full_frm_axi_clk : std_logic;
signal Rx_FIFO_Full_int,Rx_FIFO_Full_i,RX_one_less_than_full, not_Tx_FIFO_FULL : std_logic;
signal updown_cnt_en_tx, updown_cnt_en_rx : std_logic;
signal TX_one_less_than_full : std_logic;
signal tx_cntr_xfer_done : std_logic;
   signal Tx_FIFO_one_less_to_Empty, Tx_FIFO_Full_i: std_logic;
   signal Tx_FIFO_Empty_i, Tx_FIFO_Empty_int : std_logic;
   signal Tx_FIFO_Empty_frm_axi_clk : std_logic;
   signal rx_fifo_empty_i : std_logic;
   signal Rx_FIFO_Empty_int : std_logic;
signal IP2Bus_WrAck_1 : std_logic;
signal ip2Bus_WrAck_core_reg_1 : std_logic;
signal IP2Bus_RdAck_1 : std_logic;
signal ip2Bus_RdAck_core_reg_1 : std_logic;
signal IP2Bus_Error_1 : std_logic;
signal ip2Bus_Data_1 : std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1)) ;

signal SPISR_0_CMD_Error_frm_spi_clk : std_logic;
signal SPISR_0_CMD_Error_to_axi_clk  : std_logic;

signal rx_fifo_reset, tx_fifo_reset : std_logic;
signal reg_hole_wr_ack: std_logic;
signal reg_hole_rd_ack: std_logic;

signal read_ack_delay_1: std_logic;
signal read_ack_delay_2: std_logic;
signal read_ack_delay_3: std_logic;
signal read_ack_delay_4: std_logic;
signal read_ack_delay_5: std_logic;
signal read_ack_delay_6: std_logic;
signal read_ack_delay_7: std_logic;
signal read_ack_delay_8: std_logic;

signal write_ack_delay_1: std_logic;
signal write_ack_delay_2: std_logic;
signal write_ack_delay_3: std_logic;
signal write_ack_delay_4: std_logic;
signal write_ack_delay_5: std_logic;
signal write_ack_delay_6: std_logic;
signal write_ack_delay_7: std_logic;
signal write_ack_delay_8: std_logic;

signal error_ack_delay_1: std_logic;
signal error_ack_delay_2: std_logic;
signal error_ack_delay_3: std_logic;
signal error_ack_delay_4: std_logic;
signal error_ack_delay_5: std_logic;
signal error_ack_delay_6: std_logic;
signal error_ack_delay_7: std_logic;
signal error_ack_delay_8: std_logic;
signal IO2_O_int  : std_logic;
signal IO2_T_int  : std_logic;

signal IO3_O_int  : std_logic;
signal IO3_T_int  : std_logic;
signal IO2_I_int  : std_logic;
signal IO3_I_int  : std_logic;
signal fcsbo_int  : std_logic;
signal SS_O_int  : std_logic_vector((C_NUM_SS_BITS-1) downto 0);
signal SS_T_int  : std_logic;
signal SS_I_int  : std_logic_vector((C_NUM_SS_BITS-1) downto 0);
signal fcsbts_int  : std_logic;
----RX_FIFO_FULL Logic signals
signal Rx_FIFO_Full_Fifo_org : std_logic;
signal Rx_FIFO_Full_Fifo : std_logic;
signal Rx_FIFO_Full_Fifo_d1 : std_logic;
signal Rx_FIFO_Full_Fifo_d1_synced : std_logic;
signal Rx_FIFO_Full_Fifo_d1_synced_i : std_logic;
signal Rx_FIFO_Full_Fifo_d1_flag : std_logic;
signal Rx_FIFO_Full_Fifo_pos_flag : std_logic;
signal Rx_FIFO_Full_Fifo_d1_sig : std_logic;
--------------------------------------------------------------------------------
begin
-----
DATA_STARTUP_EN : if (C_USE_STARTUP = 1 and C_UC_FAMILY = 1)
generate
   -----
    begin
   -----
---
    DI_INT_IO3_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => di_int_sync(3),
          C  => EXT_SPI_CLK,
          D  => di_int(3) --MOSI_I
          );
     DI_INT_IO2_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => di_int_sync(2),
          C  => EXT_SPI_CLK,
          D  => di_int(2) -- MISO_I
          );
     DI_INT_IO1_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => di_int_sync(1),
            C  => EXT_SPI_CLK,
            D  => di_int(1)
            );
     -----------------------
     DI_INT_IO0_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => di_int_sync(0),
            C  => EXT_SPI_CLK,
            D  => di_int(0)
            );
     
        
---
fcsbo_int <= SS_O_int(0);  
fcsbts_int <= SS_T_int;  
NUM_SS : if (C_NUM_SS_BITS = 1) generate
begin
SS_O <= (others => '0');
SS_T <= '0';
end generate NUM_SS;
NUM_SS_G1 : if (C_NUM_SS_BITS > 1) generate
begin

SS_I_int <= SS_I((C_NUM_SS_BITS-1) downto 1) & '1';
SS_O <= SS_O_int((C_NUM_SS_BITS-1) downto 1);
SS_T <= SS_T_int;

end generate NUM_SS_G1;
str_IO0_I <= di_int_sync(0);
do_int(0) <= str_IO0_O;
dts_int(0) <= str_IO0_T ;
str_IO1_I <= di_int_sync(1);
do_int(1) <= str_IO1_O;
dts_int(1) <= str_IO1_T;

DATA_OUT_NQUAD: if C_SPI_MODE = 0 or C_SPI_MODE = 1 generate
begin
di <= di_int_sync(3) & di_int_sync(2);
do_int(2) <= do(0);
do_int(3) <= do(1);
dts_int(2) <= dts(0);
dts_int(3) <= dts(1);
--do <= do_int(3) & do_int(1);
--dts <= dts_int(3) & dts_int(1);
end generate DATA_OUT_NQUAD;
DATA_OUT_QUAD: if C_SPI_MODE = 2 generate
begin
--di <= "00";--di_int_sync(3) & di_int_sync(2);
IO2_I_int <= di_int_sync(2);
do_int(2) <= IO2_O_int;--do(2);
do_int(3) <= IO3_O_int;--do(1);
--do <= do_int(3) & do_int(1);
IO3_I_int <= di_int_sync(3);
dts_int(2) <= IO2_T_int;--dts_int(3) & dts_int(1);
dts_int(3) <= IO3_T_int;--dts_int(3) & dts_int(1);
end generate DATA_OUT_QUAD;
end generate DATA_STARTUP_EN;

DATA_STARTUP_DIS : if (C_USE_STARTUP = 0 or (C_USE_STARTUP = 1 and C_UC_FAMILY = 0)) 
generate
   -----
    begin
   -----
str_IO0_I <= IO0_I;
IO0_O <= str_IO0_O;
IO0_T <= str_IO0_T;
str_IO1_I <= IO1_I;
IO1_O <= str_IO1_O;
IO1_T <= str_IO1_T;
fcsbo_int <= '0';  
fcsbts_int <= '0'; 
SS_O <= SS_O_int;  
SS_T <= SS_T_int;  
SS_I_int <= SS_I;
    end generate DATA_STARTUP_DIS;




-----------------------------------
-- Combinatorial operations for SPI
-----------------------------------
---- A write to read only register wont have any effect on register.
---- The transaction is completed by generating WrAck only.
not_Tx_FIFO_FULL <= not Tx_FIFO_Full;
Interrupt_WrCE_sig <= "00";
IPIF_Lvl_Interrupts_sig <= '0';

LEGACY_MD_WR_RD_ACK_GEN: if C_TYPE_OF_AXI4_INTERFACE = 0 generate
-----
begin
-----
-- A write to read only register wont have any effect on register.
-- The transaction is completed by generating WrAck only.
--------------------------------------------------------
-- IP2Bus_Error is generated under following conditions:
-- 1. If an full transmit register/FIFO is written into.
-- 2. If an empty receive register/FIFO is read from.
-- Due to software driver legacy, the register rule test is not applied to SPI.
--------------------------------------------------------
  IP2Bus_Error_1          <= intr_ip2bus_error   or
                           rst_ip2bus_error      or
                           transmit_ip2bus_error or
                           receive_ip2bus_error;
REG_ERR_ACK_P:process(Bus2IP_Clk)is
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          IP2Bus_Error  <= '0';
      else
          IP2Bus_Error  <= IP2Bus_Error_1;
      end if;
    end if;
end process REG_ERR_ACK_P;
 wr_ce_or_reduce_core_cmb <= Bus2IP_WrCE(SPISR)  or -- read only register
                             Bus2IP_WrCE(SPIDRR) or -- read only register
                             (Bus2IP_WrCE(SPIDTR) and not_Tx_FIFO_FULL)  or -- common to
                                                    -- spi_fifo_ifmodule_1 and
                                                    -- spi_receive_reg_1
                                                    -- (FROM TRANSMITTER) module
                             Bus2IP_WrCE(SPICR)  or
                             Bus2IP_WrCE(SPISSR) or
                             Bus2IP_WrCE(SPITFOR)or -- locally generated
                             Bus2IP_WrCE(SPIRFOR)or -- locally generated
                             Bus2IP_WrCE(REG_HOLE) or -- register hole
                             or_reduce(Bus2IP_WrCE(17 to 23)); -- holes between reset end and start of SPICR register
--------------------------------------------------
WRITE_ACK_SPIDTR_REG_PROCESS: process(Bus2IP_Clk) is
---------------------------
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          Bus2IP_WrCE_d1 <= '0';
          Bus2IP_WrCE_d2 <= '0';
          Bus2IP_WrCE_d3 <= '0';
      else
          Bus2IP_WrCE_d1 <= Bus2IP_WrCE(SPIDTR);
          Bus2IP_WrCE_d2 <= Bus2IP_WrCE_d1;
          Bus2IP_WrCE_d3 <= Bus2IP_WrCE_d2;
      end if;   end if;
end process WRITE_ACK_SPIDTR_REG_PROCESS;

Bus2IP_WrCE_pulse_1 <= Bus2IP_WrCE(SPIDTR) and not Bus2IP_WrCE_d1;
Bus2IP_WrCE_pulse_2 <= Bus2IP_WrCE_d1 and not Bus2IP_WrCE_d2;
Bus2IP_WrCE_pulse_3 <= Bus2IP_WrCE_d2 and not Bus2IP_WrCE_d3;


--end generate WR_ACK_OR_REDUCE_FIFO_1_GEN;
-----------------------------------------


-- WRITE_ACK_CORE_REG_PROCESS   : The commong write ACK generation logic when FIFO is
-- ------------------------ not included in the design.
--------------------------------------------------
-- _____|-----|__________  wr_ce_or_reduce_fifo_no
-- ________|-----|_______  ip2Bus_WrAck_fifo_no_d1
-- ________|--|__________  ip2Bus_WrAck_fifo_no from common write ack register
--                         this ack will be used in register files for
--                         reference.
--------------------------------------------------
WRITE_ACK_CORE_REG_PROCESS: process(Bus2IP_Clk) is
---------------------------
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          ip2Bus_WrAck_core_reg_d1 <= '0';
          ip2Bus_WrAck_core_reg    <= '0';
          ip2Bus_WrAck_core_reg_1  <= '0';
      else
          ip2Bus_WrAck_core_reg_d1 <= wr_ce_or_reduce_core_cmb;
          ip2Bus_WrAck_core_reg   <= wr_ce_or_reduce_core_cmb and
                                                 (not ip2Bus_WrAck_core_reg_d1);
          ip2Bus_WrAck_core_reg_1  <= ip2Bus_WrAck_core_reg;
      end if;
    end if;
end process WRITE_ACK_CORE_REG_PROCESS;
-------------------------------------------------
-- internal logic uses this signal

wr_ce_reduce_ack_gen <= ip2Bus_WrAck_core_reg_1;
-------------------------------------------------
-- common WrAck to IPIF

IP2Bus_WrAck_1     <= intr_ip2bus_wrack          or -- common
                    rst_ip2bus_wrack           or -- common
                    ip2Bus_WrAck_intr_reg_hole or -- newly added to target the holes in register space
                    ip2Bus_WrAck_core_reg;--      or
                    --Tx_FIFO_wr_ack; -- newly added
REG_WR_ACK_P:process(Bus2IP_Clk)is
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          IP2Bus_WrAck <= '0';
      else
          IP2Bus_WrAck <= IP2Bus_WrAck_1;
      end if;
    end if;
end process REG_WR_ACK_P;

-------------------------------------------------
--end generate LEGACY_MD_WR_ACK_GEN;
-------------------------------------------------
--LEGACY_MD_RD_ACK_GEN: if C_TYPE_OF_AXI4_INTERFACE = 0 generate
-----
--begin
-----
rd_ce_or_reduce_core_cmb <= Bus2IP_RdCE(SWRESET) or --common locally generated
                            Bus2IP_RdCE(SPIDTR)  or --common locally generated
                            Bus2IP_RdCE(SPISR)   or --common from status register
                            Bus2IP_RdCE(SPIDRR)  or --common to
                                                    --spi_fifo_ifmodule_1
                                                    --and spi_receive_reg_1
                                                    --(FROM RECEIVER) module
                            Bus2IP_RdCE(SPICR)   or --common spi_cntrl_reg_1
                            Bus2IP_RdCE(SPISSR)  or --common spi_status_reg_1
                            Bus2IP_RdCE(SPITFOR) or --only for fifo_occu TX reg
                            Bus2IP_RdCE(SPIRFOR) or --only for fifo_occu RX reg
                            Bus2IP_RdCE(REG_HOLE) or -- register hole
                             or_reduce(Bus2IP_RdCE(17 to 23)); -- holes between reset end and start of SPICR register;  --reg hole

-- READ_ACK_CORE_REG_PROCESS   : The commong write ACK generation logic
--------------------------------------------------
-- _____|-----|__________  wr_ce_or_reduce_fifo_no
-- ________|-----|_______  ip2Bus_WrAck_fifo_no_d1
-- ________|--|__________  ip2Bus_WrAck_fifo_no from common write ack register
--                         this ack will be used in register files for
--                         reference.
--------------------------------------------------
READ_ACK_CORE_REG_PROCESS: process(Bus2IP_Clk) is
-------------------
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if (reset2ip_reset_int = RESET_ACTIVE) then
           ip2Bus_RdAck_core_reg_d1 <= '0';
           ip2Bus_RdAck_core_reg    <= '0';
           ip2Bus_RdAck_core_reg_1  <= '0';
           read_ack_delay_1 <= '0';
	   read_ack_delay_2 <= '0';
	   read_ack_delay_3 <= '0';
	   read_ack_delay_4 <= '0';
	   read_ack_delay_5 <= '0';
	   read_ack_delay_6 <= '0';
	   read_ack_delay_7 <= '0';
        else
           --ip2Bus_RdAck_core_reg_d1 <= rd_ce_or_reduce_core_cmb;
           --ip2Bus_RdAck_core_reg    <= rd_ce_or_reduce_core_cmb and
           --                                      (not ip2Bus_RdAck_core_reg_d1);
	   read_ack_delay_1 <= rd_ce_or_reduce_core_cmb;
	   read_ack_delay_2 <= read_ack_delay_1;
	   read_ack_delay_3 <= read_ack_delay_2;
	   read_ack_delay_4 <= read_ack_delay_3;
	   read_ack_delay_5 <= read_ack_delay_4;
	   read_ack_delay_6 <= read_ack_delay_5;
	   read_ack_delay_7 <= read_ack_delay_6;
           
	   ip2Bus_RdAck_core_reg <= read_ack_delay_6 and (not read_ack_delay_7);
           ip2Bus_RdAck_core_reg_1  <= ip2Bus_RdAck_core_reg;
        end if;
    end if;
end process READ_ACK_CORE_REG_PROCESS;
-------------------------------------------------
-- internal logic uses this signal

rd_ce_reduce_ack_gen <= ip2Bus_RdAck_core_reg;
-------------------------------------------------
-- common RdAck to IPIF

IP2Bus_RdAck_1        <= intr_ip2bus_rdack          or      -- common
                         ip2Bus_RdAck_intr_reg_hole or
                         ip2Bus_RdAck_core_reg;

REG_RD_ACK_P:process(Bus2IP_Clk)is
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          IP2Bus_RdAck <= '0';
      else
          IP2Bus_RdAck <= IP2Bus_RdAck_1;
      end if;
    end if;
end process REG_RD_ACK_P;
---------------------------------------------------
end generate LEGACY_MD_WR_RD_ACK_GEN;
-------------------------------------------------
ENHANCED_MD_WR_RD_ACK_GEN: if C_TYPE_OF_AXI4_INTERFACE = 1 generate
-----
begin
-----
-- A write to read only register wont have any effect on register.
-- The transaction is completed by generating WrAck only.
--------------------------------------------------------
-- IP2Bus_Error is generated under following conditions:
-- 1. If an full transmit register/FIFO is written into.
-- 2. If an empty receive register/FIFO is read from.
-- Due to software driver legacy, the register rule test is not applied to SPI.
--------------------------------------------------------
  IP2Bus_Error          <= intr_ip2bus_error   or
                           rst_ip2bus_error      or
                           transmit_ip2bus_error or
                           receive_ip2bus_error;

 wr_ce_or_reduce_core_cmb <= Bus2IP_WrCE(SPISR)  or -- read only register
                             Bus2IP_WrCE(SPIDRR) or -- read only register
                             (Bus2IP_WrCE(SPIDTR) and not_Tx_FIFO_FULL) or -- common to
                                                    -- spi_fifo_ifmodule_1 and
                                                    -- spi_receive_reg_1
                                                    -- (FROM TRANSMITTER) module
                             Bus2IP_WrCE(SPICR)  or
                             Bus2IP_WrCE(SPISSR) or
                             Bus2IP_WrCE(SPITFOR)or -- locally generated
                             Bus2IP_WrCE(SPIRFOR)or -- locally generated
                             Bus2IP_WrCE(REG_HOLE) or -- register hole
                             or_reduce(Bus2IP_WrCE(17 to 23)); -- holes between reset end and start of SPICR register; -- register hole

--------------------------------------------------
WRITE_ACK_SPIDTR_REG_PROCESS: process(Bus2IP_Clk) is
---------------------------
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          Bus2IP_WrCE_d1 <= '0';
          Bus2IP_WrCE_d2 <= '0';
          Bus2IP_WrCE_d3 <= '0';
      else
          Bus2IP_WrCE_d1 <= Bus2IP_WrCE(SPIDTR);
          Bus2IP_WrCE_d2 <= Bus2IP_WrCE_d1;
          Bus2IP_WrCE_d3 <= Bus2IP_WrCE_d2;
      end if;   end if;
end process WRITE_ACK_SPIDTR_REG_PROCESS;

Bus2IP_WrCE_pulse_1 <= Bus2IP_WrCE(SPIDTR) and not Bus2IP_WrCE_d1;
Bus2IP_WrCE_pulse_2 <= Bus2IP_WrCE_d1 and not Bus2IP_WrCE_d2;
Bus2IP_WrCE_pulse_3 <= Bus2IP_WrCE_d2 and not Bus2IP_WrCE_d3;



-- WRITE_ACK_CORE_REG_PROCESS   : The commong write ACK generation logic when FIFO is
-- ------------------------ not included in the design.
--------------------------------------------------
-- _____|-----|__________  wr_ce_or_reduce_fifo_no
-- ________|-----|_______  ip2Bus_WrAck_fifo_no_d1
-- ________|--|__________  ip2Bus_WrAck_fifo_no from common write ack register
--                         this ack will be used in register files for
--                         reference.
--------------------------------------------------
WRITE_ACK_CORE_REG_PROCESS: process(Bus2IP_Clk) is
---------------------------
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          ip2Bus_WrAck_core_reg_d1 <= '0';
          ip2Bus_WrAck_core_reg   <= '0';
          ip2Bus_WrAck_core_reg_1  <= '0';
      else
          ip2Bus_WrAck_core_reg_d1 <= wr_ce_or_reduce_core_cmb;
          ip2Bus_WrAck_core_reg   <= wr_ce_or_reduce_core_cmb and
                                                 (not ip2Bus_WrAck_core_reg_d1);
          ip2Bus_WrAck_core_reg_1  <= ip2Bus_WrAck_core_reg;
      end if;
    end if;
end process WRITE_ACK_CORE_REG_PROCESS;
-------------------------------------------------
-- internal logic uses this signal

wr_ce_reduce_ack_gen <= ip2Bus_WrAck_core_reg;--_1;
-------------------------------------------------
-- common WrAck to IPIF
-- in the enhanced mode for FIFO, the IP2bus_Wrack is provided by the enhanced mode statemachine only.
IP2Bus_WrAck      <= intr_ip2bus_wrack        or -- common
                    rst_ip2bus_wrack           or -- common
                    ip2Bus_WrAck_intr_reg_hole or -- newly added to target the holes in register space
                    (ip2Bus_WrAck_core_reg and (not burst_tr));-- or
                    --(Tx_FIFO_wr_ack and burst_tr); -- newly added

-------------------------------------------------

--ENHANCED_MD_RD_ACK_GEN: if C_TYPE_OF_AXI4_INTERFACE = 1 generate
-----
--begin
-----
FIFO_NO_RD_CE_GEN: if C_FIFO_EXIST = 0 generate
begin
rd_ce_or_reduce_core_cmb <= Bus2IP_RdCE(SWRESET) or --common locally generated
                            Bus2IP_RdCE(SPIDTR)  or --common locally generated
                            Bus2IP_RdCE(SPISR)   or --common from status register
                            Bus2IP_RdCE(SPIDRR)  or --common to
                                                    --spi_fifo_ifmodule_1
                                                    --and spi_receive_reg_1
                                                    --(FROM RECEIVER) module
                            Bus2IP_RdCE(SPICR)   or --common spi_cntrl_reg_1
                            Bus2IP_RdCE(SPISSR)  or --common spi_status_reg_1
                            Bus2IP_RdCE(SPITFOR) or --only for fifo_occu TX reg
                            Bus2IP_RdCE(SPIRFOR) or --only for fifo_occu RX reg
                            Bus2IP_RdCE(REG_HOLE) or -- register hole
                             or_reduce(Bus2IP_RdCE(17 to 23)); -- holes between reset end and start of SPICR register;  --reg hole
end generate FIFO_NO_RD_CE_GEN;

FIFO_YES_RD_CE_GEN: if C_FIFO_EXIST = 1 generate
begin
rd_ce_or_reduce_core_cmb <= Bus2IP_RdCE(SWRESET) or --common locally generated
                            Bus2IP_RdCE(SPIDTR)  or --common locally generated
                            Bus2IP_RdCE(SPISR)   or --common from status register
                            --Bus2IP_RdCE(SPIDRR)  or --common to
                                                    --spi_fifo_ifmodule_1
                                                    --and spi_receive_reg_1
                                                    --(FROM RECEIVER) module
                            Bus2IP_RdCE(SPICR)   or --common spi_cntrl_reg_1
                            Bus2IP_RdCE(SPISSR)  or --common spi_status_reg_1
                            Bus2IP_RdCE(SPITFOR) or --only for fifo_occu TX reg
                            Bus2IP_RdCE(SPIRFOR) or --only for fifo_occu RX reg
                            Bus2IP_RdCE(REG_HOLE) or -- register hole
                             or_reduce(Bus2IP_RdCE(17 to 23)); -- holes between reset end and start of SPICR register;  --reg hole
end generate FIFO_YES_RD_CE_GEN;

-- READ_ACK_CORE_REG_PROCESS   : The commong write ACK generation logic
--------------------------------------------------
-- _____|-----|__________  wr_ce_or_reduce_fifo_no
-- ________|-----|_______  ip2Bus_WrAck_fifo_no_d1
-- ________|--|__________  ip2Bus_WrAck_fifo_no from common write ack register
--                         this ack will be used in register files for
--                         reference.
--------------------------------------------------
READ_ACK_CORE_REG_PROCESS: process(Bus2IP_Clk) is
-------------------
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
        if (reset2ip_reset_int = RESET_ACTIVE) then
           ip2Bus_RdAck_core_reg_d1 <= '0';
           ip2Bus_RdAck_core_reg    <= '0';
           ip2Bus_RdAck_core_reg_1  <= '0';
           
	   read_ack_delay_1 <= '0';
	   read_ack_delay_2 <= '0';
	   read_ack_delay_3 <= '0';
	   read_ack_delay_4 <= '0';
	   read_ack_delay_5 <= '0';
	   read_ack_delay_6 <= '0';
	   read_ack_delay_7 <= '0';
        else
           --ip2Bus_RdAck_core_reg_d1 <= rd_ce_or_reduce_core_cmb;
           --ip2Bus_RdAck_core_reg    <= rd_ce_or_reduce_core_cmb and
           --                                      (not ip2Bus_RdAck_core_reg_d1);
           --ip2Bus_RdAck_core_reg_1  <= ip2Bus_RdAck_core_reg;
	   read_ack_delay_1 <= rd_ce_or_reduce_core_cmb;
	   read_ack_delay_2 <= read_ack_delay_1;
	   read_ack_delay_3 <= read_ack_delay_2;
	   read_ack_delay_4 <= read_ack_delay_3;
	   read_ack_delay_5 <= read_ack_delay_4;
	   read_ack_delay_6 <= read_ack_delay_5;
	   read_ack_delay_7 <= read_ack_delay_6;
           
	   ip2Bus_RdAck_core_reg <= read_ack_delay_6 and (not read_ack_delay_7);
           ip2Bus_RdAck_core_reg_1  <= ip2Bus_RdAck_core_reg;
        end if;
    end if;
end process READ_ACK_CORE_REG_PROCESS;
-------------------------------------------------
-- internal logic uses this signal

rd_ce_reduce_ack_gen <= ip2Bus_RdAck_core_reg; --_1;
-------------------------------------------------

-- common RdAck to IPIF

IP2Bus_RdAck         <= intr_ip2bus_rdack          or      -- common
                        ip2Bus_RdAck_intr_reg_hole or
                        ip2Bus_RdAck_core_reg or
                        (Rx_FIFO_rd_ack and rready);
-----------------------------------------------------
end generate ENHANCED_MD_WR_RD_ACK_GEN;
-------------------------------------------------
--=============================================================================
TX_FIFO_OCC_DATA_FIFO_16: if  C_FIFO_DEPTH = 16 generate
-------------------------
begin
-----
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(0) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(0)
                                             and not (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(1) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(1)
                                             and not (Tx_FIFO_Empty_SPISR_to_axi_clk); --  (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(2) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(2)
                                             and not (Tx_FIFO_Empty_SPISR_to_axi_clk); --  (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(3) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(3)
                                             and not (Tx_FIFO_Empty_SPISR_to_axi_clk); --  (Tx_FIFO_Empty); --(FIFO_Empty_tx);

     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(0) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(0)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(1) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(1)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(2) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(2)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(3) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(3)
                                             and not (Rx_FIFO_Empty); --(FIFO_Empty_rx);

end generate TX_FIFO_OCC_DATA_FIFO_16;
--------------------------------------
TX_FIFO_OCC_DATA_FIFO_256: if  C_FIFO_DEPTH = 256 generate
-------------------------
begin
-----
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(0) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(0)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(1) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(1)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(2) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(2)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(3) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(3)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);

     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(4) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(4)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(5) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(5)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(6) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(6)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1(7) <= IP2Bus_Tx_FIFO_OCC_Reg_Data_int(7)
                                             and not  (Tx_FIFO_Empty_SPISR_to_axi_clk); -- (Tx_FIFO_Empty);-- (FIFO_Empty_tx);

     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(0) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(0)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(1) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(1)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(2) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(2)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(3) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(3)
                                             and not (Rx_FIFO_Empty);

     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(4) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(4)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(5) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(5)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(6) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(6)
                                             and not (Rx_FIFO_Empty);
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1(7) <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int(7)
                                             and not (Rx_FIFO_Empty); --(FIFO_Empty_rx);

end generate TX_FIFO_OCC_DATA_FIFO_256;

--*****************************************************************************
ip2Bus_Data_occupancy_int(0 to (C_S_AXI_DATA_WIDTH-C_OCCUPANCY_NUM_BITS-1))
                         <= (others => '0');

ip2Bus_Data_occupancy_int((C_S_AXI_DATA_WIDTH-C_OCCUPANCY_NUM_BITS)
                                         to (C_S_AXI_DATA_WIDTH-1))
                         <= IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1 or
                            IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1;

-------------------------------------------------------------------------------
-- SPECIAL_CASE_WHEN_SS_NOT_EQL_32 : The Special case is executed whenever
--                                   C_NUM_SS_BITS is less than 32
-------------------------------------------------------------------------------

  SPECIAL_CASE_WHEN_SS_NOT_EQL_32: if(C_NUM_SS_BITS /= 32) generate
  -----
  begin
  -----
     ip2Bus_Data_SS_int(0 to (C_S_AXI_DATA_WIDTH-C_NUM_SS_BITS-1))
                                                 <= (others => '0');
  end generate SPECIAL_CASE_WHEN_SS_NOT_EQL_32;
  ---------------------------------------------

  ip2Bus_Data_SS_int((C_S_AXI_DATA_WIDTH-C_NUM_SS_BITS) to
                     (C_S_AXI_DATA_WIDTH-1)) <= IP2Bus_SPISSR_Data_int;

-------------------------------------------------------------------------------
  ip2Bus_Data_Reg_int(0 to C_S_AXI_DATA_WIDTH-C_SPISR_REG_WIDTH-1) <= (others => '0');
  ip2Bus_Data_Reg_int(C_S_AXI_DATA_WIDTH-C_SPISR_REG_WIDTH to C_S_AXI_DATA_WIDTH-1)
                                 <= IP2Bus_SPISR_Data_int or        -- SPISR - 11 bit
                                    ('0' & IP2Bus_SPICR_Data_int);  -- SPICR - 10 bit
-------------------------------------------------------------------------------
  -----------------------
  Receive_Reg_width_is_32: if(C_NUM_TRANSFER_BITS = 32) generate
  -----------------------
  begin
  -----

      IP2Bus_Data_received_int <= IP2Bus_Receive_Reg_Data_int;

  end generate Receive_Reg_width_is_32;
  -----------------------------------------

  ---------------------------
  Receive_Reg_width_is_not_32: if(C_NUM_TRANSFER_BITS /= 32) generate
  ---------------------------
  begin
  -----
      IP2Bus_Data_received_int(0 to C_S_AXI_DATA_WIDTH-C_NUM_TRANSFER_BITS-1)
                                                             <= (others => '0');
      IP2Bus_Data_received_int((C_S_AXI_DATA_WIDTH-C_NUM_TRANSFER_BITS) to
                               (C_S_AXI_DATA_WIDTH-1))
                                                 <= IP2Bus_Receive_Reg_Data_int;

  end generate Receive_Reg_width_is_not_32;
  -----------------------------------------
-------------------------------------------------------------------------------
LEGACY_MD_IP2BUS_DATA_GEN: if C_TYPE_OF_AXI4_INTERFACE = 0 generate
-----
begin
-----
  ip2Bus_Data_1      <= ip2Bus_Data_occupancy_int or -- occupancy reg data
                      ip2Bus_Data_SS_int        or -- Slave select reg data
                      ip2Bus_Data_Reg_int       or -- SPI CR & SR reg data
                      IP2Bus_Data_received_int  or -- SPI received data
                      intr_ip2bus_data          ;

REG_IP2BUS_DATA_P:process(Bus2IP_Clk)is
begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          ip2Bus_Data <= (others => '0');
      else
          ip2Bus_Data <= ip2Bus_Data_1;
      end if;
    end if;

end process REG_IP2BUS_DATA_P;
end generate LEGACY_MD_IP2BUS_DATA_GEN;
-------------------------------------------------------------------------------
ENHANCED_MD_IP2BUS_DATA_GEN: if C_TYPE_OF_AXI4_INTERFACE = 1 generate
-----
begin
-----
  ip2Bus_Data      <= ip2Bus_Data_occupancy_int or -- occupancy reg data
                      ip2Bus_Data_SS_int        or -- Slave select reg data
                      ip2Bus_Data_Reg_int       or -- SPI CR & SR reg data
                      IP2Bus_Data_received_int  or -- SPI received data
                      intr_ip2bus_data          ;

end generate ENHANCED_MD_IP2BUS_DATA_GEN;

-------------------------------------------------------------------------------

RESET_SYNC_AXI_SPI_CLK_INST:entity axi_quad_spi_v3_2_9.reset_sync_module
               port map(
                         EXT_SPI_CLK        => EXT_SPI_CLK        ,-- in std_logic;
                         --Bus2IP_Clk         => Bus2IP_Clk         ,-- in std_logic;
                         Soft_Reset_frm_axi => reset2ip_reset_int,-- in std_logic;
                         Rst_to_spi         => Rst_to_spi_int -- out std_logic;
               );

--------------------------------------
-- NO_FIFO_EXISTS : Signals initialisation and module
--                                     instantiation when C_FIFO_EXIST = 0
--------------------------------------

NO_FIFO_EXISTS: if(C_FIFO_EXIST = 0) generate
----------------------------------
signal spisel_pulse_frm_spi_clk : std_logic;
signal spisel_pulse_to_axi_clk  : std_logic;
signal spiXfer_done_frm_spi_clk : std_logic;
signal spiXfer_done_to_axi_clk  : std_logic;
signal modf_strobe_frm_spi_clk  : std_logic;
-- signal modf_strobe_to_axi_clk   : std_logic;
signal slave_MODF_strobe_frm_spi_clk : std_logic;
signal slave_MODF_strobe_to_axi_clk  : std_logic;
signal receive_data_frm_spi_clk : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal receive_data_to_axi_clk  : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal transmit_Data_frm_axi_clk: std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal transmit_Data_to_spi_clk : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal transmit_Data_fifo_0     : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal drr_Overrun_int_frm_spi_clk: std_logic;
signal drr_Overrun_int_to_axi_clk : std_logic;
-----
begin
-----
     Rx_FIFO_rd_ack <= '0';
     Tx_FIFO_Full    <= '0';
     --------------------------------------------------------------------------
     -- I_RECEIVE_REG : INSTANTIATE RECEIVE REGISTER
     --------------------------------------------------------------------------

     QSPI_RX_TX_REG: entity axi_quad_spi_v3_2_9.qspi_receive_transmit_reg
     generic map
           (
             C_S_AXI_DATA_WIDTH      => C_S_AXI_DATA_WIDTH,
             C_NUM_TRANSFER_BITS     => C_NUM_TRANSFER_BITS
            )
     port map
            (
             Bus2IP_Clk              => Bus2IP_Clk,                             -- in
             Soft_Reset_op           => reset2ip_reset_int,                     -- in
             --SPI Receiver signals -- From AXI clock
             Bus2IP_Receive_Reg_RdCE => Bus2IP_RdCE(SPIDRR),                    -- in
             Receive_ip2bus_error    => receive_ip2bus_error,                   -- out
             IP2Bus_Receive_Reg_Data => IP2Bus_Receive_Reg_Data_int,            -- out
             --SPI module ports From SPI clock
             SPIXfer_done            => spiXfer_done_to_axi_clk,--spiXfer_done_int,-- in
             SPI_Received_Data       => receive_data_to_axi_clk,--receive_Data_int,-- in vec
             -- receive & transmit reg signals
             -- DRR_Overrun             => drr_Overrun_int,-- drr_Overrun_int,-- out
             SR_7_Rx_Empty           => Rx_FIFO_Empty_i,                          -- out
             -- From AXI clock
             Bus2IP_Transmit_Reg_Data=> Bus2IP_Data,                            -- in vec
             Bus2IP_Transmit_Reg_WrCE=> Bus2IP_WrCE(SPIDTR),                    -- in
             Wr_ce_reduce_ack_gen    => wr_ce_reduce_ack_gen,                   -- in
             Rd_ce_reduce_ack_gen    => rd_ce_reduce_ack_gen,                   -- in
             --SPI Transmitter signals from AXI clock
             Transmit_ip2bus_error   => transmit_ip2bus_error,                  -- out
             --SPI module ports
             DTR_underrun            => dtr_underrun_to_axi_clk,--dtr_underrun_int,-- in
             SR_5_Tx_Empty           => sr_5_Tx_Empty_int,                      -- out
             tx_empty_signal_handshake_req           => tx_empty_signal_handshake_req,                      -- out
             tx_empty_signal_handshake_gnt           => tx_empty_signal_handshake_gnt,                      -- in
             DTR_Underrun_strobe     => dtr_Underrun_strobe_int,                -- out
             Transmit_Reg_Data_Out   => transmit_Data_fifo_0--transmit_Data_int -- out vec
     );

     spisel_d1_reg_frm_spi_clk     <= spisel_d1_reg;
     spisel_pulse_frm_spi_clk      <= spisel_pulse_o_int;-- from SPI module
     spiXfer_done_frm_spi_clk      <= spiXfer_done_int  ;-- from SPI module
     modf_strobe_frm_spi_clk       <= modf_strobe_int   ;-- from SPI module
     slave_MODF_strobe_frm_spi_clk <= slave_MODF_strobe_int;-- from SPI module
     receive_data_frm_spi_clk      <= Data_To_Rx_FIFO ; -- from SPI module
     dtr_underrun_frm_spi_clk      <= dtr_underrun_int;  -- from SPI module

     transmit_Data_frm_axi_clk     <= transmit_Data_fifo_0; -- From AXI clock

     Tx_FIFO_Empty_frm_axi_clk     <= sr_5_Tx_Empty_int;
     Tx_FIFO_Empty_SPISR_frm_spi_clk <= sr_5_Tx_Empty_int;
     --Rx_FIFO_Empty_int           <= Rx_FIFO_Empty;

     Rx_FIFO_Empty_int             <= Rx_FIFO_Empty_i;
     drr_Overrun_int_frm_spi_clk   <= drr_Overrun_int;

     SR_3_modf_frm_axi_clk         <= SR_3_modf_int;

     CROSS_CLK_FIFO_0_INST:entity axi_quad_spi_v3_2_9.cross_clk_sync_fifo_0
     generic map(
                 C_NUM_TRANSFER_BITS    => C_NUM_TRANSFER_BITS,
                 Async_Clk              => Async_Clk          ,
                 --C_AXI_SPI_CLK_EQ_DIFF  => C_AXI_SPI_CLK_EQ_DIFF,
                         C_NUM_SS_BITS => C_NUM_SS_BITS
                 )
     port map(
              EXT_SPI_CLK               => EXT_SPI_CLK,
              Bus2IP_Clk                => Bus2IP_Clk ,
              Soft_Reset_op             => reset2ip_reset_int,
              Rst_from_axi_cdc_to_spi       => Rst_to_spi_int,                       -- out std_logic;
              ----------------------------------------------------------
              tx_empty_signal_handshake_req     => tx_empty_signal_handshake_req,
              tx_empty_signal_handshake_gnt     => tx_empty_signal_handshake_gnt,
              Tx_FIFO_Empty_cdc_from_axi     => Tx_FIFO_Empty_frm_axi_clk,
              Tx_FIFO_Empty_cdc_to_spi      => Tx_FIFO_Empty,
              ----------------------------------------------------------
              Tx_FIFO_Empty_SPISR_cdc_from_spi => Tx_FIFO_Empty_SPISR_frm_spi_clk,
              Tx_FIFO_Empty_SPISR_cdc_to_axi  => Tx_FIFO_Empty_SPISR_to_axi_clk,
              ----------------------------------------------------------
              spisel_d1_reg_cdc_from_spi     => spisel_d1_reg_frm_spi_clk  , -- in
              spisel_d1_reg_cdc_to_axi      => spisel_d1_reg_to_axi_clk   , -- out
              ----------------------------------------------------------
              spisel_pulse_cdc_from_spi      => spisel_pulse_frm_spi_clk   , -- in
              spisel_pulse_cdc_to_axi       => spisel_pulse_to_axi_clk    , -- out
              ----------------------------------------------------------
              spiXfer_done_cdc_from_spi      => spiXfer_done_frm_spi_clk   , -- in
              spiXfer_done_cdc_to_axi       => spiXfer_done_to_axi_clk    , -- out
              ----------------------------------------------------------
              modf_strobe_cdc_from_spi       => modf_strobe_frm_spi_clk, -- in
              modf_strobe_cdc_to_axi        => modf_strobe_to_axi_clk , -- out
              ----------------------------------------------------------
              Slave_MODF_strobe_cdc_from_spi => slave_MODF_strobe_frm_spi_clk,-- in
              Slave_MODF_strobe_cdc_to_axi  => slave_MODF_strobe_to_axi_clk ,-- out
              ----------------------------------------------------------
              receive_Data_cdc_from_spi      => receive_Data_frm_spi_clk, -- in
              receive_Data_cdc_to_axi       => receive_data_to_axi_clk, -- out
              ----------------------------------------------------------
              drr_Overrun_int_cdc_from_spi   => drr_Overrun_int_frm_spi_clk, -- in
              drr_Overrun_int_cdc_to_axi    => drr_Overrun_int_to_axi_clk,  -- out
              ----------------------------------------------------------
              dtr_underrun_cdc_from_spi      => dtr_underrun_frm_spi_clk, -- in
              dtr_underrun_cdc_to_axi       => dtr_underrun_to_axi_clk,  -- out
              ----------------------------------------------------------
              transmit_Data_cdc_from_axi     => transmit_Data_frm_axi_clk, -- in
              transmit_Data_cdc_to_spi      => transmit_Data_to_spi_clk,   -- out
              ----------------------------
              SPICR_0_LOOP_cdc_from_axi      => SPICR_0_LOOP_frm_axi_clk,-- in std_logic;
              SPICR_0_LOOP_cdc_to_spi       => SPICR_0_LOOP_to_spi_clk ,-- out
              ----------------------------
              SPICR_1_SPE_cdc_from_axi       => SPICR_1_SPE_frm_axi_clk ,-- in std_logic;
              SPICR_1_SPE_cdc_to_spi        => SPICR_1_SPE_to_spi_clk  ,-- out
              ----------------------------
              SPICR_2_MST_N_SLV_cdc_from_axi => SPICR_2_MST_N_SLV_frm_axi_clk,-- in std_logic;
              SPICR_2_MST_N_SLV_cdc_to_spi  => SPICR_2_MST_N_SLV_to_spi_clk, -- out
              ----------------------------
              SPICR_3_CPOL_cdc_from_axi      => SPICR_3_CPOL_frm_axi_clk,-- in std_logic;
              SPICR_3_CPOL_cdc_to_spi       => SPICR_3_CPOL_to_spi_clk ,-- out
              ----------------------------
              SPICR_4_CPHA_cdc_from_axi      => SPICR_4_CPHA_frm_axi_clk,-- in std_logic;
              SPICR_4_CPHA_cdc_to_spi       => SPICR_4_CPHA_to_spi_clk ,-- out
              ----------------------------
              SPICR_5_TXFIFO_cdc_from_axi    => SPICR_5_TXFIFO_frm_axi_clk,-- in std_logic;
              SPICR_5_TXFIFO_cdc_to_spi     => SPICR_5_TXFIFO_to_spi_clk,  -- out
              ----------------------------
              SPICR_6_RXFIFO_RST_cdc_from_axi=> SPICR_6_RXFIFO_RST_frm_axi_clk,-- in std_logic;
              SPICR_6_RXFIFO_RST_cdc_to_spi => SPICR_6_RXFIFO_RST_to_spi_clk ,-- out
              ----------------------------
              SPICR_7_SS_cdc_from_axi        => SPICR_7_SS_frm_axi_clk ,-- in std_logic;
              SPICR_7_SS_cdc_to_spi         => SPICR_7_SS_to_spi_clk ,-- out
              ----------------------------
              SPICR_8_TR_INHIBIT_cdc_from_axi=> SPICR_8_TR_INHIBIT_frm_axi_clk,-- in std_logic;
              SPICR_8_TR_INHIBIT_cdc_to_spi => SPICR_8_TR_INHIBIT_to_spi_clk,-- out
              ----------------------------
              SPICR_9_LSB_cdc_from_axi       => SPICR_9_LSB_frm_axi_clk,-- in std_logic;
              SPICR_9_LSB_cdc_to_spi        => SPICR_9_LSB_to_spi_clk,-- out
              ----------------------------
              SPICR_bits_7_8_cdc_from_axi    => SPICR_bits_7_8_frm_axi_clk,-- in std_logic_vector
              SPICR_bits_7_8_cdc_to_spi     => SPICR_bits_7_8_to_spi_clk,-- out
              ----------------------------
              SR_3_modf_cdc_from_axi         => SR_3_modf_frm_axi_clk, -- in
              SR_3_modf_cdc_to_spi          => SR_3_modf_to_spi_clk , -- out
              ----------------------------
              SPISSR_cdc_from_axi            => SPISSR_frm_axi_clk, -- in
              SPISSR_cdc_to_spi             => register_Data_slvsel_int -- out
              ----------------------------
     );
     Data_From_TxFIFO <= transmit_Data_to_spi_clk;

     rc_FIFO_Full_strobe_int      <= '0';
     rc_FIFO_occ_Reversed_int     <= (others => '0');
     rc_FIFO_Data_Out_int         <= (others => '0');
     data_Exists_RcFIFO_int       <= '0';
     tx_FIFO_Empty_strobe_int     <= '0';
     tx_FIFO_occ_Reversed_int     <= (others => '0');
     data_Exists_TxFIFO_int       <= '0';
     data_From_TxFIFO_int         <= (others => '0');
     tx_FIFO_less_half_int        <= '0';
     reset_TxFIFO_ptr_int         <= '0';
     reset_RcFIFO_ptr_int         <= '0';
     IP2Bus_Rx_FIFO_OCC_Reg_Data_int_1  <= (others => '0');
     IP2Bus_Tx_FIFO_OCC_Reg_Data_int_1  <= (others => '0');

     Tx_FIFO_Full_int                 <= not(sr_5_Tx_Empty_int); -- Tx_FIFO_Empty_to_axi_clk);
     Rx_FIFO_Full_int             <= not(Rx_FIFO_Empty_i);
     Rx_FIFO_Full_Fifo             <= not(Rx_FIFO_Empty_i);
     Rx_FIFO_Full_Fifo_d1_synced   <= not(Rx_FIFO_Empty_i);
     --------------------------------------------------------------------------

     bus2IP_Data_for_interrupt_core(0 to 14) <= Bus2IP_Data(0 to 14);

     bus2IP_Data_for_interrupt_core(15 to 22) <= (others => '0');

     -- below code manipulates the bus2ip_data going towards interrupt control
     -- unit. In FIFO=0, case bit 23 and 25 of IPIER are not applicable.

     -- Bu2IP Data to Interrupt Registers - IPISR and IPIER
     -- Bus2IP_Data - 0                 31
     -- IPISR/IPIER - 0        22 23    31
     --                <---NA---> <-used->
     --                           23        24          25         26       27   28       29    30    31
     --                           DRR_Not   Slave       Tx_FIFO    DRR_     DRR_ DTR_     DTR   Slave MODF
     --                           _Empty    Select_mode Half_Empty Over_Run Full Underrun Empty MODF
     --                           NA-fifo-0             NA -fifo-0

     bus2IP_Data_for_interrupt_core(23)      <= '0'; -- DRR_Not_Empty bit in IPIER/IPISR
     bus2IP_Data_for_interrupt_core(24)      <= Bus2IP_Data(24);
     bus2IP_Data_for_interrupt_core(25)      <= '0'; -- Tx FIFO Half Empty
     bus2IP_Data_for_interrupt_core(26 to (C_S_AXI_DATA_WIDTH-1)) <=
                                      Bus2IP_Data(26 to (C_S_AXI_DATA_WIDTH-1));
     --------------------------------------------------------------------------

     -- Interrupt Status Register(IPISR) Mapping
     ip2Bus_IntrEvent_int(13)     <= '0'; -- doesnt exist in the FIFO = 0 case
     ip2Bus_IntrEvent_int(12)     <= '0'; -- doesnt exist in the FIFO = 0 case
     ip2Bus_IntrEvent_int(11)     <= '0'; -- doesnt exist in the FIFO = 0 case
     ip2Bus_IntrEvent_int(10)     <= '0'; -- doesnt exist in the FIFO = 0 case
     ip2Bus_IntrEvent_int(9)      <= '0'; -- doesnt exist in the FIFO = 0 case
     ip2Bus_IntrEvent_int(8)      <= '0'; -- doesnt exist in the FIFO = 0 case
     ip2Bus_IntrEvent_int(7)      <= spisel_pulse_to_axi_clk;      -- spisel_pulse_o_int;
     ip2Bus_IntrEvent_int(6)      <= '0'; --
     ip2Bus_IntrEvent_int(5)      <= drr_Overrun_int_to_axi_clk; -- drr_Overrun_int_to_axi_clk;
     ip2Bus_IntrEvent_int(4)      <= spiXfer_done_to_axi_clk;      -- spiXfer_done_int;
     ip2Bus_IntrEvent_int(3)      <= dtr_Underrun_strobe_int;
     ip2Bus_IntrEvent_int(2)      <= spiXfer_done_to_axi_clk;      -- spiXfer_done_int;
     ip2Bus_IntrEvent_int(1)      <= slave_MODF_strobe_to_axi_clk; -- slave_MODF_strobe_int;
     ip2Bus_IntrEvent_int(0)      <= modf_strobe_to_axi_clk;       -- modf_strobe_int;



end generate NO_FIFO_EXISTS;

-------------------------------------------------------------------------------
-- FIFO_EXISTS : Signals initialisation and module
--                                  instantiation when C_FIFO_EXIST = 1
-------------------------------------------------------------------------------
FIFO_EXISTS: if(C_FIFO_EXIST = 1) generate
------------------------------
constant C_RD_COUNT_WIDTH_INT : integer := clog2(C_FIFO_DEPTH);
constant C_WR_COUNT_WIDTH_INT : integer := clog2(C_FIFO_DEPTH);
constant RX_FIFO_CNTR_WIDTH: integer := clog2(C_FIFO_DEPTH);
constant TX_FIFO_CNTR_WIDTH: integer := clog2(C_FIFO_DEPTH);
constant ZERO_RX_FIFO_CNT   : std_logic_vector(RX_FIFO_CNTR_WIDTH-1 downto 0) := (others => '0');
constant ZERO_TX_FIFO_CNT   : std_logic_vector(TX_FIFO_CNTR_WIDTH-1 downto 0) := (others => '0');
signal rx_fifo_count: std_logic_vector(RX_FIFO_CNTR_WIDTH-1 downto 0);
signal tx_fifo_count: std_logic_vector(TX_FIFO_CNTR_WIDTH-1 downto 0);
signal tx_fifo_count_d1: std_logic_vector(TX_FIFO_CNTR_WIDTH-1 downto 0);
signal tx_fifo_count_d2: std_logic_vector(TX_FIFO_CNTR_WIDTH-1 downto 0);
signal Tx_FIFO_Empty_1 : std_logic;
signal Tx_FIFO_Empty_intr : std_logic;
signal IP2Bus_RdAck_receive_enable  : std_logic;
signal IP2Bus_WrAck_transmit_enable : std_logic;
    constant ALL_0          : std_logic_vector(0 to TX_FIFO_CNTR_WIDTH-1)
                            := (others => '1');

signal data_Exists_RcFIFO_int_d1: std_logic;
signal data_Exists_RcFIFO_pulse : std_logic;

--signal FIFO_Empty_rx : std_logic;
--signal SPISR_0_CMD_Error_frm_spi_clk : std_logic;
--signal SPISR_0_CMD_Error_to_axi_clk  : std_logic;

--signal spisel_d1_reg_frm_spi_clk : std_logic;
--signal spisel_d1_reg_to_axi_clk  : std_logic;
 signal tx_occ_msb_111             : std_logic:= '0';
 signal tx_occ_msb_11             : std_logic_vector(TX_FIFO_CNTR_WIDTH-1 downto 0);

signal spisel_pulse_frm_spi_clk : std_logic;
signal spisel_pulse_to_axi_clk  : std_logic;

signal slave_MODF_strobe_frm_spi_clk : std_logic;
signal slave_MODF_strobe_to_axi_clk  : std_logic;

signal Rx_FIFO_Empty_frm_axi_clk : std_logic;
signal Rx_FIFO_Empty_to_spi_clk  : std_logic;

signal Tx_FIFO_Full_frm_axi_clk     : std_logic;
signal Tx_FIFO_Full_to_spi_clk      : std_logic;

signal spiXfer_done_frm_spi_clk : std_logic;
signal spiXfer_done_to_axi_clk  : std_logic;

signal SR_3_modf_frm_axi_clk    : std_logic;

signal spiXfer_done_to_axi_1 : std_logic;
signal spiXfer_done_to_axi_d1 : std_logic;
signal updown_cnt_en : std_logic;

signal drr_Overrun_int_to_axi_clk : std_logic;
signal drr_Overrun_int_frm_spi_clk: std_logic;
-----
begin
-----

     SPISR_0_CMD_Error_frm_spi_clk <= SPISR_0_CMD_Error_int;
     spisel_d1_reg_frm_spi_clk     <= spisel_d1_reg;
     spisel_pulse_frm_spi_clk      <= spisel_pulse_o_int;-- from SPI module
     slave_MODF_strobe_frm_spi_clk <= slave_MODF_strobe_int; -- from SPI module
     modf_strobe_frm_spi_clk       <= modf_strobe_int; -- spi module
     --Rx_FIFO_Full_frm_axi_clk      <= Rx_FIFO_Full; -- from Async Receive FIFO
     ----RX_FIFO_FULL Logic signals
     Rx_FIFO_Full_frm_axi_clk      <= Rx_FIFO_Full_Fifo; -- from Async Receive FIFO
     Tx_FIFO_Empty_frm_spi_clk     <= Tx_FIFO_Empty_intr; -- Tx_FIFO_Empty; -- from Async Transmit FIFO
     spiXfer_done_frm_spi_clk      <= spiXfer_done_int; -- from SPI module
     dtr_underrun_frm_spi_clk      <= dtr_underrun_int; -- from SPI module
     Tx_FIFO_Empty_SPISR_frm_spi_clk <= Tx_FIFO_Empty;-- from TX FIFO for SPI Status register
     drr_Overrun_int_frm_spi_clk   <= drr_Overrun_int;

    -- SPICR_6_RXFIFO_RST_frm_axi_clk<= SPICR_6_RXFIFO_RST_frm_axi_clk; -- from SPICR
     reset_RcFIFO_ptr_frm_axi_clk  <= reset_RcFIFO_ptr_int; -- from AXI clock
     Rx_FIFO_Empty_frm_axi_clk     <= Rx_FIFO_Empty; -- from Async Receive FIFO AXI side
     Tx_FIFO_Full_frm_axi_clk      <= Tx_FIFO_Full; -- from Async Transmit FIFO AXI side
     SR_3_modf_frm_axi_clk         <= SR_3_modf_int;

--CLK_CROSS_I:
CLK_CROSS_I:entity axi_quad_spi_v3_2_9.cross_clk_sync_fifo_1
     generic map(
             C_FAMILY                     => C_FAMILY           ,
             C_FIFO_DEPTH                 => C_FIFO_DEPTH       ,
             Async_Clk                    => Async_Clk          ,
             C_DATA_WIDTH                 => C_S_AXI_DATA_WIDTH ,
             C_S_AXI_DATA_WIDTH           => C_S_AXI_DATA_WIDTH ,
             C_NUM_TRANSFER_BITS          => C_NUM_TRANSFER_BITS,
             C_NUM_SS_BITS                => C_NUM_SS_BITS

     )
     port map(
              EXT_SPI_CLK               => EXT_SPI_CLK        ,                 -- in std_logic;
              Bus2IP_Clk                => Bus2IP_Clk         ,                 -- in std_logic;
              Soft_Reset_op             => reset2ip_reset_int ,
              --Soft_Reset_op       => Soft_Reset_op      ,                     -- in std_logic;
              Rst_cdc_to_spi                => Rst_to_spi_int     ,                 -- out std_logic;
              ----------------------------
              SPISR_0_CMD_Error_cdc_from_spi => SPISR_0_CMD_Error_frm_spi_clk ,
              SPISR_0_CMD_Error_cdc_to_axi  => SPISR_0_CMD_Error_to_axi_clk  ,
              ----------------------------------------------------------
              spisel_d1_reg_cdc_from_spi     => spisel_d1_reg_frm_spi_clk  , -- in
              spisel_d1_reg_cdc_to_axi      => spisel_d1_reg_to_axi_clk   , -- out
              ----------------------------------------------------------
              spisel_pulse_cdc_from_spi      => spisel_pulse_frm_spi_clk   , -- in
              spisel_pulse_cdc_to_axi       => spisel_pulse_to_axi_clk    , -- out
              ----------------------------
              Mst_N_Slv_mode_cdc_from_spi    => Mst_N_Slv_mode_frm_spi_clk , -- in
              Mst_N_Slv_mode_cdc_to_axi     => Mst_N_Slv_mode_to_axi_clk  , -- out
              ----------------------------
              slave_MODF_strobe_cdc_from_spi => slave_MODF_strobe_frm_spi_clk, -- in
              slave_MODF_strobe_cdc_to_axi  => slave_MODF_strobe_to_axi_clk , -- out
              ----------------------------
              modf_strobe_cdc_from_spi       => modf_strobe_frm_spi_clk , -- in
              modf_strobe_cdc_to_axi        => modf_strobe_to_axi_clk  , -- out
              ----------------------------
              SPICR_6_RXFIFO_RST_cdc_from_axi=> SPICR_6_RXFIFO_RST_frm_axi_clk, -- in
              SPICR_6_RXFIFO_RST_cdc_to_spi => SPICR_6_RXFIFO_RST_to_spi_clk , -- out
              ----------------------------
              Rx_FIFO_Full_cdc_from_axi      => Rx_FIFO_Full_frm_axi_clk, -- in
              Rx_FIFO_Full_cdc_to_spi       => Rx_FIFO_Full_to_spi_clk , -- out
              ----------------------------
              reset_RcFIFO_ptr_cdc_from_axi  => reset_RcFIFO_ptr_frm_axi_clk, -- in
              reset_RcFIFO_ptr_cdc_to_spi   => reset_RcFIFO_ptr_to_spi_clk , -- out
              ----------------------------
              Rx_FIFO_Empty_cdc_from_axi     => Rx_FIFO_Empty_frm_axi_clk , -- in
              Rx_FIFO_Empty_cdc_to_spi      => Rx_FIFO_Empty_to_spi_clk , -- out
              ----------------------------
              Tx_FIFO_Empty_cdc_from_spi     => Tx_FIFO_Empty_frm_spi_clk, -- in
              Tx_FIFO_Empty_cdc_to_axi      => Tx_FIFO_Empty_to_Axi_clk, -- out
              ----------------------------
              Tx_FIFO_Empty_SPISR_cdc_from_spi => Tx_FIFO_Empty_SPISR_frm_spi_clk,
              Tx_FIFO_Empty_SPISR_cdc_to_axi  => Tx_FIFO_Empty_SPISR_to_axi_clk,

              Tx_FIFO_Full_cdc_from_axi      => Tx_FIFO_Full_frm_axi_clk,-- in
              Tx_FIFO_Full_cdc_to_spi       => Tx_FIFO_Full_to_spi_clk ,-- out
              ----------------------------
              spiXfer_done_cdc_from_spi      => spiXfer_done_frm_spi_clk, -- in
              spiXfer_done_cdc_to_axi       => spiXfer_done_to_axi_clk, -- out
              ----------------------------
              dtr_underrun_cdc_from_spi      => dtr_underrun_frm_spi_clk, -- in
              dtr_underrun_cdc_to_axi       => dtr_underrun_to_axi_clk , -- out
              ----------------------------
              SPICR_0_LOOP_cdc_from_axi      => SPICR_0_LOOP_frm_axi_clk,-- in std_logic;
              SPICR_0_LOOP_cdc_to_spi       => SPICR_0_LOOP_to_spi_clk ,-- out
              ----------------------------
              SPICR_1_SPE_cdc_from_axi       => SPICR_1_SPE_frm_axi_clk ,-- in std_logic;
              SPICR_1_SPE_cdc_to_spi        => SPICR_1_SPE_to_spi_clk  ,-- out
              ----------------------------
              SPICR_2_MST_N_SLV_cdc_from_axi => SPICR_2_MST_N_SLV_frm_axi_clk,-- in std_logic;
              SPICR_2_MST_N_SLV_cdc_to_spi  => SPICR_2_MST_N_SLV_to_spi_clk, -- out
              ----------------------------
              SPICR_3_CPOL_cdc_from_axi      => SPICR_3_CPOL_frm_axi_clk,-- in std_logic;
              SPICR_3_CPOL_cdc_to_spi       => SPICR_3_CPOL_to_spi_clk ,-- out
              ----------------------------
              SPICR_4_CPHA_cdc_from_axi      => SPICR_4_CPHA_frm_axi_clk,-- in std_logic;
              SPICR_4_CPHA_cdc_to_spi       => SPICR_4_CPHA_to_spi_clk ,-- out
              ----------------------------
              SPICR_5_TXFIFO_cdc_from_axi    => SPICR_5_TXFIFO_RST_frm_axi_clk,-- in std_logic;
              SPICR_5_TXFIFO_cdc_to_spi     => SPICR_5_TXFIFO_to_spi_clk,  -- out
              ----------------------------
              SPICR_7_SS_cdc_from_axi        => SPICR_7_SS_frm_axi_clk ,-- in std_logic;
              SPICR_7_SS_cdc_to_spi         => SPICR_7_SS_to_spi_clk ,-- out
              ----------------------------
              SPICR_8_TR_INHIBIT_cdc_from_axi=> SPICR_8_TR_INHIBIT_frm_axi_clk,-- in std_logic;
              SPICR_8_TR_INHIBIT_cdc_to_spi => SPICR_8_TR_INHIBIT_to_spi_clk,-- out
              ----------------------------
              SPICR_9_LSB_cdc_from_axi       => SPICR_9_LSB_frm_axi_clk,-- in std_logic;
              SPICR_9_LSB_cdc_to_spi        => SPICR_9_LSB_to_spi_clk,-- out
              ----------------------------
              SPICR_bits_7_8_cdc_from_axi    => SPICR_bits_7_8_frm_axi_clk,-- in std_logic_vector
              SPICR_bits_7_8_cdc_to_spi     => SPICR_bits_7_8_to_spi_clk,-- out
              ----------------------------
              SR_3_modf_cdc_from_axi         => SR_3_modf_frm_axi_clk, -- in
              SR_3_modf_cdc_to_spi          => SR_3_modf_to_spi_clk , -- out
              ----------------------------
              SPISSR_cdc_from_axi            => SPISSR_frm_axi_clk, -- in
              SPISSR_cdc_to_spi             => register_Data_slvsel_int, -- out
              ----------------------------
              spiXfer_done_cdc_to_axi_1     => spiXfer_done_to_axi_1,
              ----------------------------
              drr_Overrun_int_cdc_from_spi   => drr_Overrun_int_frm_spi_clk,
              drr_Overrun_int_cdc_to_axi    => drr_Overrun_int_to_axi_clk
              ----------------------------
);

     -- Bu2IP Data to Interrupt Registers - IPISR and IPIER
     -- Bus2IP_Data - 0                 31
     -- IPISR/IPIER - 0        17 18    31
     --                <---NA---> <-used->
     --                           18    19      20    21         22        23        24          25         26       27   28       29    30    31
     --                           CMD_  Loop_Bk MSB   Slave_Mode CPOL_CPHA DRR_Not   Slave       Tx_FIFO    DRR_     DRR_ DTR_     DTR   Slave MODF
     --                           Error Error   Error Error      Error     _Empty    Select_mode Half_Empty Over_Run Full Underrun Empty MODF
     --                                                                    In Slave
     --                                                                    mode_only
     --                           <--------------------------------------->         <------------------------------------------------------------->
     --                            In C_SPI_MODE 1 or 2 only                             Present in all conditions

     -- IPISR Write
     -- when FIFO = 1,all other the IPIER, IPISR interrupt bits are applicable based upon the SPI mode.
     -- DRR_Not_Empty bit (bit 23) - available only in case of core is selected in
     --                    slave mode and control register mst_n_slv bit is '0'.
     -- Slave_select_mode bit-available only in case of core is selected in slave mode

     -- common assignment to SPI_MODE 1/2 and SPI_MODE = 0
     bus2IP_Data_for_interrupt_core(0 to 17) <= Bus2IP_Data(0 to 17);

     DUAL_MD_IPISR_GEN: if C_SPI_MODE = 1 or C_SPI_MODE = 2 generate
     -----------------------
     begin
     -----
          bus2IP_Data_for_interrupt_core(18 to 22) <= Bus2IP_Data(18 to 22);

     end generate DUAL_MD_IPISR_GEN;
     ---------------------------------------------

     STD_MD_IPISR_GEN: if C_SPI_MODE = 0 generate
     -----------------------------------
     begin
     -----
          bus2IP_Data_for_interrupt_core(18 to 22)<= (others => '0');

     end generate STD_MD_IPISR_GEN;
     ------------------------------------------------

     bus2IP_Data_for_interrupt_core(23)      <= Bus2IP_Data(23)     and             -- exists only when FIFO = exists                      AND
                                                ((not spisel_d1_reg_to_axi_clk) --spisel_d1_reg)
                                                  or                                -- core is selected by asserting SPISEL by ext. master AND
                                                 (not SPICR_2_MST_N_SLV_frm_axi_clk) --Mst_N_Slv_mode)           -- core is in slave mode
                                                );
     bus2IP_Data_for_interrupt_core(24 to (C_S_AXI_DATA_WIDTH-1)) <=
                                      Bus2IP_Data(24 to (C_S_AXI_DATA_WIDTH-1));
     --

     ----------------------------------------------------
     -- _____|-------------  data_Exists_RcFIFO_int
     -- ________|----------  data_Exists_RcFIFO_int_d1
     -- _____|--|__________  data_Exists_RcFIFO_pulse
     ----------------------------------------------------
     DRR_NOT_EMPTY_PULSE_P: process(Bus2IP_Clk) is
     -----
     begin
     -----
         if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if (reset2ip_reset_int = RESET_ACTIVE) then
                 data_Exists_RcFIFO_int_d1   <= '0';
             else
                 data_Exists_RcFIFO_int_d1   <= not rx_fifo_empty_i; -- data_Exists_RcFIFO_int;
             end if;
         end if;
     end process DRR_NOT_EMPTY_PULSE_P;
     ------------------------------------
     data_Exists_RcFIFO_pulse  <= not rx_fifo_empty_i and
                                 (not data_Exists_RcFIFO_int_d1);
     ------------------------------------

     ---------------------------------------------------------------------------

     DUAL_MD_INTR_GEN: if C_SPI_MODE = 1 or C_SPI_MODE = 2 generate
     -----------------------
        signal SPISR_4_CPOL_CPHA_Error_d1    : std_logic;
        signal SPISR_3_Slave_Mode_Error_d1   : std_logic;
        signal SPISR_2_MSB_Error_d1          : std_logic;
        signal SPISR_1_LOOP_Back_Error_d1    : std_logic;
        signal SPISR_0_CMD_Error_d1          : std_logic;

        signal SPISR_4_CPOL_CPHA_Error_pulse : std_logic;
        signal SPISR_3_Slave_Mode_Error_pulse: std_logic;
        signal SPISR_2_MSB_Error_pulse       : std_logic;
        signal SPISR_1_LOOP_Back_Error_pulse : std_logic;
        signal SPISR_0_CMD_Error_pulse       : std_logic;
     -----
     begin
     -----
     INTR_UPPER_BITS_P: process(Bus2IP_Clk) is
     -----
     begin
     -----
         if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
           if (reset2ip_reset_int = RESET_ACTIVE) then
               SPISR_0_CMD_Error_d1        <= '0';
               SPISR_1_LOOP_Back_Error_d1  <= '0';
               SPISR_2_MSB_Error_d1        <= '0';
               SPISR_3_Slave_Mode_Error_d1 <= '0';
               SPISR_4_CPOL_CPHA_Error_d1  <= '0';
           else
               SPISR_0_CMD_Error_d1        <= SPISR_0_CMD_Error_to_axi_clk; -- SPISR_0_CMD_Error_int;
               SPISR_1_LOOP_Back_Error_d1  <= SPISR_1_LOOP_Back_Error_int; -- from SPICR
               SPISR_2_MSB_Error_d1        <= SPISR_2_MSB_Error_int;       -- from SPICR
               SPISR_3_Slave_Mode_Error_d1 <= SPISR_3_Slave_Mode_Error_int;-- from SPICR
               SPISR_4_CPOL_CPHA_Error_d1  <= SPISR_4_CPOL_CPHA_Error_int; -- from SPICR
           end if;
         end if;
     end process INTR_UPPER_BITS_P;
     ------------------------------------
     SPISR_0_CMD_Error_pulse        <= SPISR_0_CMD_Error_to_axi_clk -- SPISR_0_CMD_Error_int
                                       and (not SPISR_0_CMD_Error_d1);
     SPISR_1_LOOP_Back_Error_pulse  <= SPISR_1_LOOP_Back_Error_int
                                       and (not SPISR_1_LOOP_Back_Error_d1);
     SPISR_2_MSB_Error_pulse        <= SPISR_2_MSB_Error_int
                                       and (not SPISR_2_MSB_Error_d1);
     SPISR_3_Slave_Mode_Error_pulse <= SPISR_3_Slave_Mode_Error_int
                                       and (not SPISR_3_Slave_Mode_Error_d1);
     SPISR_4_CPOL_CPHA_Error_pulse  <= SPISR_4_CPOL_CPHA_Error_int
                                       and (not SPISR_4_CPOL_CPHA_Error_d1);

     -- Interrupt Status Register(IPISR) Mapping
     ip2Bus_IntrEvent_int(13) <= SPISR_0_CMD_Error_pulse;
     ip2Bus_IntrEvent_int(12) <= SPISR_1_LOOP_Back_Error_pulse;
     ip2Bus_IntrEvent_int(11) <= SPISR_2_MSB_Error_pulse;
     ip2Bus_IntrEvent_int(10) <= SPISR_3_Slave_Mode_Error_pulse;
     ip2Bus_IntrEvent_int(9)  <= SPISR_4_CPOL_CPHA_Error_pulse ;

     end generate DUAL_MD_INTR_GEN;
     --------------------------------------------

     STD_MD_INTR_GEN: if C_SPI_MODE = 0 generate
     -----------------------
     begin
     -----
         ip2Bus_IntrEvent_int(13) <= '0';
         ip2Bus_IntrEvent_int(12) <= '0';
         ip2Bus_IntrEvent_int(11) <= '0';
         ip2Bus_IntrEvent_int(10) <= '0';
         ip2Bus_IntrEvent_int(9)  <= '0';

     end generate STD_MD_INTR_GEN;
     -----------------------------------------------

     ip2Bus_IntrEvent_int(8)  <= data_Exists_RcFIFO_pulse and
                                 ((not spisel_d1_reg_to_axi_clk) -- spisel_d1_reg)
                                   or
                                  (not SPICR_2_MST_N_SLV_frm_axi_clk) -- Mst_N_Slv_mode)
                                  );
     ip2Bus_IntrEvent_int(7)  <= spisel_pulse_to_axi_clk;-- and not SPICR_2_MST_N_SLV_frm_axi_clk; -- spisel_pulse_o_int;-- spi_module

     ip2Bus_IntrEvent_int(6)  <= tx_FIFO_less_half_int;    -- qspi_fifo_ifmodule
     ip2Bus_IntrEvent_int(5)  <= drr_Overrun_int_to_axi_clk; -- drr_Overrun_int;          -- qspi_fifo_ifmodule
     ip2Bus_IntrEvent_int(4)  <= rc_FIFO_Full_strobe_int;  -- qspi_fifo_ifmodule
     ip2Bus_IntrEvent_int(3)  <= dtr_Underrun_strobe_int;  -- qspi_fifo_ifmodule
     ip2Bus_IntrEvent_int(2)  <= tx_FIFO_Empty_strobe_int; -- qspi_fifo_ifmodule
     ip2Bus_IntrEvent_int(1)  <= slave_MODF_strobe_to_axi_clk; --slave_MODF_strobe_int;-- spi_module
     ip2Bus_IntrEvent_int(0)  <= modf_strobe_to_axi_clk;       -- modf_strobe_int;     -- spi_module

     --Combinatorial operations
     reset_TxFIFO_ptr_int <= reset2ip_reset_int or SPICR_5_TXFIFO_RST_frm_axi_clk;
     reset_TxFIFO_ptr_int_to_spi <= Rst_to_spi_int or SPICR_5_TXFIFO_to_spi_clk;
	 
     --reset_RcFIFO_ptr_int <= Rst_to_spi_int or SPICR_6_RXFIFO_RST_to_spi_clk; -- SPICR_6_RXFIFO_RST_int;
     reset_RcFIFO_ptr_int <= reset2ip_reset_int or SPICR_6_RXFIFO_RST_frm_axi_clk;
     sr_5_Tx_Empty_int    <= not (data_Exists_TxFIFO_int);
     Rc_FIFO_Empty_int    <= Rx_FIFO_Empty;--not (data_Exists_RcFIFO_int);


  --    AXI Clk domain   -- __________________ SPI clk domain
  --Dout                 --|AXI clk           |-- Din
  --Rd_en                --|                  |-- Wr_en
  --Rd_clk               --|                  |-- Wr_clk
                         --|                  |--
  --Rx_FIFO_Empty        --|    Rx FIFO       |-- Rx_FIFO_Full
  --Rx_FIFO_almost_Empty --|                  |-- Rx_FIFO_almost_Full
  --Rx_FIFO_occ_Reversed --|                  |--
  --Rx_FIFO_rd_ack       --|                  |--
                         --|                  |--
                         --|                  |--
                         --|                  |--
                         --|__________________|--

  RX_RD_EN_LEG_MD_GEN: if C_TYPE_OF_AXI4_INTERFACE = 0 generate
  begin
  -----

  IP2Bus_RdAck_receive_enable  <= (rd_ce_reduce_ack_gen and
                                  Bus2IP_RdCE(SPIDRR)
                                  )and
                                  (not Rx_FIFO_Empty);
  end generate RX_RD_EN_LEG_MD_GEN;

  RX_RD_EN_ENHAN_MD_GEN: if C_TYPE_OF_AXI4_INTERFACE = 1 generate
  begin
  -----

  IP2Bus_RdAck_receive_enable  <= --(rd_ce_reduce_ack_gen and
                                  (rready and
                                  Bus2IP_RdCE(SPIDRR)
                                  )and
                                  (not Rx_FIFO_Empty);
  end generate RX_RD_EN_ENHAN_MD_GEN;
-- Receive FIFO Logic
rx_fifo_reset <= Rst_to_spi_int or reset_RcFIFO_ptr_to_spi_clk;

RX_FIFO_II: entity lib_fifo_v1_0_6.async_fifo_fg --axi_quad_spi_v3_2_9_0.async_fifo_fg --lib_fifo_v1_0_6_4.async_fifo_fg
  generic map(
        -- for first word fall through FIFO below two parameters setting is must please dont change
	C_PRELOAD_LATENCY  => 0                  ,-- this is newly added and async_fifo_fg is referred from proc common v4_0
        C_PRELOAD_REGS     => 1                  ,-- this is newly added and async_fifo_fg is referred from proc common v4_0
        -- variables
        C_ALLOW_2N_DEPTH   => 1                  , -- : Integer := 0;  -- New paramter to leverage FIFO Gen 2**N depth
        C_FAMILY           => C_FAMILY           , -- : String  := "virtex5";  -- new for FIFO Gen
        C_DATA_WIDTH       => C_NUM_TRANSFER_BITS, -- : integer := 16;
        C_FIFO_DEPTH       => C_FIFO_DEPTH       , -- : integer := 15;
        C_RD_COUNT_WIDTH   => C_RD_COUNT_WIDTH_INT,-- : integer := 3 ;
        C_WR_COUNT_WIDTH   => C_WR_COUNT_WIDTH_INT,-- : integer := 3 ;
        C_HAS_ALMOST_EMPTY => 1                  , -- : integer := 1 ;
        C_HAS_ALMOST_FULL  => 1                  , -- : integer := 1 ;
        C_HAS_RD_ACK       => 1                  , -- : integer := 0 ;
        C_HAS_RD_COUNT     => 1                  , -- : integer := 1 ;
        C_HAS_WR_ACK       => 1                  , -- : integer := 0 ;
        C_HAS_WR_COUNT     => 1                  , -- : integer := 1 ;
        -- constants
        C_HAS_RD_ERR       => 0                  , -- : integer := 0 ;
        C_HAS_WR_ERR       => 0                  , -- : integer := 0 ;
        C_RD_ACK_LOW       => 0                  , -- : integer := 0 ;
        C_RD_ERR_LOW       => 0                  , -- : integer := 0 ;
        C_WR_ACK_LOW       => 0                  , -- : integer := 0 ;
        C_WR_ERR_LOW       => 0                  , -- : integer := 0
        C_ENABLE_RLOCS     => 0                  , -- : integer := 0 ;  -- not supported in FG
        C_USE_BLOCKMEM     => 0                    -- : integer := 1 ;  -- 0 = distributed RAM, 1 = BRAM
    )
  port map(
        Din                => Data_To_Rx_FIFO           , -- : in std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
        Wr_en              => spiXfer_done_int, --SPIXfer_done_Rx_Wr_en, --            , -- : in std_logic := '1';
        Wr_clk             => EXT_SPI_CLK                 , -- : in std_logic := '1';
        Wr_ack             => Rx_FIFO_wr_ack_open         , -- : out std_logic;
        ------
        Dout               => Data_From_Rx_FIFO           , -- : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
        Rd_en              => IP2Bus_RdAck_receive_enable , -- : in std_logic := '0';
        Rd_clk             => Bus2IP_Clk                  , -- : in std_logic := '1';
        Rd_ack             => Rx_FIFO_rd_ack              , -- : out std_logic;
        ------
        Full               => Rx_FIFO_Full_Fifo_org           , -- : out std_logic;
        Empty              => Rx_FIFO_Empty               , -- : out std_logic;
        Almost_full        => Rx_FIFO_almost_Full         , -- : out std_logic;
        Almost_empty       => Rx_FIFO_almost_Empty        , -- : out std_logic;
        Rd_count           => Rx_FIFO_occ_Reversed        , -- : out std_logic_vector(C_RD_COUNT_WIDTH-1 downto 0);
        ------
        Ainit              => rx_fifo_reset, -- reset_RcFIFO_ptr_to_spi_clk ,--reset_RcFIFO_ptr_int, -- reset_RcFIFO_ptr_to_spi_clk ,--Rx_FIFO_ptr_RST             , -- : in std_logic := '1';
        Wr_count           => open                        , -- : out std_logic_vector(C_WR_COUNT_WIDTH-1 downto 0);
        Rd_err             => open                        , -- : out std_logic;
        Wr_err             => open                          -- : out std_logic
    );

    RX_FIFO_EMPTY_SYNC_AXI_2_SPI_CDC : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1, -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => 2   
		)

    port map (
        prmry_aclk           => Bus2IP_Clk , 
        prmry_resetn         => '0',
        prmry_in             => Rx_FIFO_Empty,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => '0' ,
        scndry_out           => Rx_FIFO_Empty_Synced_in_SPI_domain 
       );



Rx_FIFO_Full_Fifo <= Rx_FIFO_Full_Fifo_org and not Rx_FIFO_Empty_Synced_in_SPI_domain;

RX_FULL_DELAY_PROCESS: process(EXT_SPI_CLK) is
----------------------
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK='1') then
             if (Rst_to_spi_int = '1') then
                 Rx_FIFO_Full_Fifo_d1   <= '0';
           else
               Rx_FIFO_Full_Fifo_d1 <= Rx_FIFO_Full_Fifo;
         end if;
     end if;
end process RX_FULL_DELAY_PROCESS;

RX_FULL_EDGE_PROCESS: process(Bus2IP_Clk) is
----------------------
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk='1') then
           if (reset2ip_reset_int = RESET_ACTIVE) then
                 Rx_FIFO_Full_Fifo_d1_flag   <= '0';
             else
                 Rx_FIFO_Full_Fifo_d1_flag <= Rx_FIFO_Full_Fifo_d1_synced;
         end if;
     end if;
end process RX_FULL_EDGE_PROCESS;

Rx_FIFO_Full_Fifo_pos_flag <= Rx_FIFO_Full_Fifo_d1_synced and (not Rx_FIFO_Full_Fifo_d1_flag);
--Rx_FIFO_Full_Fifo_neg_flag <= (not Rx_FIFO_Full_Fifo_d1_synced) and Rx_FIFO_Full_Fifo_d1_flag;

RX_FULL_GEN_PROCESS: process(Bus2IP_Clk) is
----------------------
begin
-----
     if(Bus2IP_Clk'event and Bus2IP_Clk='1') then
           if (reset2ip_reset_int = RESET_ACTIVE) then
                 Rx_FIFO_Full_Fifo_d1_sig   <= '0';
             elsif(IP2Bus_RdAck_receive_enable = '1' and Rx_FIFO_Full_Fifo_d1_synced = '1')then
                 Rx_FIFO_Full_Fifo_d1_sig   <= '0';
             elsif(Rx_FIFO_Full_Fifo_pos_flag = '1') then
                 Rx_FIFO_Full_Fifo_d1_sig <= '1';
         end if;
     end if;
end process RX_FULL_GEN_PROCESS;

----------------------------------

    RX_FIFO_FULL_SYNCED_SPI_2_AXI_CDC : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1, -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => 2   
		)

    port map (
        prmry_aclk           => EXT_SPI_CLK , 
        prmry_resetn         => '0',
        prmry_in             => Rx_FIFO_Full_Fifo_d1,
        scndry_aclk          => Bus2IP_Clk ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => '0' ,
        scndry_out           => Rx_FIFO_Full_Fifo_d1_synced 
       );

 RX_FIFO_FULL_CNTR_I : entity axi_quad_spi_v3_2_9.counter_f
      generic map(
        C_NUM_BITS    =>  RX_FIFO_CNTR_WIDTH,
        C_FAMILY      =>  "nofamily"
          )
      port map(
        Clk           =>  Bus2IP_Clk,      -- in
        Rst           =>  '0',             -- in
        Load_In       =>  ALL_0,           -- in
        Count_Enable  =>  updown_cnt_en_rx,     -- in
        ----------------
        Count_Load    =>  reset_RcFIFO_ptr_int, -- in
        ----------------
        Count_Down    =>  IP2Bus_RdAck_receive_enable,   -- in
        Count_Out     =>  rx_fifo_count,             -- out std_logic_vector
        Carry_Out     =>  open             -- out
        );

        --updown_cnt_en_rx <= IP2Bus_RdAck_receive_enable xor spiXfer_done_to_axi_1;
      --fifo_full_f_int <= Rx_FIFO_Full_Fifo_d1_synced when      

      --updown_cnt_en_rx <= ((not spiXfer_done_to_axi_1) and IP2Bus_RdAck_receive_enable and Rx_FIFO_Full_int and (not Rx_FIFO_Full_Fifo_d1_synced)) or ((IP2Bus_RdAck_receive_enable xor spiXfer_done_to_axi_1) and (not Rx_FIFO_Full_Fifo_d1_synced) and (not Rx_FIFO_Full_int));
      updown_cnt_en_rx <= ((not spiXfer_done_to_axi_1) and IP2Bus_RdAck_receive_enable and Rx_FIFO_Full_int and (not (Rx_FIFO_Full_Fifo_d1_sig or Rx_FIFO_Full_Fifo_pos_flag))) or ((IP2Bus_RdAck_receive_enable xor spiXfer_done_to_axi_1) and (not (Rx_FIFO_Full_Fifo_d1_sig or Rx_FIFO_Full_Fifo_pos_flag)) and (not Rx_FIFO_Full_int));
   -- updown_cnt_en_rx <= (IP2Bus_RdAck_receive_enable and Rx_FIFO_Full_int)
                        -- or (spiXfer_done_to_axi_1 and (not Rx_FIFO_Full_int)) 
                        -- or ((IP2Bus_RdAck_receive_enable xor spiXfer_done_to_axi_1) and (not Rx_FIFO_Full_int));

   RX_one_less_than_full <= and_reduce(rx_fifo_count(RX_FIFO_CNTR_WIDTH-1 downto RX_FIFO_CNTR_WIDTH-RX_FIFO_CNTR_WIDTH+1)) and
                            (not rx_fifo_count(0))and spiXfer_done_to_axi_1;



   RX_FULL_EMP_MD_12_INTR_GEN: if C_SPI_MODE /= 0 generate
   -----
   --signal rx_fifo_empty_i : std_logic;
   begin
   -----
   RX_FIFO_EMPTY_P:process(Bus2IP_Clk)is
   begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(reset2ip_reset_int = RESET_ACTIVE)then
                 rx_fifo_empty_i <= '1';
             elsif(reset_RcFIFO_ptr_int = '1')then
                 rx_fifo_empty_i <= '1';
             elsif(spiXfer_done_to_axi_1 = '1')then
                 rx_fifo_empty_i <= '0';
             end if;
        end if;
   end process RX_FIFO_EMPTY_P;

   RX_FIFO_FULL_P:process(Bus2IP_Clk)is
   begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(reset2ip_reset_int = RESET_ACTIVE)then
                 Rx_FIFO_Full_int <= '0';
             --elsif(reset_RcFIFO_ptr_int = '1') or (drr_Overrun_int_to_axi_clk = '1') then --(drr_Overrun_int = '1')then
             elsif(reset_RcFIFO_ptr_int = '1')  then --(drr_Overrun_int = '1')then
                 Rx_FIFO_Full_int <= '0';
            elsif(Rx_FIFO_Full_int = '1' and IP2Bus_RdAck_receive_enable = '1') then -- IP2Bus_RdAck_receive_enable = '1')then
                 Rx_FIFO_Full_int <= '0';
             elsif(RX_one_less_than_full = '1' and
                   spiXfer_done_to_axi_1 = '1' and
                   rx_fifo_empty_i = '0')then
                 Rx_FIFO_Full_int <= '1';
             end if;
        end if;
   end process RX_FIFO_FULL_P;

   end generate RX_FULL_EMP_MD_12_INTR_GEN;
   ------------------------------------

   RX_FULL_EMP_MD_0_GEN: if C_SPI_MODE = 0 generate
   --signal rx_fifo_empty_i : std_logic;
   -----
   begin
   -----
   RX_FIFO_EMPTY_P:process(Bus2IP_Clk)is
   begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(reset2ip_reset_int = RESET_ACTIVE)then
                 rx_fifo_empty_i <= '1';
             elsif(reset_RcFIFO_ptr_int = '1')then
                 rx_fifo_empty_i <= '1';
             elsif(spiXfer_done_to_axi_1 = '1')then
                 rx_fifo_empty_i <= '0';
             end if;
        end if;
   end process RX_FIFO_EMPTY_P;


   -------------------------------------------
   RX_FIFO_ABT_TO_FULL_P:process(Bus2IP_Clk)is
   begin
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(reset2ip_reset_int = RESET_ACTIVE)then
                    Rx_FIFO_Full_i <= '0';
             --elsif(reset_RcFIFO_ptr_int = '1') or (drr_Overrun_int_to_axi_clk = '1') then -- (drr_Overrun_int = '1')then
             elsif(reset_RcFIFO_ptr_int = '1') then -- (drr_Overrun_int = '1')then
                    Rx_FIFO_Full_i <= '0';
             elsif(Rx_FIFO_Full_int = '1')then
                    Rx_FIFO_Full_i <= '0';
             elsif(RX_one_less_than_full = '1')then
                    Rx_FIFO_Full_i <= '1';
             end if;
        end if;
   end process RX_FIFO_ABT_TO_FULL_P;
   -------------------------------------
   RX_FIFO_FULL_P: process(Bus2IP_Clk)is
   begin
   -----
        if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
            if(reset2ip_reset_int = RESET_ACTIVE)then
                Rx_FIFO_Full_int <= '0';
            --elsif(reset_RcFIFO_ptr_int = '1') or (drr_Overrun_int_to_axi_clk = '1') then -- (drr_Overrun_int = '1')then
            elsif(reset_RcFIFO_ptr_int = '1')  then -- (drr_Overrun_int = '1')then
                 Rx_FIFO_Full_int <= '0';
            elsif(Rx_FIFO_Full_int = '1' and IP2Bus_RdAck_receive_enable = '1') then -- IP2Bus_RdAck_receive_enable = '1')then
                Rx_FIFO_Full_int <= '0';
            elsif(Rx_FIFO_Full_i = '1')then
                Rx_FIFO_Full_int <= '1';
            end if;
        end if;
   end process RX_FIFO_FULL_P;
   ---------------------------------
   Rx_FIFO_Full <= Rx_FIFO_Full_int;

   end generate RX_FULL_EMP_MD_0_GEN;

   Rx_FIFO_Empty_int <= Rx_FIFO_Empty or Rx_FIFO_Empty_i;

  -----------------------------------------------------------------------------
  --    AXI Clk domain   -- __________________ SPI clk domain
  --Din                  --|AXI clk           |-- Dout
  --Wr_en                --|                  |-- Rd_en
  --Wr_clk               --|                  |-- Rd_clk
                         --|                  |--
  --Tx_FIFO_Full         --|    Tx FIFO       |-- Tx_FIFO_Empty
  --Tx_FIFO_almost_Full  --|                  |-- Tx_FIFO_almost_Empty
  --Tx_FIFO_occ_Reversed --|                  |-- Tx_FIFO_rd_ack
  --Tx_FIFO_wr_ack       --|                  |--
                         --|                  |--
                         --|                  |--
                         --|                  |--
                         --|__________________|--
  TX_TR_EN_LEG_MD_GEN: if C_TYPE_OF_AXI4_INTERFACE = 0 generate
  begin
  -----
  IP2Bus_WrAck_transmit_enable <= (wr_ce_reduce_ack_gen and
                                  Bus2IP_WrCE(SPIDTR)
                                  ) and
                                 (not Tx_FIFO_Full);-- after 100 ps;
  end generate TX_TR_EN_LEG_MD_GEN;

  TX_TR_EN_ENHAN_MD_GEN: if C_TYPE_OF_AXI4_INTERFACE = 1 generate
  signal local_tr_en : std_logic;
  begin
  -----
  --IP2Bus_WrAck_transmit_enable <= (wr_ce_reduce_ack_gen and
  --                                Bus2IP_WrCE(SPIDTR)
  --                                ) and
  --                                (not Tx_FIFO_Full)
  --                               when burst_tr = '0' else
  --                                (Bus2IP_WrCE(SPIDTR)
  --                                 and
  --                                (not Tx_FIFO_Full));-- after 100 ps;
  local_tr_en  <= Bus2IP_WrCE(SPIDTR) and (not Tx_FIFO_Full);
  --local_tr_en1 <= Bus2IP_WrCE_d1      and (not Tx_FIFO_Full);
  TR_EN_P:process(wr_ce_reduce_ack_gen,
                  local_tr_en,
                  burst_tr,
                  WVALID)is
  begin
       if(burst_tr = '1') then
           IP2Bus_WrAck_transmit_enable <= local_tr_en and WVALID; -- Bus2IP_WrCE_d1 and (not Tx_FIFO_Full); --local_tr_en;
       else
           IP2Bus_WrAck_transmit_enable <= local_tr_en and wr_ce_reduce_ack_gen;
       end if;
  end process TR_EN_P;
  end generate TX_TR_EN_ENHAN_MD_GEN;

Data_To_TxFIFO <= Bus2IP_Data((C_S_AXI_DATA_WIDTH-C_NUM_TRANSFER_BITS) to(C_S_AXI_DATA_WIDTH-1));-- after 100 ps;
-- Transmit FIFO Logic
tx_fifo_reset <= reset2ip_reset_int or reset_TxFIFO_ptr_int;
TX_FIFO_II: entity lib_fifo_v1_0_6.async_fifo_fg -- entity axi_quad_spi_v3_2_9_0.async_fifo_fg -- lib_fifo_v1_0_6_4.async_fifo_fg
  generic map
      (
        -- for first word fall through FIFO below two parameters setting is must please dont change
	C_PRELOAD_LATENCY  => 0                  ,-- this is newly added and async_fifo_fg is referred from proc common v4_0
        C_PRELOAD_REGS     => 1                  ,-- this is newly added and async_fifo_fg is referred from proc common v4_0
	-- variables
        C_ALLOW_2N_DEPTH   => 1                  , -- : Integer := 0;  -- New paramter to leverage FIFO Gen 2**N depth
        C_FAMILY           => C_FAMILY           , -- : String  := "virtex5";  -- new for FIFO Gen
        C_DATA_WIDTH       => C_NUM_TRANSFER_BITS, -- : integer := 16;
        C_FIFO_DEPTH       => C_FIFO_DEPTH       , -- : integer := 15;
        C_RD_COUNT_WIDTH   => C_RD_COUNT_WIDTH_INT,-- : integer := 3 ;
        C_WR_COUNT_WIDTH   => C_WR_COUNT_WIDTH_INT,-- : integer := 3 ;
        C_HAS_ALMOST_EMPTY => 1                  , -- : integer := 1 ;
        C_HAS_ALMOST_FULL  => 1                  , -- : integer := 1 ;
        C_HAS_RD_ACK       => 1                  , -- : integer := 0 ;
        C_HAS_RD_COUNT     => 1                  , -- : integer := 1 ;
        C_HAS_WR_ACK       => 1                  , -- : integer := 0 ;
        C_HAS_WR_COUNT     => 1                  , -- : integer := 1 ;
        -- constants
        C_HAS_RD_ERR       => 0                  , -- : integer := 0 ;
        C_HAS_WR_ERR       => 0                  , -- : integer := 0 ;
        C_RD_ACK_LOW       => 0                  , -- : integer := 0 ;
        C_RD_ERR_LOW       => 0                  , -- : integer := 0 ;
        C_WR_ACK_LOW       => 0                  , -- : integer := 0 ;
        C_WR_ERR_LOW       => 0                  , -- : integer := 0
        C_ENABLE_RLOCS     => 0                  , -- : integer := 0 ;  -- not supported in FG
        C_USE_BLOCKMEM     => 0                    -- : integer := 1 ;  -- 0 = distributed RAM, 1 = BRAM
      )
  port map
      (
        -- writing will be through AXI clock
        Wr_clk             => Bus2IP_Clk                  , -- : in std_logic := '1';
        Din                => Data_To_TxFIFO              , -- : in std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
        Wr_en              => IP2Bus_WrAck_transmit_enable, -- : in std_logic := '1';
        Wr_ack             => Tx_FIFO_wr_ack              , -- : out std_logic;
        ------
        -- reading will be through SPI clock
        Rd_clk             => EXT_SPI_CLK                 , -- : in std_logic := '1';
        Dout               => Data_From_TxFIFO            , -- : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
        Rd_en              => SPIXfer_done_rd_tx_en            , -- : in std_logic := '0';
        Rd_ack             => Tx_FIFO_rd_ack_open         , -- : out std_logic;
        ------
        Full               => Tx_FIFO_Full                , -- : out std_logic;
        Empty              => Tx_FIFO_Empty               , -- : out std_logic;
        Almost_full        => Tx_FIFO_almost_Full         , -- : out std_logic;
        Almost_empty       => Tx_FIFO_almost_Empty        , -- : out std_logic;
        Rd_count           => open        , -- : out std_logic_vector(C_RD_COUNT_WIDTH-1 downto 0);
        ------
        Ainit              => reset_TxFIFO_ptr_int        ,--Tx_FIFO_ptr_RST             , -- : in std_logic := '1';
        Wr_count           => Tx_FIFO_occ_Reversed        , -- : out std_logic_vector(C_WR_COUNT_WIDTH-1 downto 0);
        Rd_err             => open                        , -- : out std_logic;
        Wr_err             => open                          -- : out std_logic
    );

    --tx_occ_msb             <= tx_fifo_count(TX_FIFO_CNTR_WIDTH-1); -- --Tx_FIFO_occ_Reversed(C_WR_COUNT_WIDTH_INT-1);
    --tx_occ_msb_1             <= (tx_fifo_count(TX_FIFO_CNTR_WIDTH-1));-- and not(or_reduce(tx_fifo_count(TX_FIFO_CNTR_WIDTH-2 downto 0))) ;--
                              --and not Tx_FIFO_Empty_SPISR_to_axi_clk;-- and not Tx_FIFO_Full_int; -- --Tx_FIFO_occ_Reversed(C_WR_COUNT_WIDTH_INT-1);
    tx_occ_msb_11             <= (tx_fifo_count);

    FIFO_16_OCC_MSB_GEN: if C_FIFO_DEPTH = 16 generate
    begin
        tx_occ_msb_1 <= tx_occ_msb_11(3);
    end generate FIFO_16_OCC_MSB_GEN;

    FIFO_256_OCC_MSB_GEN: if C_FIFO_DEPTH = 256 generate
    begin
        tx_occ_msb_1 <= tx_occ_msb_11(7);
    end generate FIFO_256_OCC_MSB_GEN;

    TX_OCC_MSB_P: process (Bus2IP_Clk)is
    begin
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
               if(reset2ip_reset_int = RESET_ACTIVE)then
                   tx_occ_msb_2 <= '0';
                   tx_occ_msb_3 <= '0';
                   tx_occ_msb_4 <= '0';
               else
                   tx_occ_msb_2 <= tx_occ_msb_1;
                   tx_occ_msb_3 <= tx_occ_msb_2;
                   tx_occ_msb_4 <= tx_occ_msb_3;
               end if;
         end if;
    end process TX_OCC_MSB_P;
    tx_occ_msb <= tx_occ_msb_4 and not Tx_FIFO_Empty_SPISR_to_axi_clk;

    data_Exists_TxFIFO_int <= not (Tx_FIFO_Empty);
    -----------------------------------------------------------
    TX_FIFO_EMPTY_CNTR_I : entity axi_quad_spi_v3_2_9.counter_f
      generic map(
        C_NUM_BITS    =>  TX_FIFO_CNTR_WIDTH,
        C_FAMILY      =>  "nofamily"
          )
      port map(
        Clk           =>  Bus2IP_Clk,      -- in
        Rst           =>  '0',             -- in
        Load_In       =>  ALL_0,           -- in
        Count_Enable  =>  updown_cnt_en,     -- in
        ----------------
        Count_Load    =>  reset_TxFIFO_ptr_int, -- in
        ----------------
        Count_Down    =>  spiXfer_done_to_axi_1,   -- in
        Count_Out     =>  tx_fifo_count,             -- out std_logic_vector
        Carry_Out     =>  open             -- out
        );

   updown_cnt_en <= IP2Bus_WrAck_transmit_enable xor spiXfer_done_to_axi_1;
   ----------------------------------------
   TX_FULL_EMP_INTR_MD_12_GEN: if C_SPI_MODE /=0 generate
   -----
   begin
   -----
   Tx_FIFO_Empty_intr <= not (or_reduce(tx_fifo_count(TX_FIFO_CNTR_WIDTH-1 downto 0)))
                                      -- and (tx_fifo_count(0))
                                      and spiXfer_done_to_axi_1
                                      and ( Tx_FIFO_Empty_SPISR_to_axi_clk); -- and ( Tx_FIFO_Empty);

   Tx_FIFO_Full_int       <= Tx_FIFO_Full;

   end generate TX_FULL_EMP_INTR_MD_12_GEN;
   ----------------------------------------

   ----------------------------------------
   TX_FULL_EMP_INTR_MD_0_GEN: if C_SPI_MODE =0 generate
   -----
   begin
   -----
    -- Tx_FIFO_one_less_to_Empty <= not(or_reduce(tx_fifo_count(TX_FIFO_CNTR_WIDTH-1 downto 0)))
    --                                    --and (tx_fifo_count(0))
    --                                    and spiXfer_done_to_axi_1;--tx_cntr_xfer_done_to_axi_1_clk; --
    -- --------------------------------------------
    -- TX_FIFO_ABT_TO_EMPTY_P:process(Bus2IP_Clk)is
    -- begin
    --       if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
    --            if(reset2ip_reset_int = RESET_ACTIVE)then
    --             Tx_FIFO_Empty_i <= '0';
    --            elsif(Tx_FIFO_Empty_int = '1')then
    --               Tx_FIFO_Empty_i <= '0';
    --            elsif(Tx_FIFO_one_less_to_Empty = '1') or then
    --              Tx_FIFO_Empty_i <= '1';
    --            end if;
    --       end if;
    -- end process TX_FIFO_ABT_TO_EMPTY_P;
    -- --------------------------------------
    -- TX_FIFO_EMPTY_P: process(Bus2IP_Clk)is
    -- begin
    -- -----
    --      if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
    --          if(reset2ip_reset_int = RESET_ACTIVE)then
    --              Tx_FIFO_Empty_int <= '0';
    --          elsif(Tx_FIFO_Empty_int = '1' and spiXfer_done_to_axi_1 = '1')then
    --              Tx_FIFO_Empty_int <= '0';
    --          elsif(Tx_FIFO_Empty_i = '1')then
    --              Tx_FIFO_Empty_int <= '1';
    --          end if;
    --      end if;
    -- end process TX_FIFO_EMPTY_P;
    --------------------------------
    -- Tx_FIFO_Empty_intr <= Tx_FIFO_Empty_int and spiXfer_done_to_axi_1;
    --------------------------------
    TX_FIFO_CNTR_DELAY_P: process(Bus2IP_Clk)is
    begin
    -----
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(reset2ip_reset_int = RESET_ACTIVE)then
                 tx_fifo_count_d1 <= (others => '0');
		 tx_fifo_count_d2 <= (others => '0');
		 spiXfer_done_to_axi_d1 <= '0';
             else
		 tx_fifo_count_d1 <= tx_fifo_count;
		 tx_fifo_count_d2 <= tx_fifo_count_d1;
		 spiXfer_done_to_axi_d1 <= spiXfer_done_to_axi_1;
             end if;
         end if;
    end process TX_FIFO_CNTR_DELAY_P;

    Tx_FIFO_Empty_intr <= (not (or_reduce(tx_fifo_count_d2(TX_FIFO_CNTR_WIDTH-1 downto 0)))
                                          -- and (tx_fifo_count(0))
                                          and spiXfer_done_to_axi_d1
                                          and ( Tx_FIFO_Empty_SPISR_to_axi_clk));

    TX_one_less_than_full <= and_reduce(tx_fifo_count(TX_FIFO_CNTR_WIDTH-1 downto TX_FIFO_CNTR_WIDTH-TX_FIFO_CNTR_WIDTH+1)) and
                            (not tx_fifo_count(0))and IP2Bus_WrAck_transmit_enable;
    -------------------------------------------
    TX_FIFO_ABT_TO_FULL_P:process(Bus2IP_Clk)is
    begin
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
              if(reset2ip_reset_int = RESET_ACTIVE)then
                 Tx_FIFO_Full_i <= '0';
              elsif(reset_TxFIFO_ptr_int = '1')then
                 Tx_FIFO_Full_i <= '0';
              elsif(Tx_FIFO_Full_int = '1')then
                 Tx_FIFO_Full_i <= '0';
              elsif(TX_one_less_than_full = '1')then
             Tx_FIFO_Full_i <= '1';
              end if;
         end if;
    end process TX_FIFO_ABT_TO_FULL_P;
    ----------------------------------
    TX_FIFO_FULL_P: process(Bus2IP_Clk)is
    begin
    -----
         if(Bus2IP_Clk'event and Bus2IP_Clk = '1') then
             if(reset2ip_reset_int = RESET_ACTIVE)then
                 Tx_FIFO_Full_int <= '0';
             elsif(reset_TxFIFO_ptr_int = '1')then
                 Tx_FIFO_Full_int <= '0';
             elsif(Tx_FIFO_Full_int = '1' and spiXfer_done_to_axi_1 = '1')then
                 Tx_FIFO_Full_int <= '0';
             elsif(Tx_FIFO_Full_i = '1') then --  and spiXfer_done_to_axi_1 = '1')then
                 Tx_FIFO_Full_int <= '1';
             end if;
         end if;
    end process TX_FIFO_FULL_P;
    ---------------------------
   end generate TX_FULL_EMP_INTR_MD_0_GEN;
   ----------------------------------------

-------------------------------------------------------------------------------
-- I_FIFO_IF_MODULE : INSTANTIATE FIFO INTERFACE MODULE
-------------------------------------------------------------------------------
Rx_FIFO_Full_Fifo_d1_synced_i <= Rx_FIFO_Full_Fifo_d1_synced and (not Rx_FIFO_Empty); 
  FIFO_IF_MODULE_I: entity axi_quad_spi_v3_2_9.qspi_fifo_ifmodule
        generic map
             (
              C_NUM_TRANSFER_BITS   => C_NUM_TRANSFER_BITS
             )
        port map
             (
              Bus2IP_Clk            => Bus2IP_Clk   ,                           -- in
              Soft_Reset_op         => reset2ip_reset_int,                      -- in
              -- Slave attachment ports from AXI clock
              Bus2IP_RcFIFO_RdCE    => Bus2IP_RdCE(SPIDRR),-- axiclk            -- in
              Bus2IP_TxFIFO_WrCE    => Bus2IP_WrCE(SPIDTR),-- axi clk           -- in
              Rd_ce_reduce_ack_gen  => rd_ce_reduce_ack_gen,-- axi clk          -- in
              -- FIFO ports
              Data_From_TxFIFO      => Data_From_TxFIFO    ,-- spi clk          -- in vec
              Data_From_Rc_FIFO     => Data_From_Rx_FIFO   ,-- axi clk          -- in vec
              Tx_FIFO_Data_WithZero => transmit_Data_int   ,-- spi clk          -- out vec
              IP2Bus_RX_FIFO_Data   => IP2Bus_Receive_Reg_Data_int,             -- out vec
              ---------------------
              --Rc_FIFO_Full          => Rx_FIFO_Full_int, -- Rx_FIFO_Full_to_axi_clk,                 -- in
              Rc_FIFO_Full          => Rx_FIFO_Full_Fifo_d1_synced_i, -- Rx_FIFO_Full_to_axi_clk,                 -- in
              Rc_FIFO_Full_strobe   => rc_FIFO_Full_strobe_int,                 -- out
              ---------------------
              Tx_FIFO_Empty         => Tx_FIFO_Empty_intr , -- Tx_FIFO_Empty_to_Axi_clk, -- sr_5_Tx_Empty_int,-- spi clk -- in
              Tx_FIFO_Empty_strobe  => tx_FIFO_Empty_strobe_int,                -- out
              ---------------------
              Rc_FIFO_Empty         => Rx_FIFO_Empty_int, -- 13-09-2012   rx_fifo_empty_i, -- Rx_FIFO_Empty , -- Rc_FIFO_Empty_int,                       -- in
              Receive_ip2bus_error  => receive_ip2bus_error,                    -- out
              Tx_FIFO_Full          => Tx_FIFO_Full_int,                        -- in
              Transmit_ip2bus_error => transmit_ip2bus_error,                   -- out
              ---------------------
              Tx_FIFO_Occpncy_MSB   => tx_occ_msb,                              -- in
              Tx_FIFO_less_half     => tx_FIFO_less_half_int,                   -- out
              ---------------------
              DTR_underrun          => dtr_underrun_to_axi_clk,-- dtr_underrun_int,-- in
              DTR_Underrun_strobe   => dtr_Underrun_strobe_int,                 -- out
              ---------------------
              SPIXfer_done          => spiXfer_done_to_axi_1, -- spiXfer_done_int, -- in
              rready                => rready
             -- DRR_Overrun_reg       => drr_Overrun_int                          -- out
        );

-------------------------------------------------------------------------------
-- TX_OCCUPANCY_I : INSTANTIATE TRANSMIT OCCUPANCY REGISTER
-------------------------------------------------------------------------------

     TX_OCCUPANCY_I: entity axi_quad_spi_v3_2_9.qspi_occupancy_reg
        generic map
             (
              C_OCCUPANCY_NUM_BITS => C_OCCUPANCY_NUM_BITS
             )
        port map
             (
          --Slave attachment ports
              Bus2IP_OCC_REG_RdCE      => Bus2IP_RdCE(SPITFOR),                 -- in

          --FIFO port
              IP2Reg_OCC_Data          => tx_fifo_count, -- tx_FIFO_occ_Reversed,             -- in vec
              IP2Bus_OCC_REG_Data      => IP2Bus_Tx_FIFO_OCC_Reg_Data_int       -- out vec
             );

-------------------------------------------------------------------------------
-- RX_OCCUPANCY_I : INSTANTIATE RECEIVE OCCUPANCY REGISTER
-------------------------------------------------------------------------------

     RX_OCCUPANCY_I: entity axi_quad_spi_v3_2_9.qspi_occupancy_reg
        generic map
             (
              C_OCCUPANCY_NUM_BITS => C_OCCUPANCY_NUM_BITS--,
             )
        port map
             (
          --Slave attachment ports
              Bus2IP_OCC_REG_RdCE      => Bus2IP_RdCE(SPIRFOR),                 -- in

          --FIFO port
              IP2Reg_OCC_Data          => rx_fifo_count, --rx_FIFO_occ_Reversed,             -- in vec
              IP2Bus_OCC_REG_Data      => IP2Bus_Rx_FIFO_OCC_Reg_Data_int       -- out vec
             );

 end generate FIFO_EXISTS;
 --------------------------------------------


-- LOGIC_FOR_MD_0_GEN: in stantiate the original SPI module when the core is configured in Standard SPI mode.
------------------------------
LOGIC_FOR_MD_0_GEN: if C_SPI_MODE = 0 generate
---------------------------
signal SCK_O_int : std_logic;
signal MISO_I_int: std_logic;
-----
begin
-----
   -- un used IO2 and IO3 O/P ports are tied to 0 and T ports are tied to '1'
    DATA_STARTUP_USED : if C_USE_STARTUP = 1 generate
   -----
    begin
   -----
--   IO2_O <= do(2);
--   IO2_T <= dts(2);
--   IO3_O <= do(3);
--   IO3_T <= dts(3);
        IO2_O <= '0';
        IO2_T <= '1';
        IO3_O <= '0';
        IO3_T <= '1';
 
   SPISR_0_CMD_Error_int <= '0'; -- no command error when C_SPI_MODE= 0
end generate DATA_STARTUP_USED;
   -------------------------------------------------------
   SCK_MISO_NO_STARTUP_USED: if C_USE_STARTUP = 0 generate
   -----
   begin
   -----
        IO2_O <= '0';
        IO2_T <= '1';
        IO3_O <= '0';
        IO3_T <= '1';
        SCK_O      <= SCK_O_int;   -- output from the core
        MISO_I_int <= IO1_I;       -- input to the core

   end generate SCK_MISO_NO_STARTUP_USED;
   -------------------------------------------------------

   -------------------------------------------------------
   SCK_MISO_STARTUP_USED: if C_USE_STARTUP = 1 generate
   -----
   begin
   -----
   QSPI_STARTUP_BLOCK_I: entity axi_quad_spi_v3_2_9.qspi_startup_block
   ---------------------
   generic map
        (
                C_SUB_FAMILY     => C_SUB_FAMILY , -- support for V6/V7/K7/A7 families only
                -----------------
                C_USE_STARTUP    => C_USE_STARTUP,
                -----------------
                C_SHARED_STARTUP          => C_SHARED_STARTUP,
                -----------------
                C_SPI_MODE       => C_SPI_MODE
                -----------------
        )
   port map
        (
               SCK_O          => SCK_O_int, -- : in std_logic; -- input from the qspi_mode_0_module
               IO1_I_startup  => IO1_I,     -- : in std_logic; -- input from the top level port list
               IO1_Int        => MISO_I_int,-- : out std_logic
		         Bus2IP_Clk     => Bus2IP_Clk,
		         reset2ip_reset => reset2ip_reset_int,
			      CFGCLK         => cfgclk,       -- FGCLK        , -- 1-bit output: Configuration main clock output
               CFGMCLK        => cfgmclk, -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
               EOS            => eos,  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
               PREQ           => preq, -- REQ          , -- 1-bit output: PROGRAM request to fabric output
               DI             => di_int,    -- output
               DO             => do_int,    -- 4-bit input
               DTS            => dts_int,   -- 4-bit input
               FCSBO          => fcsbo_int, -- 1-bit input
               FCSBTS         => fcsbts_int,-- 1-bit input
               CLK            => clk,   -- 1-bit input, SetReset
               GSR            => gsr,   -- 1-bit input, SetReset
               GTS            => gts,   -- 1-bit input
               KEYCLEARB      => keyclearb, --1-bit input
               PACK           => pack, --1-bit input
               USRCCLKTS      => usrcclkts, -- SRCCLKTS     , -- 1-bit input
               USRDONEO       => usrdoneo, -- SRDONEO      , -- 1-bit input
               USRDONETS      => usrdonets -- SRDONETS       -- 1-bit input


        );
   --------------------

   end generate SCK_MISO_STARTUP_USED;
   -------------------------------------------------------

   ----------------------------------------------------------------------------
   -- SPI_MODULE_I : INSTANTIATE SPI MODULE
   ----------------------------------------------------------------------------

   SPI_MODULE_I: entity axi_quad_spi_v3_2_9.qspi_mode_0_module
   -------------
   generic map
        (
         C_SCK_RATIO           => C_SCK_RATIO         ,
         C_USE_STARTUP         => C_USE_STARTUP       ,
         C_SPICR_REG_WIDTH     => C_SPICR_REG_WIDTH   ,
         C_NUM_SS_BITS         => C_NUM_SS_BITS       ,
         C_NUM_TRANSFER_BITS   => C_NUM_TRANSFER_BITS ,
         C_SUB_FAMILY          => C_SUB_FAMILY        ,
         C_FIFO_EXIST          => C_FIFO_EXIST        ,
         C_DUAL_MODE           => C_DUAL_MODE         ,
         C_STARTUP_EXT         => C_STARTUP_EXT
        )
   port map
        (
         Bus2IP_Clk            => EXT_SPI_CLK,                                   -- in
         Soft_Reset_op         => Rst_to_spi_int,                           -- in
         ------------------------
         SPICR_0_LOOP          => SPICR_0_LOOP_to_spi_clk,--_int,
         SPICR_1_SPE           => SPICR_1_SPE_to_spi_clk,--_int,
         SPICR_2_MASTER_N_SLV  => SPICR_2_MST_N_SLV_to_spi_clk,--_int,
         SPICR_3_CPOL          => SPICR_3_CPOL_to_spi_clk,--_int,
         SPICR_4_CPHA          => SPICR_4_CPHA_to_spi_clk,--_int,
         SPICR_5_TXFIFO_RST    => SPICR_5_TXFIFO_to_spi_clk, -- SPICR_5_TXFIFO_RST_to_spi_clk,--_int,
         SPICR_6_RXFIFO_RST    => SPICR_6_RXFIFO_RST_to_spi_clk,--_int,
         SPICR_7_SS            => SPICR_7_SS_to_spi_clk,--_int,
         SPICR_8_TR_INHIBIT    => SPICR_8_TR_INHIBIT_to_spi_clk,--_int,
         SPICR_9_LSB           => SPICR_9_LSB_to_spi_clk,--_int,
         ------------------------
         Rx_FIFO_Empty_i_no_fifo           => Rx_FIFO_Empty_i,                          -- in

         SR_3_MODF             => SR_3_modf_to_spi_clk,                         -- in
         SR_5_Tx_Empty         => Tx_FIFO_Empty, -- sr_5_Tx_Empty_int,          -- in
         Slave_MODF_strobe     => slave_MODF_strobe_int,                        -- out
         MODF_strobe           => modf_strobe_int,                              -- out

         Slave_Select_Reg      => register_Data_slvsel_int, -- already updated  -- in vec
         Transmit_Data         => Data_From_TxFIFO, -- transmit_Data_int,       -- in vec
         Receive_Data          => Data_To_Rx_FIFO, -- receive_Data_int,         -- out vec
         SPIXfer_done          => spiXfer_done_int,                             -- out
         -- SPIXfer_done_Rx_Wr_en=> SPIXfer_done_Rx_Wr_en,
         DTR_underrun          => dtr_underrun_int,                             -- out
         SPIXfer_done_rd_tx_en=> SPIXfer_done_rd_tx_en,

       --SPI Ports
         SCK_I                 => SCK_I,                                        -- in
         SCK_O_reg             => SCK_O_int,                                    -- out
         SCK_T                 => SCK_T,                                        -- out

         MISO_I                => str_IO1_I, --IO0_I,  -- MOSI_I,                     -- in  std_logic; -- MISO
         MISO_O                => str_IO1_O,--IO0_O,  -- MOSI_O,                     -- out std_logic;
         MISO_T                => str_IO1_T, --IO0_T,  -- MOSI_T,                     -- out std_logic;

         MOSI_I                => str_IO0_I,--MISO_I_int, -- IO1_I,  -- MISO_I,      -- in  std_logic;
         MOSI_O                => str_IO0_O,--IO1_O,  -- MISO_O,                     -- out std_logic; -- MOSI
         MOSI_T                => str_IO0_T,--IO1_T,  -- MISO_T,                     -- out std_logic;

         --MISO_I                => MISO_I_int, -- IO1_I,  -- MISO_I,             -- in
         --MISO_O                => IO1_O,  -- MISO_O,                            -- out
         --MISO_T                => IO1_T,  -- MISO_T,                            -- out

         --MOSI_I                => IO0_I,  -- MOSI_I,                            -- in
         --MOSI_O                => IO0_O,  -- MOSI_O,                            -- out
         --MOSI_T                => IO0_T,  -- MOSI_T,                            -- out

         SPISEL                => SPISEL,                                       -- in

         SS_I                  => SS_I_int,                                         -- in
         SS_O                  => SS_O_int,                                         -- out
         SS_T                  => SS_T_int,                                         -- out

         SPISEL_pulse_op      => spisel_pulse_o_int          ,          -- out std_logic;
         SPISEL_d1_reg        => spisel_d1_reg               ,          -- out std_logic;
         control_bit_7_8       => SPICR_bits_7_8_to_spi_clk,                          -- in vec
         Mst_N_Slv_mode        => Mst_N_Slv_mode             ,
         --Rx_FIFO_Full         => Rx_FIFO_Full_to_spi_clk,
         Rx_FIFO_Full         => Rx_FIFO_Full_Fifo,
         DRR_Overrun_reg       => drr_Overrun_int,               -- out
         reset_RcFIFO_ptr_to_spi => reset_RcFIFO_ptr_to_spi_clk,
         tx_cntr_xfer_done    => tx_cntr_xfer_done
        );
   -------------

end generate LOGIC_FOR_MD_0_GEN;
----------------------------------------

-- LOGIC_FOR_MD_12_GEN: to generate the functionality for mode 1 and 2.
------------------------------
LOGIC_FOR_MD_12_GEN: if C_SPI_MODE /= 0  generate
---------------------------
signal SCK_O_int : std_logic;
signal MISO_I_int: std_logic;

signal Data_Dir_int    : std_logic;
signal Data_Mode_1_int : std_logic;
signal Data_Mode_0_int : std_logic;
signal Data_Phase_int  : std_logic;

signal Addr_Mode_1_int : std_logic;
signal Addr_Mode_0_int : std_logic;
signal Addr_Bit_int    : std_logic;
signal Addr_Phase_int  : std_logic;

signal CMD_Mode_1_int  : std_logic;
signal CMD_Mode_0_int  : std_logic;
signal CMD_Error_int   : std_logic;

signal CMD_decoded_int : std_logic;
signal Dummy_Bits_int  : std_logic_vector(3 downto 0);

-----
begin
-----
 
    LOGIC_FOR_C_SPI_MODE_1_GEN: if C_SPI_MODE = 1 generate
     -------
     begin
     -------
-- DATA_STARTUP_USED_MODE1 : if C_USE_STARTUP = 1 generate
--   -----
--    begin
--   -----
--   IO2_O <= do(2);
--   IO2_T <= dts(2);
--   IO3_O <= do(3);
--   IO3_T <= dts(3);
--   --IO2_I_int <= di(2);-- assign default value as this bit is not used in thid mode
--   IO2_I_int <= '0';-- assign default value as this bit is not used in thid mode
--   --IO3_I_int <= di(3);-- assign default value as this bit is not used in thid mode
--   IO3_I_int <= '0';-- assign default value as this bit is not used in thid mode
--end generate DATA_STARTUP_USED_MODE1;
--
--DATA_NOSTARTUP_USED_MODE1 : if C_USE_STARTUP = 0 generate
--   -----
--    begin
--   -----

          IO2_O <= '0'; -- not used in the logic
          IO3_O <= '0'; -- not used in the logic

          IO2_T <= '1'; -- disable the tri-state buffers
          IO3_T <= '1'; -- disable the tri-state buffers

          IO2_I_int <= '0';-- assign default value as this bit is not used in thid mode

          IO3_I_int <= '0';-- assign default value as this bit is not used in thid mode
--end generate DATA_NOSTARTUP_USED_MODE1;

     end generate LOGIC_FOR_C_SPI_MODE_1_GEN;
     ---------------------------------------
     LOGIC_FOR_C_SPI_MODE_2_GEN: if C_SPI_MODE = 2 generate
     -------
     begin
     -------
 DATA_STARTUP_USED_MODE2 : if (C_USE_STARTUP = 1 and C_UC_FAMILY = 1) generate
   -----
    begin
   -----
          di <= "00";
     end generate DATA_STARTUP_USED_MODE2;

 DATA_NOSTARTUP_USED_MODE2 : if (C_USE_STARTUP = 0 or (C_USE_STARTUP = 1 and C_UC_FAMILY = 0)) generate
   -----
    begin
   -----

          IO2_I_int <= IO2_I;    -- assign this bit from the top level port
          IO2_O     <= IO2_O_int;
          IO2_T     <= IO2_T_int;

          IO3_I_int <= IO3_I;    -- assign this bit from the top level port
          IO3_O     <= IO3_O_int;
          IO3_T     <= IO3_T_int;
     end generate DATA_NOSTARTUP_USED_MODE2;

     end generate LOGIC_FOR_C_SPI_MODE_2_GEN;
     ---------------------------------------


          SPISR_0_CMD_Error_int <= CMD_Error_int;
          dtr_underrun_int      <= '0'; -- SPI MODE 1 & 2 are master modes, so DTR under run wont be present
          slave_MODF_strobe_int <= '0'; -- SPI MODE 1 & 2 are master modes, so the slave mode fault error wont appear
          Mst_N_Slv_mode        <= '1';
          -------------------------------------------------------
          -- SCK_O      <= SCK_O_int;   -- output from the core
          -- MISO_I_int <= IO1_I;       -- input to the core
-- *
          -------------------------------------------------------
          SCK_MISO_NO_STARTUP_USED: if C_USE_STARTUP = 0 generate
          -----
          begin
          -----
               SCK_O      <= SCK_O_int;   -- output from the core
               MISO_I_int <= IO1_I;       -- input to the core

          end generate SCK_MISO_NO_STARTUP_USED;
          -------------------------------------------------------

          -------------------------------------------------------
          SCK_MISO_STARTUP_USED: if C_USE_STARTUP = 1 generate
          -----
          begin
          -----
          QSPI_STARTUP_BLOCK_I: entity axi_quad_spi_v3_2_9.qspi_startup_block
          ---------------------
          generic map
               (
                       C_SUB_FAMILY     => C_SUB_FAMILY , -- support for V6/V7/K7/A7 families only
                       -----------------
                       C_USE_STARTUP    => C_USE_STARTUP,
                       -----------------
                       C_SHARED_STARTUP          => C_SHARED_STARTUP,

                       -----------------
                       C_SPI_MODE       => C_SPI_MODE
                       -----------------
               )
          port map
               (
                       SCK_O          => SCK_O_int, -- : in std_logic; -- input from the qspi_mode_0_module
                       IO1_I_startup  => IO1_I,     -- : in std_logic; -- input from the top level port list
                       IO1_Int        => MISO_I_int,-- : out std_logic
		       Bus2IP_Clk     => Bus2IP_Clk,
		       reset2ip_reset => reset2ip_reset_int,
			   CFGCLK         => cfgclk,       -- FGCLK        , -- 1-bit output: Configuration main clock output
               CFGMCLK        => cfgmclk, -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
               EOS            => eos,  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
               PREQ           => preq, -- REQ          , -- 1-bit output: PROGRAM request to fabric output
               DI             => di_int,    -- output
               DO             => do_int,    -- 4-bit input
               DTS            => dts_int,   -- 4-bit input
               FCSBO          => fcsbo_int, -- 1-bit input
               FCSBTS         => fcsbts_int,-- 1-bit input
               CLK            => clk,   -- 1-bit input, SetReset
               GSR            => gsr,   -- 1-bit input, SetReset
               GTS            => gts,   -- 1-bit input
               KEYCLEARB      => keyclearb, --1-bit input
               PACK           => pack, --1-bit input
               USRCCLKTS      => usrcclkts, -- SRCCLKTS     , -- 1-bit input
               USRDONEO       => usrdoneo, -- SRDONEO      , -- 1-bit input
               USRDONETS      => usrdonets -- SRDONETS       -- 1-bit input


               );
          --------------------

          end generate SCK_MISO_STARTUP_USED;
          -------------------------------------------------------
-- *
          -- Add instance for Look up table logic
          SPI_MODE_1_LUT_LOGIC_I: entity axi_quad_spi_v3_2_9.qspi_look_up_logic
          -------------
          generic map
               (
                 C_FAMILY            => C_FAMILY           ,
                 C_SPI_MODE          => C_SPI_MODE         ,
                 C_SPI_MEMORY        => C_SPI_MEMORY       ,
                 C_SELECT_XPM        => C_SELECT_XPM       ,
                 C_NUM_TRANSFER_BITS => C_NUM_TRANSFER_BITS
               )
          port map
               (
                 EXT_SPI_CLK         => EXT_SPI_CLK         ,                   -- : in std_logic;
                 Rst_to_spi          => Rst_to_spi_int      ,                   -- : in std_logic;
                 TXFIFO_RST          => reset_TxFIFO_ptr_int_to_spi,                   -- : in std_logic;
                 --------------------                                           --
                 DTR_FIFO_Data_Exists=> data_Exists_TxFIFO_int,                 -- : in std_logic;
                 Data_From_TxFIFO    => Data_From_TxFIFO   ,                    -- : in std_logic_vector
                                                                                --              (0 to (C_NUM_TRANSFER_BITS-1))
                 pr_state_idle       => pr_state_idle_int  ,                    --
                 --------------------                                           --
                 Data_Dir            => Data_Dir_int       ,                    -- : out std_logic;
                 Data_Mode_1         => Data_Mode_1_int    ,                    -- : out std_logic;
                 Data_Mode_0         => Data_Mode_0_int    ,                    -- : out std_logic;
                 Data_Phase          => Data_Phase_int     ,                    -- : out std_logic;
                 --------------------                                           --
                 Quad_Phase          => Quad_Phase_int     ,
                 --------------------                                           --
                 Addr_Mode_1         => Addr_Mode_1_int    ,                    -- : out std_logic;
                 Addr_Mode_0         => Addr_Mode_0_int    ,                    -- : out std_logic;
                 Addr_Bit            => Addr_Bit_int       ,                    -- : out std_logic;
                 Addr_Phase          => Addr_Phase_int     ,                    -- : out std_logic;
                 --------------------                                           --
                 CMD_Mode_1          => CMD_Mode_1_int     ,                    -- : out std_logic;
                 CMD_Mode_0          => CMD_Mode_0_int     ,                    -- : out std_logic;
                 CMD_Error           => CMD_Error_int      ,                    -- : out std_logic;
                 --------------------                                           -- -
                 CMD_decoded         => CMD_decoded_int                         -- : out std_logic
               );
          ---------

          SPI_MODE_CONTROL_LOGIC_I: entity axi_quad_spi_v3_2_9.qspi_mode_control_logic
          -------------
          generic map
               (
                 C_SCK_RATIO          => C_SCK_RATIO         ,
                 C_NUM_TRANSFER_BITS  => C_NUM_TRANSFER_BITS ,
                 C_SPI_MODE           => C_SPI_MODE          ,
                 C_USE_STARTUP        => C_USE_STARTUP       ,
                 C_NUM_SS_BITS        => C_NUM_SS_BITS       ,
                 C_SPI_MEMORY         => C_SPI_MEMORY        ,
                 C_SUB_FAMILY         => C_SUB_FAMILY        ,
                 C_DUAL_MODE          => C_DUAL_MODE         ,
                 C_STARTUP_EXT        => C_STARTUP_EXT
               )
          port map
               (
                 Bus2IP_Clk           =>  EXT_SPI_CLK               , -- Bus2IP_Clk                ,           -- in std_logic;
                 Soft_Reset_op        =>  Rst_to_spi_int            ,           -- in std_logic;
                 --------------------                               ,           --
                 DTR_FIFO_Data_Exists =>  data_Exists_TxFIFO_int    ,           -- in std_logic;
                 Slave_Select_Reg     =>  register_Data_slvsel_int  , -- already updated            -- in  std_logic_vector(0 to (C_NUM_SS_BITS-1));
                 Transmit_Data        =>  Data_From_TxFIFO,--transmit_Data_int         , -- already updated           -- in  std_logic_vector(0 to (C_NUM_TRANSFER_BITS
                 Receive_Data         =>  Data_To_Rx_FIFO           ,           -- out std_logic_vector(0 to (C_NUM_TRANSFER_BITS
                 --Data_To_Rx_FIFO_1    => Data_To_Rx_FIFO_1,
                 SPIXfer_done         =>  spiXfer_done_int          , -- already updated           -- out std_logic;
                 SPIXfer_done_Rx_Wr_en=> SPIXfer_done_Rx_Wr_en,
                 MODF_strobe          =>  modf_strobe_int           , -- already updated
                 SPIXfer_done_rd_tx_en=> SPIXfer_done_rd_tx_en,
                 ---------------------                                         --
                 SR_3_MODF            =>  SR_3_modf_to_spi_clk      ,           -- in std_logic;
                 SR_5_Tx_Empty        =>  Tx_FIFO_Empty             , -- sr_5_Tx_Empty_int   -- in std_logic;
                 --SR_6_Rx_Full         =>  Rx_FIFO_Full              ,           -- in
                 pr_state_idle        =>  pr_state_idle_int         ,           --
                 ---------------------                                          -- from control register
                 SPICR_0_LOOP         =>  SPICR_0_LOOP_to_spi_clk     ,--SPICR_0_LOOP_int          ,           -- in std_logic;
                 SPICR_1_SPE          =>  SPICR_1_SPE_to_spi_clk      ,--_int           ,           -- in std_logic;
                 SPICR_2_MASTER_N_SLV =>  SPICR_2_MST_N_SLV_to_spi_clk,--_int  ,           -- in std_logic;
                 SPICR_3_CPOL         =>  SPICR_3_CPOL_to_spi_clk     ,--_int          ,           -- in std_logic;
                 SPICR_4_CPHA         =>  SPICR_4_CPHA_to_spi_clk     ,--_int          ,           -- in std_logic;
                 SPICR_5_TXFIFO_RST   =>  SPICR_5_TXFIFO_RST_to_spi_clk,--_int    ,           -- in std_logic;
                 SPICR_6_RXFIFO_RST   =>  SPICR_6_RXFIFO_RST_to_spi_clk,--_int    ,           -- in std_logic;
                 SPICR_7_SS           =>  SPICR_7_SS_to_spi_clk        ,--_int            ,           -- in std_logic;
                 SPICR_8_TR_INHIBIT   =>  SPICR_8_TR_INHIBIT_to_spi_clk,--_int    ,           -- in std_logic;
                 SPICR_9_LSB          =>  SPICR_9_LSB_to_spi_clk       ,--_int           ,           -- in std_logic;
                 ---------------------                                          --

                 ---------------------                                          -- from look up table
                 Data_Dir             => Data_Dir_int               ,           -- in std_logic;
                 Data_Mode_1          => Data_Mode_1_int            ,           -- in std_logic;
                 Data_Mode_0          => Data_Mode_0_int            ,           -- in std_logic;
                 Data_Phase           => Data_Phase_int             ,
                 ---------------------
                 --Dummy_Bits           => Dummy_Bits_int             ,           -- in std_logic_vector(3 downto 0);
                 Quad_Phase           => Quad_Phase_int             ,
                 ---------------------                                          -- in std_logic;
                 Addr_Mode_1          => Addr_Mode_1_int            ,           -- in std_logic;
                 Addr_Mode_0          => Addr_Mode_0_int            ,           -- in std_logic;
                 Addr_Bit             => Addr_Bit_int               ,           -- in std_logic;
                 Addr_Phase           => Addr_Phase_int             ,           -- in std_logic;
                 ---------------------
                 CMD_Mode_1           => CMD_Mode_1_int             ,           -- in std_logic;
                 CMD_Mode_0           => CMD_Mode_0_int             ,           -- in std_logic;
                 CMD_Error            => CMD_Error_int              ,           -- in std_logic;
                 ---------------------                                          --
                 CMD_decoded          => CMD_decoded_int            ,           -- in std_logic;

                 --SPI Interface                                                --
                 SCK_I                => SCK_I,                                 -- in  std_logic;
                 SCK_O_reg            => SCK_O_int,                             -- out std_logic;
                 SCK_T                => SCK_T,                                 -- out std_logic;
                                                                                --
                 IO0_I                => str_IO0_I, --IO0_I,  -- MOSI_I,                     -- in  std_logic; -- MISO
                 IO0_O                => str_IO0_O,--IO0_O,  -- MOSI_O,                     -- out std_logic;
                 IO0_T                => str_IO0_T, --IO0_T,  -- MOSI_T,                     -- out std_logic;

                 IO1_I                => str_IO1_I,--MISO_I_int, -- IO1_I,  -- MISO_I,      -- in  std_logic;
                 IO1_O                => str_IO1_O,--IO1_O,  -- MISO_O,                     -- out std_logic; -- MOSI
                 IO1_T                => str_IO1_T,--IO1_T,  -- MISO_T,                     -- out std_logic;
                                                                                --
                 IO2_I                => IO2_I_int,  --                         -- in  std_logic;
                 IO2_O                => IO2_O_int,  --                         -- out std_logic;
                 IO2_T                => IO2_T_int,  --                         -- out std_logic;
                                                                                --
                 IO3_I                => IO3_I_int,  --                         -- in  std_logic;
                 IO3_O                => IO3_O_int,  --                         -- out std_logic;
                 IO3_T                => IO3_T_int,  --                         -- out std_logic;
                                                                                --
                 SPISEL               => SPISEL,                                -- in  std_logic;
                                                                                --
                 SS_I                 => SS_I_int,                                  -- in std_logic_vector(0 to (C_NUM_SS_BITS-1));
                 SS_O                 => SS_O_int,                                  -- out std_logic_vector(0 to (C_NUM_SS_BITS-1));
                 SS_T                 => SS_T_int,                                  -- out std_logic;
                                                                                --
                 SPISEL_pulse_op      => spisel_pulse_o_int          ,          -- out std_logic;
                 SPISEL_d1_reg        => spisel_d1_reg               ,          -- out std_logic;
                 Control_bit_7_8      => SPICR_bits_7_8_to_spi_clk   ,           -- in std_logic_vector(0 to 1) --(7 to 8)
                 Rx_FIFO_Full         => Rx_FIFO_Full_Fifo,
                 DRR_Overrun_reg       => drr_Overrun_int,
                 reset_RcFIFO_ptr_to_spi => reset_RcFIFO_ptr_to_spi_clk
               );
          -------------

end generate LOGIC_FOR_MD_12_GEN;
------------------------------------------
--------------------------------------------------------------------------------
 CONTROL_REG_I: entity axi_quad_spi_v3_2_9.qspi_cntrl_reg
             generic map
             (
             --------------------------
             C_S_AXI_DATA_WIDTH         => C_S_AXI_DATA_WIDTH,
             --------------------------
             -- Number of bits in regis
             C_SPI_NUM_BITS_REG         => C_SPI_NUM_BITS_REG,
             --------------------------
             C_SPICR_REG_WIDTH          => C_SPICR_REG_WIDTH,
             --------------------------
             C_SPI_MODE                 => C_SPI_MODE
             --------------------------
             )
             port map
             (                                                                  -- in
             Bus2IP_Clk                 => Bus2IP_Clk,                          -- in
             Soft_Reset_op              => reset2ip_reset_int,
             ---------------------------
             Wr_ce_reduce_ack_gen       => Wr_ce_reduce_ack_gen,                -- in
             Bus2IP_SPICR_WrCE          => Bus2IP_WrCE(SPICR),                  -- in
             Bus2IP_SPICR_RdCE          => Bus2IP_RdCE(SPICR),                  -- in
             Bus2IP_SPICR_data          => Bus2IP_Data,                         -- in vec
             ---------------------------
             SPICR_0_LOOP               => SPICR_0_LOOP_frm_axi_clk,                    -- out
             SPICR_1_SPE                => SPICR_1_SPE_frm_axi_clk,                     -- out
             SPICR_2_MASTER_N_SLV       => SPICR_2_MST_N_SLV_frm_axi_clk,            -- out
             SPICR_3_CPOL               => SPICR_3_CPOL_frm_axi_clk,                    -- out
             SPICR_4_CPHA               => SPICR_4_CPHA_frm_axi_clk,                    -- out
             SPICR_5_TXFIFO_RST         => SPICR_5_TXFIFO_RST_frm_axi_clk,              -- out
             SPICR_6_RXFIFO_RST         => SPICR_6_RXFIFO_RST_frm_axi_clk,              -- out
             SPICR_7_SS                 => SPICR_7_SS_frm_axi_clk,                      -- out
             SPICR_8_TR_INHIBIT         => SPICR_8_TR_INHIBIT_frm_axi_clk,              -- out
             SPICR_9_LSB                => SPICR_9_LSB_frm_axi_clk,                     -- out
             -- to Status Register
             SPISR_1_LOOP_Back_Error    => SPISR_1_LOOP_Back_Error_int,         -- out
             SPISR_2_MSB_Error          => SPISR_2_MSB_Error_int,               -- out
             SPISR_3_Slave_Mode_Error   => SPISR_3_Slave_Mode_Error_int,        -- out
             SPISR_4_CPOL_CPHA_Error    => SPISR_4_CPOL_CPHA_Error_int,         -- out
             ---------------------------
             IP2Bus_SPICR_Data          => IP2Bus_SPICR_Data_int,               -- out vec
             ---------------------------
             Control_bit_7_8            => SPICR_bits_7_8_frm_axi_clk           -- out vec
             ---------------------------
             );


-------------------------------------------------------------------------------
-- STATUS_REG_I : INSTANTIATE STATUS REGISTER
-------------------------------------------------------------------------------
   STATUS_REG_MODE_0_GEN: if C_SPI_MODE = 0 generate
   begin

       STATUS_SLAVE_SEL_REG_I: entity axi_quad_spi_v3_2_9.qspi_status_slave_sel_reg
                generic map(
                C_SPI_NUM_BITS_REG      => C_SPI_NUM_BITS_REG            ,
                ------------------------   ------------------------
                C_S_AXI_DATA_WIDTH      => C_S_AXI_DATA_WIDTH            ,
                ------------------------   ------------------------
                C_NUM_SS_BITS           => C_NUM_SS_BITS                 ,
                ------------------------   ------------------------
                C_SPISR_REG_WIDTH       => C_SPISR_REG_WIDTH
                )
                port map(
                Bus2IP_Clk                  =>  Bus2IP_Clk                    , -- in
                Soft_Reset_op               =>  reset2ip_reset_int            , -- in
                -- I/P from control regis
                SPISR_0_Command_Error       =>  '0'                           , -- SPISR_0_CMD_Error_int         , -- in-- should come from look up table
                SPISR_1_LOOP_Back_Error     =>  SPISR_1_LOOP_Back_Error_int   , -- in
                SPISR_2_MSB_Error           =>  SPISR_2_MSB_Error_int         , -- in
                SPISR_3_Slave_Mode_Error    =>  SPISR_3_Slave_Mode_Error_int  , -- in
                SPISR_4_CPOL_CPHA_Error     =>  SPISR_4_CPOL_CPHA_Error_int   , -- in
                -- I/P from other modules
                SPISR_Ext_SPISEL_slave      =>  spisel_d1_reg_to_axi_clk      , -- in
                SPISR_7_Tx_Full             =>  Tx_FIFO_Full_int                  , -- in
                SPISR_8_Tx_Empty            =>  Tx_FIFO_Empty_SPISR_to_axi_clk, -- Tx_FIFO_Empty_to_Axi_clk      , -- in
                --SPISR_9_Rx_Full             =>  Rx_FIFO_Full_int, -- Rx_FIFO_Full_to_axi_clk       , -- in
                SPISR_9_Rx_Full             =>  Rx_FIFO_Full_Fifo_d1_synced, -- Rx_FIFO_Full_to_axi_clk       , -- in
                SPISR_10_Rx_Empty           =>  Rx_FIFO_Empty_int                 , -- in

                -- Slave attachment ports
                ModeFault_Strobe            =>  modf_strobe_to_axi_clk        , -- in
                Rd_ce_reduce_ack_gen        =>  rd_ce_reduce_ack_gen          , -- in
                Bus2IP_SPISR_RdCE           =>  Bus2IP_RdCE(SPISR)            , -- in

                IP2Bus_SPISR_Data           =>  IP2Bus_SPISR_Data_int         , -- out vec
                SR_3_modf                   =>  SR_3_modf_int                 , -- out
                -- Slave Select Register
                Bus2IP_SPISSR_WrCE          =>  Bus2IP_WrCE(SPISSR)           , -- in
                Wr_ce_reduce_ack_gen        =>  Wr_ce_reduce_ack_gen          , -- in
                Bus2IP_SPISSR_RdCE          =>  Bus2IP_RdCE(SPISSR)           , -- in
                Bus2IP_SPISSR_Data          =>  Bus2IP_Data                   , -- in vec
                IP2Bus_SPISSR_Data          =>  IP2Bus_SPISSR_Data_int        , -- out vec

                SPISSR_Data_reg_op          =>  SPISSR_frm_axi_clk        -- out vec
                );

   end generate STATUS_REG_MODE_0_GEN;

   STATUS_REG_MODE_12_GEN: if C_SPI_MODE /= 0 generate
   begin

       STATUS_SLAVE_SEL_REG_I: entity axi_quad_spi_v3_2_9.qspi_status_slave_sel_reg
                generic map(
                C_SPI_NUM_BITS_REG      => C_SPI_NUM_BITS_REG            ,
                ------------------------   ------------------------
                C_S_AXI_DATA_WIDTH      => C_S_AXI_DATA_WIDTH            ,
                ------------------------   ------------------------
                C_NUM_SS_BITS           => C_NUM_SS_BITS                 ,
                ------------------------   ------------------------
                C_SPISR_REG_WIDTH       => C_SPISR_REG_WIDTH
                )
                port map(
                Bus2IP_Clk                  =>  Bus2IP_Clk                    , -- in
                Soft_Reset_op               =>  reset2ip_reset_int            , -- in
                -- I/P from control regis
                SPISR_0_Command_Error       =>  SPISR_0_CMD_Error_to_axi_clk  , -- SPISR_0_CMD_Error_int         , -- in-- should come from look up table
                SPISR_1_LOOP_Back_Error     =>  SPISR_1_LOOP_Back_Error_int   , -- in
                SPISR_2_MSB_Error           =>  SPISR_2_MSB_Error_int         , -- in
                SPISR_3_Slave_Mode_Error    =>  SPISR_3_Slave_Mode_Error_int  , -- in
                SPISR_4_CPOL_CPHA_Error     =>  SPISR_4_CPOL_CPHA_Error_int   , -- in
                -- I/P from other modules
                SPISR_Ext_SPISEL_slave      =>  spisel_d1_reg_to_axi_clk      , -- in
                SPISR_7_Tx_Full             =>  Tx_FIFO_Full_int                  , -- in
                SPISR_8_Tx_Empty            =>  Tx_FIFO_Empty_SPISR_to_axi_clk, -- Tx_FIFO_Empty_to_Axi_clk      , -- in
                --SPISR_9_Rx_Full             =>  Rx_FIFO_Full_int, -- Rx_FIFO_Full_to_axi_clk       , -- in
                SPISR_9_Rx_Full             =>  Rx_FIFO_Full_Fifo_d1_synced, -- Rx_FIFO_Full_to_axi_clk       , -- in
                SPISR_10_Rx_Empty           =>  Rx_FIFO_Empty_int                 , -- in

                -- Slave attachment ports
                ModeFault_Strobe            =>  modf_strobe_to_axi_clk        , -- in
                Rd_ce_reduce_ack_gen        =>  rd_ce_reduce_ack_gen          , -- in
                Bus2IP_SPISR_RdCE           =>  Bus2IP_RdCE(SPISR)            , -- in

                IP2Bus_SPISR_Data           =>  IP2Bus_SPISR_Data_int         , -- out vec
                SR_3_modf                   =>  SR_3_modf_int                 , -- out
                -- Slave Select Register
                Bus2IP_SPISSR_WrCE          =>  Bus2IP_WrCE(SPISSR)           , -- in
                Wr_ce_reduce_ack_gen        =>  Wr_ce_reduce_ack_gen          , -- in
                Bus2IP_SPISSR_RdCE          =>  Bus2IP_RdCE(SPISSR)           , -- in
                Bus2IP_SPISSR_Data          =>  Bus2IP_Data                   , -- in vec
                IP2Bus_SPISSR_Data          =>  IP2Bus_SPISSR_Data_int        , -- out vec

                SPISSR_Data_reg_op          =>  SPISSR_frm_axi_clk        -- out vec
                );
    end generate STATUS_REG_MODE_12_GEN;
-------------------------------------------------------------------------------
-- SOFT_RESET_I : INSTANTIATE SOFT RESET
-------------------------------------------------------------------------------
     SOFT_RESET_I: entity axi_quad_spi_v3_2_9.soft_reset
        generic map
             (
              C_SIPIF_DWIDTH     => C_S_AXI_DATA_WIDTH,
              -- Width of triggered reset in Bus Clocks
              C_RESET_WIDTH      => 16
             )
        port map
             (
              -- Inputs From the PLBv46 Slave Single Bus
              Bus2IP_Clk         => Bus2IP_Clk,                                 -- in
              Bus2IP_Reset       => Bus2IP_Reset,                               -- in

              Bus2IP_WrCE        => Bus2IP_WrCE(SWRESET),                       -- in
              Bus2IP_Data        => Bus2IP_Data,                                -- in
              Bus2IP_BE          => Bus2IP_BE,                                  -- in

              -- Final Device Reset Output
              Reset2IP_Reset     => reset2ip_reset_int,                         -- out

              -- Status Reply Outputs to the Bus
              Reset2Bus_WrAck    => rst_ip2bus_wrack,                           -- out
              Reset2Bus_Error    => rst_ip2bus_error,                           -- out
              Reset2Bus_ToutSup  => open                                        -- out
             );

-------------------------------------------------------------------------------
-- INTERRUPT_CONTROL_I : INSTANTIATE INTERRUPT CONTROLLER
-------------------------------------------------------------------------------

 bus2ip_intr_rdce <= "0000000"      &
                     Bus2IP_RdCE(7) &
                     Bus2IP_RdCE(8) &
                     '0'            &
                     Bus2IP_RdCE(10)&
                     "00000";

 bus2ip_intr_wrce <= "0000000"      &
                     Bus2IP_WrCE(7) &
                     Bus2IP_WrCE(8) &
                     '0'            &
                     Bus2IP_WrCE(10)&
                     "00000";

 ------------------------------------------------------------------------------
 intr_controller_rd_ce_or_reduce <= or_reduce(Bus2IP_RdCE(0 to 6)) or
                                    Bus2IP_RdCE(9)                 or
                                    or_reduce(Bus2IP_RdCE(11 to 15));

 ------------------------------------------------------------------------------
 I_READ_ACK_INTR_HOLES: process(Bus2IP_Clk) is
 begin
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          ip2Bus_RdAck_intr_reg_hole     <= '0';
          ip2Bus_RdAck_intr_reg_hole_d1  <= '0';
      else
          ip2Bus_RdAck_intr_reg_hole_d1 <= intr_controller_rd_ce_or_reduce;
          ip2Bus_RdAck_intr_reg_hole    <= intr_controller_rd_ce_or_reduce and
                                            (not ip2Bus_RdAck_intr_reg_hole_d1);
      end if;
    end if;
 end process I_READ_ACK_INTR_HOLES;
 ------------------------------------------------------------------------------
 intr_controller_wr_ce_or_reduce <= or_reduce(Bus2IP_WrCE(0 to 6)) or
                                    Bus2IP_WrCE(9)                 or
                                    or_reduce(Bus2IP_WrCE(11 to 15));

 ------------------------------------------------------------------------------
 I_WRITE_ACK_INTR_HOLES: process(Bus2IP_Clk) is
 -----
 begin
 -----
    if (Bus2IP_Clk'event and Bus2IP_Clk = '1') then
      if (reset2ip_reset_int = RESET_ACTIVE) then
          ip2Bus_WrAck_intr_reg_hole     <= '0';
          ip2Bus_WrAck_intr_reg_hole_d1  <= '0';
      else
          ip2Bus_WrAck_intr_reg_hole_d1 <= intr_controller_wr_ce_or_reduce;
          ip2Bus_WrAck_intr_reg_hole    <= intr_controller_wr_ce_or_reduce and
                                            (not ip2Bus_WrAck_intr_reg_hole_d1);
      end if;
    end if;
 end process I_WRITE_ACK_INTR_HOLES;
 ------------------------------------------------------------------------------

     INTERRUPT_CONTROL_I: entity interrupt_control_v3_1_4.interrupt_control
        generic map
             (
              C_NUM_CE               => 16,
              C_NUM_IPIF_IRPT_SRC    =>  1,  -- Set to 1 to avoid null array
              C_IP_INTR_MODE_ARRAY   => C_IP_INTR_MODE_ARRAY,

              -- Specifies device Priority Encoder function
              C_INCLUDE_DEV_PENCODER => false,

              -- Specifies device ISC hierarchy
              C_INCLUDE_DEV_ISC      => false,

              C_IPIF_DWIDTH          => C_S_AXI_DATA_WIDTH
             )
        port map
             (
              Bus2IP_Clk             =>  Bus2IP_Clk,                            -- in
              Bus2IP_Reset           =>  reset2ip_reset_int,                    -- in
              Bus2IP_Data            =>  bus2IP_Data_for_interrupt_core,                 -- in vec
              Bus2IP_BE              =>  Bus2IP_BE,                             -- in vec
              Interrupt_RdCE         =>  bus2ip_intr_rdce,                      -- in vec
              Interrupt_WrCE         =>  bus2ip_intr_wrce,                      -- in vec
              IPIF_Reg_Interrupts    =>  "00", -- Tie off the unused reg intrs
              IPIF_Lvl_Interrupts    =>  "0",  -- Tie off the dummy lvl intr
              IP2Bus_IntrEvent       =>  ip2Bus_IntrEvent_int,                  -- in
              Intr2Bus_DevIntr       =>  IP2INTC_Irpt,                          -- out
              Intr2Bus_DBus          =>  intr_ip2bus_data,                      -- out vec
              Intr2Bus_WrAck         =>  intr_ip2bus_wrack,                     -- out
              Intr2Bus_RdAck         =>  intr_ip2bus_rdack,                     -- out
              Intr2Bus_Error         =>  intr_ip2bus_error,                     -- out
              Intr2Bus_Retry         =>  open,
              Intr2Bus_ToutSup       =>  open
             );
--------------------------------------------------------------------------------
end imp;
--------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- axi_qspi_xip_if.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_qspi_xip_if.vhd
-- Version:         v3.0
-- Description:     This is the top-level design file for the AXI Quad SPI core
--                  in XIP mode.
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.conv_std_logic_vector;
    use ieee.std_logic_arith.all;
    -- use ieee.std_logic_signed.all;
    use ieee.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
    use ieee.std_logic_unsigned.all;


library axi_lite_ipif_v3_0_4;
use axi_lite_ipif_v3_0_4.axi_lite_ipif;
use axi_lite_ipif_v3_0_4.ipif_pkg.all;
library lib_fifo_v1_0_6;
    use lib_fifo_v1_0_6.async_fifo_fg;
library lib_cdc_v1_0_2;
	use lib_cdc_v1_0_2.cdc_sync;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
library unisim;
    use unisim.vcomponents.FDRE;
    use unisim.vcomponents.FD;
    use unisim.vcomponents.FDR;
-------------------------------------------------------------------------------

entity axi_qspi_xip_if is
   generic(
       -- General Parameters
       C_FAMILY                 : string               := "virtex7";
       Async_Clk                : integer              := 0;
       C_SUB_FAMILY             : string               := "virtex7";
       -------------------------
       C_SPI_MEM_ADDR_BITS          : integer              ; -- default is 24 bit, options are 24 or 32 bits
       -------------------------
      -- C_AXI4_CLK_PS            : integer              := 10000;--AXI clock period
      -- C_EXT_SPI_CLK_PS         : integer              := 10000;--ext clock period
       C_XIP_FIFO_DEPTH             : integer          := 64;-- Fixed value for XIP mode.
       C_SCK_RATIO              : integer              := 16;--default in legacy mode
       C_NUM_SS_BITS            : integer range 1 to 32:= 1;
       C_NUM_TRANSFER_BITS      : integer              := 8; -- Fixed 8 bit for XIP mode
       -------------------------
       C_SPI_MODE               : integer range 0 to 2 := 0; -- used for differentiating
                                                             -- Standard, Dual or Quad mode
                                                             -- in Ports as well as internal
                                                             -- functionality
       C_USE_STARTUP            : integer range 0 to 1 := 1; --
       C_SPI_MEMORY             : integer range 0 to 3 := 1; -- 0 - mixed mode,
                                                             -- 1 - winbond,
                                                             -- 2 - numonyx
															 -- 3 - spansion
                                                             -- used to differentiate
                                                             -- internal look up table
                                                             -- for commands.
       -------------------------
       -- AXI4 Lite Interface Parameters
       --*C_S_AXI_ADDR_WIDTH       : integer range 32 to 32 := 32;
       C_S_AXI_ADDR_WIDTH       : integer range 7 to 7   := 7;
       C_S_AXI_DATA_WIDTH       : integer range 32 to 32 := 32;
       -------------------------
       --*C_BASEADDR               : std_logic_vector       := x"FFFFFFFF";
       --*C_HIGHADDR               : std_logic_vector       := x"00000000";
       -------------------------
       -- AXI4 Full Interface Parameters
       --*C_S_AXI4_ADDR_WIDTH      : integer range 32 to 32 := 32;
       C_S_AXI4_ADDR_WIDTH      : integer ;-- range 32 to 32 := 32;
       C_S_AXI4_DATA_WIDTH      : integer range 32 to 32 := 32;
       C_S_AXI4_ID_WIDTH        : integer range 1 to 16  := 4;
       -------------------------
       --*C_AXI4_BASEADDR          : std_logic_vector       := x"FFFFFFFF";
       --*C_AXI4_HIGHADDR          : std_logic_vector       := x"00000000";
       -------------------------
       C_XIP_FULL_ARD_ADDR_RANGE_ARRAY: SLV64_ARRAY_TYPE :=
           (
            X"0000_0000_0100_0000", --  IP user0 base address
            X"0000_0000_01FF_FFFF"  --  IP user0 high address
           );
       C_XIP_FULL_ARD_NUM_CE_ARRAY  : INTEGER_ARRAY_TYPE :=
           (
            2,
            1 -- User0 CE Number
           )
   );
   port(
       -- external async clock for SPI interface logic
       EXT_SPI_CLK    : in std_logic;
       S_AXI4_ACLK     : in std_logic;

       Rst_to_spi      : in std_logic;
       S_AXI4_ARESET  : in std_logic;
       -------------------------------
       S_AXI_ACLK      : in std_logic;
       S_AXI_ARESETN   : in std_logic;
       ------------------------------------
       -- AXI Write Address Channel Signals
       ------------------------------------
       S_AXI4_AWID    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       S_AXI4_AWADDR  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1) downto 0);
       S_AXI4_AWLEN   : in  std_logic_vector(7 downto 0);
       S_AXI4_AWSIZE  : in  std_logic_vector(2 downto 0);
       S_AXI4_AWBURST : in  std_logic_vector(1 downto 0);
       S_AXI4_AWLOCK  : in  std_logic;                   -- not supported in design
       S_AXI4_AWCACHE : in  std_logic_vector(3 downto 0);-- not supported in design
       S_AXI4_AWPROT  : in  std_logic_vector(2 downto 0);-- not supported in design
       S_AXI4_AWVALID : in  std_logic;
       S_AXI4_AWREADY : out std_logic;
       ---------------------------------------
       -- AXI4 Full Write Data Channel Signals
       ---------------------------------------
       S_AXI4_WDATA   : in  std_logic_vector((C_S_AXI4_DATA_WIDTH-1)downto 0);
       S_AXI4_WSTRB   : in  std_logic_vector(((C_S_AXI4_DATA_WIDTH/8)-1) downto 0);
       S_AXI4_WLAST   : in  std_logic;
       S_AXI4_WVALID  : in  std_logic;
       S_AXI4_WREADY  : out std_logic;
       -------------------------------------------
       -- AXI4 Full Write Response Channel Signals
       -------------------------------------------
       S_AXI4_BID     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       S_AXI4_BRESP   : out std_logic_vector(1 downto 0);
       S_AXI4_BVALID  : out std_logic;
       S_AXI4_BREADY  : in  std_logic;
       -----------------------------------
       -- AXI Read Address Channel Signals
       -----------------------------------
       S_AXI4_ARID    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       S_AXI4_ARADDR  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1) downto 0);
       S_AXI4_ARLEN   : in  std_logic_vector(7 downto 0);
       S_AXI4_ARSIZE  : in  std_logic_vector(2 downto 0);
       S_AXI4_ARBURST : in  std_logic_vector(1 downto 0);
       S_AXI4_ARLOCK  : in  std_logic;                -- not supported in design
       S_AXI4_ARCACHE : in  std_logic_vector(3 downto 0);-- not supported in design
       S_AXI4_ARPROT  : in  std_logic_vector(2 downto 0);-- not supported in design
       S_AXI4_ARVALID : in  std_logic;
       S_AXI4_ARREADY : out std_logic;
       --------------------------------
       -- AXI Read Data Channel Signals
       --------------------------------
       S_AXI4_RID     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       S_AXI4_RDATA   : out std_logic_vector((C_S_AXI4_DATA_WIDTH-1) downto 0);
       S_AXI4_RRESP   : out std_logic_vector(1 downto 0);
       S_AXI4_RLAST   : out std_logic;
       S_AXI4_RVALID  : out std_logic;
       S_AXI4_RREADY  : in  std_logic;
       --------------------------------
       XIPSR_CPHA_CPOL_ERR     : in std_logic;
       TO_XIPSR_trans_error    : out std_logic;
       --------------------------------
       TO_XIPSR_mst_modf_err   : out std_logic;
       TO_XIPSR_axi_rx_full    : out std_logic;
       TO_XIPSR_axi_rx_empty   : out std_logic;

       XIPCR_1_CPOL            : in std_logic;
       XIPCR_0_CPHA            : in std_logic;
       -------------------------------
       --*SPI port interface      * --
       -------------------------------
       IO0_I          : in std_logic;  -- MOSI signal in standard SPI
       IO0_O          : out std_logic;
       IO0_T          : out std_logic;
       -------------------------------
       IO1_I          : in std_logic;  -- MISO signal in standard SPI
       IO1_O          : out std_logic;
       IO1_T          : out std_logic;
       -----------------
       -- quad mode pins
       -----------------
       IO2_I          : in std_logic;
       IO2_O          : out std_logic;
       IO2_T          : out std_logic;
       ---------------
       IO3_I          : in std_logic;
       IO3_O          : out std_logic;
       IO3_T          : out std_logic;
       ---------------------------------
       -- common pins
       ----------------
       SPISEL         : in std_logic;
       -----
       SCK_I          : in std_logic;
       SCK_O_reg      : out std_logic;
       SCK_T          : out std_logic;
       -----
       SS_I           : in std_logic_vector((C_NUM_SS_BITS-1) downto 0);
       SS_O           : out std_logic_vector((C_NUM_SS_BITS-1) downto 0);
       SS_T           : out std_logic
       ---------------------------------
   );
end entity axi_qspi_xip_if;
--------------------------------------------------------------------------------
architecture imp of axi_qspi_xip_if is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

constant NEW_LOGIC : integer := 0; -- 3/29/2013
constant ACTIVE_LOW_RESET : std_logic := '0';
constant CMD_BITS_LENGTH : integer:= 8; -- 3/29/2013
-----
-- code coverage -- function assign_addr_bits (logic_info : integer) return integer is
-- code coverage --          variable addr_width_24 : integer:= 24;
-- code coverage --          variable addr_width_32 : integer:= 32;
-- code coverage -- begin
-- code coverage --      if logic_info = 0 then -- old logic for 24 bit addressing
-- code coverage --         return addr_width_24;
-- code coverage --      else
-- code coverage --         return addr_width_32;
-- code coverage --      end if;
-- code coverage -- end function assign_addr_bits;

signal nm_wr_en_CMD : std_logic_vector(7 downto 0);
signal nm_4byte_addr_en_CMD : std_logic_vector(7 downto 0);
type NM_WR_EN_STATE_TYPE is
      (NM_WR_EN_IDLE,       -- decode command can be combined here later
       NM_WR_EN,
       NM_WR_EN_DONE
       );
signal nm_wr_en_cntrl_ps : NM_WR_EN_STATE_TYPE;
signal nm_wr_en_cntrl_ns : NM_WR_EN_STATE_TYPE;
signal wr_en_under_process        : std_logic;
signal wr_en_under_process_d1     : std_logic;
signal load_wr_en, wr_en_done_reg : std_logic;
signal wr_en_done_d1, wr_en_done_d2 : std_logic;
signal wr_en_done     : std_logic;
signal data_loaded, cmd_sent : std_logic;

type NM_32_BIT_WR_EN_STATE_TYPE is
      (NM_32_BIT_IDLE,       -- decode command can be combined here later
       NM_32_BIT_EN,
       NM_32_BIT_EN_DONE
       );
signal nm_sm_4_byte_addr_ps : NM_32_BIT_WR_EN_STATE_TYPE;
signal nm_sm_4_byte_addr_ns : NM_32_BIT_WR_EN_STATE_TYPE;
signal four_byte_en_under_process         : std_logic;
signal four_byte_addr_under_process_d1    : std_logic;
signal load_4_byte_addr_en, four_byte_en_done, four_byte_en_done_reg : std_logic;
-----
-- constant declaration
constant FAST_READ         : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0):="00001011"; -- 0B
constant FAST_READ_DUAL_IO : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0):="00111011"; -- 3B
constant FAST_READ_QUAD_IO : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0):="10111011"; -- BB
constant C_RD_COUNT_WIDTH_INT : integer := clog2(C_XIP_FIFO_DEPTH);
constant C_WR_COUNT_WIDTH_INT : integer := clog2(C_XIP_FIFO_DEPTH);
constant RX_FIFO_CNTR_WIDTH   : integer := clog2(C_XIP_FIFO_DEPTH);

constant XIP_MIN_SIZE  : std_logic_vector(31 downto 0):= X"00ffffff";-- 24 bit address
--constant XIP_ADDR_BITS : integer := 24;
constant XIP_ADDR_BITS : integer := C_SPI_MEM_ADDR_BITS; -- assign_addr_bits(NEW_LOGIC);

constant RESET_ACTIVE : std_logic := '1';
constant COUNT_WIDTH  : INTEGER   := log2(C_NUM_TRANSFER_BITS)+1;
constant ACTIVE_HIGH_RESET : std_logic := '1';
constant ZERO_RX_FIFO_CNT   : std_logic_vector(RX_FIFO_CNTR_WIDTH-1 downto 0) := (others => '0');
signal   rx_fifo_count: std_logic_vector(RX_FIFO_CNTR_WIDTH-1 downto 0);
constant ALL_1          : std_logic_vector(0 to RX_FIFO_CNTR_WIDTH-1)
                            := (others => '0');
signal updown_cnt_en_rx,down_cnt_en_rx : std_logic;

type AXI_IF_STATE_TYPE is
                  (
                   IDLE,       -- decode command can be combined here later
                   RD_BURST
                   );
signal xip_sm_ps: AXI_IF_STATE_TYPE;
signal xip_sm_ns: AXI_IF_STATE_TYPE;

type STATE_TYPE is
                  (IDLE,       -- decode command can be combined here later
                   CMD_SEND,
                   HPM_DUMMY,
                   ADDR_SEND,
                   TEMP_ADDR_SEND,
                   --DUMMY_SEND,
                   DATA_SEND,
                   TEMP_DATA_SEND,
                   DATA_RECEIVE,
                   TEMP_DATA_RECEIVE
                   );
signal qspi_cntrl_ns : STATE_TYPE;
signal qspi_cntrl_ps : STATE_TYPE;

type WB_STATE_TYPE is
                  (WB_IDLE,       -- decode command can be combined here later
                   WB_WR_HPM,
                   WB_DONE
                   );
signal wb_cntrl_ns : WB_STATE_TYPE;
signal wb_cntrl_ps : WB_STATE_TYPE;

signal valid_decode      : std_logic;
signal s_axi_arready_cmb : std_logic;
signal temp_i            : std_logic;
signal SS_frm_axi        : std_logic_vector(C_NUM_SS_BITS-1 downto 0);
signal SS_frm_axi_int    : std_logic_vector(C_NUM_SS_BITS-1 downto 0);
signal SS_frm_axi_reg    : std_logic_vector(C_NUM_SS_BITS-1 downto 0);
signal type_of_burst     : std_logic; --_vector(1 downto 0);
signal axi_length        : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal size_length       : std_logic_vector(1 downto 0);
signal S_AXI4_RID_reg    : std_logic_vector(C_S_AXI4_ID_WIDTH-1 downto 0);
signal XIP_ADDR          : std_logic_vector(XIP_ADDR_BITS-1 downto 0);
signal one_byte_transfer : std_logic;
signal two_byte_transfer : std_logic;
signal four_byte_transfer: std_logic;
signal dtr_length        : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal write_length      : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal s_axi_rvalid_i    : std_logic;
signal dtr_cntr_empty    : std_logic;
signal last_bt_one_data_cmb : std_logic;
signal last_data_cmb        : std_logic;
signal last_data_acked      : std_logic;
signal last_data            : std_logic;
signal rd_error_int         : std_logic;
signal Data_From_Rx_FIFO    : std_logic_vector(C_S_AXI4_DATA_WIDTH-1 downto 0);
signal S_AXI4_RRESP_i       : std_logic_vector(1 downto 0);
signal S_AXI4_RDATA_i       : std_logic_vector(C_S_AXI4_DATA_WIDTH-1 downto 0);
-- signal s_axi_rvalid_i       : std_logic;
signal s_axi_rvalid_cmb     : std_logic;
signal xip_pr_state_idle    : std_logic;
signal pr_state_idle        : std_logic;
signal rready_i             : std_logic;
signal wrap_around_to_axi_clk : std_logic;
signal spiXfer_done_to_axi_1  : std_logic;
signal Rx_FIFO_Empty          : std_logic;
signal IO0_T_cntrl_axi        : std_logic;
signal IO1_T_cntrl_axi        : std_logic;
signal IO2_T_cntrl_axi        : std_logic;
signal IO3_T_cntrl_axi        : std_logic;
signal SCK_T_cntrl_axi        : std_logic;
signal load_axi_data_frm_axi  : std_logic;
--signal Transmit_addr_int      : std_logic_vector(23 downto 0);            -- 3/30/2013
signal Transmit_addr_int      : std_logic_vector(XIP_ADDR_BITS-1 downto 0); -- 3/30/2013
signal Rx_FIFO_rd_ack         : std_logic;
signal Data_To_Rx_FIFO        : std_logic_vector(C_S_AXI4_DATA_WIDTH-1 downto 0);
signal store_date_in_drr_fifo : std_logic;
--signal Rx_FIFO_Empty          : std_logic;
signal Rx_FIFO_almost_Full    : std_logic;
signal Rx_FIFO_almost_Empty   : std_logic;
--signal pr_state_idle          : std_logic;
signal spiXfer_done_frm_spi_clk: std_logic;
signal mst_modf_err_frm_spi_clk: std_logic;
signal wrap_around_frm_spi_clk : std_logic;
signal one_byte_xfer_frm_axi_clk  : std_logic;
signal two_byte_xfer_frm_axi_clk  : std_logic;
signal four_byte_xfer_frm_axi_clk : std_logic;
signal load_axi_data_frm_axi_clk  : std_logic;
--signal Transmit_Addr_frm_axi_clk  : std_logic_vector(23 downto 0);           -- 3/30/2013
signal Transmit_Addr_frm_axi_clk  : std_logic_vector(XIP_ADDR_BITS-1 downto 0);-- 3/30/2013
signal CPOL_frm_axi_clk           : std_logic;
signal CPHA_frm_axi_clk           : std_logic;
signal SS_frm_axi_clk             : std_logic_vector(C_NUM_SS_BITS-1 downto 0);
signal type_of_burst_frm_axi_clk  : std_logic; -- _vector(1 downto 0);
signal type_of_burst_frm_axi      : std_logic; -- _vector(1 downto 0);
signal axi_length_frm_axi_clk     : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal dtr_length_frm_axi_clk     : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal load_axi_data_to_spi_clk   : std_logic;
--signal Transmit_Addr_to_spi_clk   : std_logic_vector(23 downto 0);            -- 3/30/2013
signal Transmit_Addr_to_spi_clk   : std_logic_vector(XIP_ADDR_BITS-1 downto 0); -- 3/30/2013
signal last_7_addr_bits           : std_logic_vector(7 downto 0);
signal CPOL_to_spi_clk            : std_logic;
signal CPHA_to_spi_clk            : std_logic;
signal SS_to_spi_clk              : std_logic_vector(C_NUM_SS_BITS-1 downto 0);
signal type_of_burst_to_spi       : std_logic;
signal type_of_burst_to_spi_clk   : std_logic;
signal axi_length_to_spi_clk      : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal dtr_length_to_spi_clk      : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
--signal wrap_around_to_axi_clk     : std_logic;
signal spi_addr                   : std_logic_vector(31 downto 0);
signal spi_addr_i                 : std_logic_vector(XIP_ADDR_BITS-1  downto 0); -- (23 downto 0);
signal spi_addr_int               : std_logic_vector(XIP_ADDR_BITS-1  downto 0); -- (23 downto 0);
signal spi_addr_wrap              : std_logic_vector(XIP_ADDR_BITS-1  downto 0); -- (23 downto 0);
signal spi_addr_wrap_1            : std_logic_vector(XIP_ADDR_BITS-1  downto 0); -- (23 downto 0);

--signal Transmit_Addr_to_spi_clk   : std_logic_vector(23 downto 0);
signal load_wrap_addr             : std_logic;
signal wrap_two                   : std_logic;
signal wrap_four                  : std_logic;
signal wrap_eight                 : std_logic;
signal wrap_sixteen               : std_logic;
signal SPIXfer_done_int           : std_logic;
signal size_length_cntr           : std_logic_vector(1 downto 0);
signal size_length_cntr_fixed     : std_logic_vector(1 downto 0);
signal length_cntr                : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal cmd_addr_sent              : std_logic;
signal SR_5_Tx_Empty, SR_5_Tx_Empty_d1, SR_5_Tx_Empty_d2              : std_logic;
signal wrap_around                : std_logic;
signal rst_wrap_around            : std_logic;
--signal pr_state_idle              : std_logic;
signal one_byte_xfer_to_spi_clk   : std_logic;
signal two_byte_xfer_to_spi_clk   : std_logic;
signal four_byte_xfer_to_spi_clk  : std_logic;
--signal store_date_in_drr_fifo     : std_logic;
signal Data_To_Rx_FIFO_int        : std_logic_vector(C_S_AXI4_DATA_WIDTH-1 downto 0);
signal SPIXfer_done_int_pulse_d2  : std_logic;
signal receive_Data_int           : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
--signal Data_To_Rx_FIFO            : std_logic_vector(7 downto 0);
--signal load_axi_data_to_spi_clk   : std_logic;
signal Tx_Data_d1                 : std_logic_vector(31 downto 0);
signal Tx_Data_d2                 : std_logic_vector(39 downto 0);
signal internal_count             : std_logic_vector(3 downto 0);
signal SPI_cmd                    : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);
signal Transmit_Data              : std_logic_vector(0 to C_NUM_TRANSFER_BITS-1);
signal Data_Dir                   : std_logic;
signal Data_Mode_1                : std_logic;
signal Data_Mode_0                : std_logic;
signal Data_Phase                 : std_logic;
signal Quad_Phase                 : std_logic;
signal Addr_Mode_1                : std_logic;
signal Addr_Mode_0                : std_logic;
signal Addr_Bit                   : std_logic;
signal Addr_Phase                 : std_logic;
signal CMD_Mode_1                 : std_logic;
signal CMD_Mode_0                 : std_logic;
--signal cmd_addr_cntr              : std_logic_vector(2 downto 0);
--signal cmd_addr_sent              : std_logic;
signal transfer_start             : std_logic;
signal last_bt_one_data           : std_logic;
--signal SPIXfer_done_int           : std_logic;
signal actual_SPIXfer_done_int    : std_logic;
signal transfer_start_d1          : std_logic;
signal transfer_start_d2          : std_logic;
signal transfer_start_d3          : std_logic;
signal transfer_start_pulse       : std_logic;
signal SPIXfer_done_int_d1        : std_logic;
signal SPIXfer_done_int_pulse     : std_logic;
signal SPIXfer_done_int_pulse_d1  : std_logic;
--signal SPIXfer_done_int_pulse_d2  : std_logic;
signal SPIXfer_done_int_pulse_d3  : std_logic;
--signal SPIXfer_done_int           : std_logic;
signal mode_1                     : std_logic;
signal mode_0                     : std_logic;
signal Count                      : std_logic_vector(COUNT_WIDTH downto 0);
--signal receive_Data_int           : std_logic_vector(7 downto 0);
signal rx_shft_reg_mode_0011      : std_logic_vector(0 to (C_NUM_TRANSFER_BITS-1));
signal Sync_Set                   : std_logic;
signal Sync_Reset                 : std_logic;
signal sck_o_int                  : std_logic;
signal sck_d1                     : std_logic;
signal sck_d2                     : std_logic;
signal sck_rising_edge            : std_logic;
signal Shift_Reg                  : std_logic_vector(0 to C_NUM_TRANSFER_BITS-1);
signal Serial_Dout_0              : std_logic;
signal Serial_Dout_1              : std_logic;
signal Serial_Dout_2              : std_logic;
signal Serial_Dout_3              : std_logic;
signal pr_state_cmd_ph            : std_logic;

--signal qspi_cntrl_ps              : std_logic;
signal stop_clock                 : std_logic;
signal stop_clock_reg             : std_logic;
signal pr_state_data_receive      : std_logic;
signal pr_state_non_idle          : std_logic;
--signal pr_state_idle            : std_logic;
--signal pr_state_cmd_ph                  : std_logic;
--signal SPIXfer_done_int_pulse   : std_logic;
signal no_slave_selected          : std_logic;
--signal rst_wrap_around                  : std_logic;
signal IO0_T_control              : std_logic;
signal IO1_T_control              : std_logic;
signal IO2_T_control              : std_logic;
signal IO3_T_control              : std_logic;
signal addr_cnt                   : std_logic_vector(2 downto 0);
signal addr_cnt1                  : std_logic_vector(1 downto 0);
signal pr_state_addr_ph           : std_logic;
signal SS_tri_state_en_control    : std_logic;
signal SCK_tri_state_en_control   : std_logic;
signal IO0_tri_state_en_control   : std_logic;
signal IO1_tri_state_en_control   : std_logic;
signal IO2_tri_state_en_control   : std_logic;
signal IO3_tri_state_en_control   : std_logic;
signal IO0_T_cntrl_spi            : std_logic;
signal MODF_strobe_int            : std_logic;
signal SPISEL_sync                : std_logic;
signal spisel_d1                  : std_logic;
signal MODF_strobe                : std_logic;
signal Allow_MODF_Strobe          : std_logic;
signal sck_o_in                   : std_logic;
--signal SCK_O_reg                : std_logic;
signal slave_mode                 : std_logic;
--signal pr_state_non_idle        : std_logic;
signal mst_modf_err_to_axi_clk    : std_logic;
signal mst_modf_err_to_axi4_clk    : std_logic;
signal Rx_FIFO_Full_to_axi4_clk    : std_logic;
signal Rx_FIFO_Full_to_axi_clk     : std_logic;
signal Rx_FIFO_Full                : std_logic;
signal Rx_FIFO_Full_org            : std_logic;
signal Rx_FIFO_Empty_Synced_in_SPI_domain            : std_logic;
signal Rx_FIFO_Empty_Synced_in_AXI_domain            : std_logic;
signal one_byte_xfer               : std_logic;
signal two_byte_xfer               : std_logic;
signal four_byte_xfer              : std_logic;
signal XIP_trans_error             : std_logic;
signal XIP_trans_cdc_to_error             : std_logic;
signal load_cmd                    : std_logic;
signal load_cmd_to_spi_clk         : std_logic;
--signal load_axi_data_frm_axi_clk : std_logic;
signal load_cmd_frm_axi_clk        : std_logic;
signal axi_len_two     : std_logic;
signal axi_len_four    : std_logic;
signal axi_len_eight   : std_logic;
signal axi_len_sixteen : std_logic;
signal reset_inversion : std_logic;

signal new_tr            : std_logic;
signal SR_5_Tx_Empty_int : std_logic;
signal only_last_count   : std_logic;
signal rx_fifo_cntr_rst, rx_fifo_not_empty : std_logic;

signal store_date_in_drr_fifo_d1 : std_logic;
signal store_date_in_drr_fifo_d2 : std_logic;
signal store_date_in_drr_fifo_d3 : std_logic;
signal xip_ns_state_idle         : std_logic;
signal wrap_around_d1            : std_logic;
signal wrap_ack                  : std_logic;
signal wrap_ack_1                : std_logic;
signal wrap_around_d2            : std_logic;
signal wrap_around_d3            : std_logic;
signal start_after_wrap          : std_logic;
signal store_last_b4_wrap        : std_logic;

signal wrp_addr_len_16_siz_32 : std_logic;
signal wrp_addr_len_8_siz_32  : std_logic;
signal wrp_addr_len_4_siz_32  : std_logic;
signal wrp_addr_len_2_siz_32  : std_logic;

signal wrp_addr_len_16_siz_16 : std_logic;
signal wrp_addr_len_8_siz_16  : std_logic;
signal wrp_addr_len_4_siz_16  : std_logic;
signal wrp_addr_len_2_siz_16, start_after_wrap_d1  : std_logic;
signal SS_O_1                 : std_logic_vector((C_NUM_SS_BITS-1) downto 0);

signal WB_wr_en_CMD  : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);-- (7 downto 0);
signal WB_wr_sr_CMD  : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);-- (7 downto 0);
signal WB_wr_sr_DATA : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);-- (7 downto 0);
signal WB_wr_hpm_CMD : std_logic_vector(C_NUM_TRANSFER_BITS-1 downto 0);-- (7 downto 0);
signal wb_wr_en_done       : std_logic;
signal wb_wr_sr_done       : std_logic;
signal wb_wr_sr_data_done  : std_logic;
signal wb_wr_hpm_done      : std_logic;

signal load_wr_en_cmd      : std_logic;
signal load_wr_sr_cmd      : std_logic;
signal load_wr_sr_d0       : std_logic;
signal load_wr_sr_d1       : std_logic;
signal load_rd_sr          : std_logic;
signal load_wr_hpm         : std_logic;
signal wb_hpm_done         : std_logic;
signal wb_hpm_done_reg     : std_logic;
signal dis_sr_5_empty_reg  : std_logic;
signal dis_sr_5_empty      : std_logic;

signal wb_hpm_done_frm_spi,wb_hpm_done_frm_spi_clk,wb_hpm_done_to_axi : std_logic;
signal hpm_under_process         : std_logic;
signal hpm_under_process_d1      : std_logic;
signal s_axi_rlast_cmb           : std_logic;
signal store_date_in_drr_fifo_en : std_logic;



signal XIP_trans_error_cmb, XIP_trans_error_d1, XIP_trans_error_d2, XIP_trans_error_d3 : std_logic;
signal axi4_tr_over_d1, axi4_tr_over_d2               : std_logic;
signal arready_d1, arready_d2, arready_d3 : std_logic;
signal XIPSR_CPHA_CPOL_ERR_d1, XIPSR_CPHA_CPOL_ERR_d2 : std_logic;
signal axi4_tr_over_d3       : std_logic;
signal last_data_acked_int_2 : std_logic;
signal XIP_trans_error_int_2 : std_logic;
signal s_axi_arready_int_2                : std_logic;



-- signal XIP_trans_error_cmb : std_logic;
-- signal axi4_tr_over_d1, axi4_tr_over_d2               : std_logic;
-- signal arready_d1, arready_d2, arready_d3 : std_logic;
-- signal XIPSR_CPHA_CPOL_ERR_d1, XIPSR_CPHA_CPOL_ERR_d2 : std_logic;
-- signal axi4_tr_over_d3       : std_logic;
-- signal last_data_acked_int_2 : std_logic;
-- signal XIP_trans_error_int_2 : std_logic;
-- signal s_axi_arready_int_2                : std_logic;


signal Rx_FIFO_Empty_d1, Rx_FIFO_Empty_d2             : std_logic;
signal XIPSR_CPHA_CPOL_ERR_4                          : std_logic;
--signal mst_modf_err_to_axi4clk: std_logic;
signal xip_done                           : std_logic;
signal en_xip                             : std_logic;
signal new_tr_at_axi4                     : std_logic;

signal axi4_tr_over          : std_logic;
signal fifo_ren :std_logic;
--attribute ASYNC_REG          : string;
--attribute ASYNC_REG of XIP_TRANS_ERROR_AXI2AXI4_CDC : label is "TRUE";
--attribute ASYNC_REG of Rx_FIFO_Empty_AXI42AXI : label is "TRUE";
--attribute ASYNC_REG of CPHA_CPOL_ERR_AXI2AXI4_CDC  : label is "TRUE";
--attribute ASYNC_REG of ARREADY_PULSE_AXI42AXI_CDC: label is "TRUE";
--attribute ASYNC_REG of AXI4_TR_OVER_AXI42AXI_CDC   : label is "TRUE";

constant LOGIC_CHANGE : integer range 0 to 1 := 1;
constant MTBF_STAGES_AXI2S : integer range 0 to 6 := 3 ;
constant MTBF_STAGES_S2AXI : integer range 0 to 6 := 4 ;
constant MTBF_STAGES_AXI2AXILITE : integer range 0 to 6 := 4 ;


-----
begin
-----
S_AXI4_WREADY <= '0';
S_AXI4_BID    <= (others => '0');
S_AXI4_BRESP  <= (others => '0');
S_AXI4_BVALID <= '0';
S_AXI4_AWREADY<= '0';

  RX_FIFO_EMPTY_SYNC_AXI4_2_AXI_CDC : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1, -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => 2   
		)

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => '0',
        prmry_in             => Rx_FIFO_Empty,
        scndry_aclk          => S_AXI_ACLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => '0' ,
        scndry_out           => Rx_FIFO_Empty_Synced_in_AXI_domain 
       );


RX_FIFO_EMPTY_SYNC_AXI_2_SPI_CDC : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1, -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => 2   
		)

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => '0',
        prmry_in             => Rx_FIFO_Empty,
        scndry_aclk          => EXT_SPI_CLK ,
	prmry_vect_in        => (others => '0' ),
        scndry_resetn        => '0' ,
        scndry_out           => Rx_FIFO_Empty_Synced_in_SPI_domain 
       );


Rx_FIFO_Full <= Rx_FIFO_Full_org and not Rx_FIFO_Empty_Synced_in_SPI_domain;
valid_decode <= S_AXI4_ARVALID and xip_pr_state_idle;
reset_inversion <= not S_AXI4_ARESET;
-- address decoder and CS generation in AXI interface
I_DECODER : entity axi_quad_spi_v3_2_9.qspi_address_decoder
    generic map
    (
     C_BUS_AWIDTH          => XIP_ADDR_BITS, -- C_S_AXI4_ADDR_WIDTH,
     C_S_AXI4_MIN_SIZE     => XIP_MIN_SIZE,
     C_ARD_ADDR_RANGE_ARRAY=> C_XIP_FULL_ARD_ADDR_RANGE_ARRAY,
     C_ARD_NUM_CE_ARRAY    => C_XIP_FULL_ARD_NUM_CE_ARRAY,
     C_FAMILY              => "nofamily"
    )
    port map
    (
     Bus_clk               =>  S_AXI4_ACLK,                             -- in  std_logic;
     Bus_rst               =>  reset_inversion,                         -- in  std_logic;
     Address_In_Erly       =>  S_AXI4_ARADDR(XIP_ADDR_BITS-1 downto 0), -- in  std_logic_vector(0 to C_BUS_AWIDTH-1);
     Address_Valid_Erly    =>  s_axi_arready_cmb,                       -- in  std_logic;                            
     Bus_RNW               =>  valid_decode,                            -- in  std_logic;                            
     Bus_RNW_Erly          =>  valid_decode,                            -- in  std_logic;                            
     CS_CE_ld_enable       =>  s_axi_arready_cmb,                       -- in  std_logic;       
     Clear_CS_CE_Reg       =>  temp_i,                                  -- in  std_logic;
     RW_CE_ld_enable       =>  s_axi_arready_cmb,                       -- in  std_logic;
     CS_for_gaps           =>  open,                                    -- out std_logic;
      -- Decode output signals
     CS_Out                =>  SS_frm_axi,
     RdCE_Out              =>  open,
     WrCE_Out              =>  open
      );
-------------------------------------------------
STORE_AXI_ARBURST_P: process (S_AXI4_ACLK) is
begin
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
       if (S_AXI4_ARESET = ACTIVE_HIGH_RESET) then -- S_AXI4_ARESET is already inverted and made active high
         type_of_burst     <= '0';-- "01"; -- default is INCR burst
       elsif(s_axi_arready_cmb = '1')then
         type_of_burst     <= S_AXI4_ARBURST(1) ;
       end if;
    end if;
end process STORE_AXI_ARBURST_P;
-----------------------

S_AXI4_ARREADY_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            S_AXI4_ARREADY <= '0';
        else
            S_AXI4_ARREADY <= s_axi_arready_cmb;
        end if;
    end if;
end process S_AXI4_ARREADY_P;

-- S_AXI4_ARREADY <= s_axi_arready_cmb;

STORE_AXI_LENGTH_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            axi_length <= (others => '0');
        elsif(s_axi_arready_cmb = '1')then
            axi_length <= S_AXI4_ARLEN;
        end if;
    end if;
end process STORE_AXI_LENGTH_P;
---------------------------------------------------
STORE_AXI_SIZE_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            size_length <= (others => '0');
        elsif(s_axi_arready_cmb = '1')then
            size_length <= S_AXI4_ARSIZE(1 downto 0);
        end if;
    end if;
end process STORE_AXI_SIZE_P;
-------------------------------------------------------------------------------
REG_RID_P: process (S_AXI4_ACLK) is
begin
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
       if (S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
         S_AXI4_RID_reg       <= (others=> '0');
       elsif(s_axi_arready_cmb = '1')then
         S_AXI4_RID_reg       <= S_AXI4_ARID ;
       end if;
    end if;
end process REG_RID_P;
----------------------
S_AXI4_RID <= S_AXI4_ARID when (s_axi_arready_cmb = '1') else S_AXI4_RID_reg; --kar S_AXI4_RID_reg
-----------------------------
OLD_LOGIC_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
begin
    STORE_AXI_ADDR_P:process(S_AXI4_ACLK)is
    -----
    begin
    -----
        if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
            if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
                XIP_ADDR <= (others => '0');
            elsif(s_axi_arready_cmb = '1')then
                XIP_ADDR <= S_AXI4_ARADDR(23 downto 0);-- support for 24 bit address
            end if;
        end if;
    end process STORE_AXI_ADDR_P;
end generate OLD_LOGIC_GEN;
---------------------------

NEW_LOGIC_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
begin
    STORE_AXI_ADDR_P:process(S_AXI4_ACLK)is
    -----
    begin
    -----
        if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
            if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
                XIP_ADDR <= (others => '0');
            elsif(s_axi_arready_cmb = '1')then
                XIP_ADDR <= S_AXI4_ARADDR(C_SPI_MEM_ADDR_BITS-1 downto 0);-- support for 24 or 32 bit address
            end if;
        end if;
    end process STORE_AXI_ADDR_P;
end generate NEW_LOGIC_GEN;
---------------------------
------------------------------------------------------------------------------

ONE_BYTE_XFER_P:process(S_AXI4_ACLK) is
begin
-----
     if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            one_byte_xfer <= '0';
        elsif(s_axi_arready_cmb = '1')then
            one_byte_xfer <= not(or_reduce(S_AXI4_ARSIZE(1 downto 0)));
        end if;
     end if;
end process ONE_BYTE_XFER_P;

TWO_BYTE_XFER_P:process(S_AXI4_ACLK) is
begin
-----
     if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            two_byte_xfer <= '0';
        elsif(s_axi_arready_cmb = '1')then
            two_byte_xfer <= S_AXI4_ARSIZE(0);
        end if;
     end if;
end process TWO_BYTE_XFER_P;

FOUR_BYTE_XFER_P:process(S_AXI4_ACLK) is
begin
-----
     if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            four_byte_xfer <= '0';
        elsif(s_axi_arready_cmb = '1')then
            four_byte_xfer <= S_AXI4_ARSIZE(1);
        end if;
     end if;
end process FOUR_BYTE_XFER_P;

---------------------------------------------------------------------------------
STORE_DTR_LENGTH_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            dtr_length <= (others => '0');
        elsif(s_axi_arready_cmb = '1')then
            dtr_length <= S_AXI4_ARLEN;-- + "00000001";
       -- elsif(S_AXI4_RREADY = '1' and s_axi_rvalid_i = '1') then
      --elsif(Rx_FIFO_rd_ack = '1') then
      elsif(fifo_ren = '1') then
            dtr_length <=  dtr_length - '1';
        end if;
    end if;
end process STORE_DTR_LENGTH_P;
-----------------------------------------------------
STORE_WRITE_LENGTH_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then -- if(xip_sm_ps = IDLE)then
            write_length <= (others => '0');
        elsif(s_axi_arready_cmb = '1')then
            write_length <= S_AXI4_ARLEN + "00000001";
        elsif(spiXfer_done_to_axi_1 = '1')then
            write_length <=  write_length - '1';
        end if;
    end if;
end process STORE_WRITE_LENGTH_P;
-----------------------------------------------------
--dtr_cntr_empty <= or_Reduce(dtr_length);
-----------------------------------------------------
last_bt_one_data_cmb <= not(or_reduce(dtr_length(C_NUM_TRANSFER_BITS-1 downto 1))) and
                                                 dtr_length(0) and
                                                 S_AXI4_RREADY;
last_data_cmb        <= not(or_reduce(dtr_length(C_NUM_TRANSFER_BITS-1 downto 0)));

      RX_FIFO_FULL_CNTR_I : entity axi_quad_spi_v3_2_9.counter_f
      generic map(
        C_NUM_BITS    =>  RX_FIFO_CNTR_WIDTH,
        C_FAMILY      =>  "nofamily"
          )
      port map(
        Clk           =>  S_AXI4_ACLK,      -- in
        Rst           =>  S_AXI4_ARESET,   -- '0',              -- in
	-- coverage off
        Load_In       =>  ALL_1,            -- in
	-- coverage on
        Count_Enable  =>  updown_cnt_en_rx, -- in
        ----------------
        Count_Load    =>  s_axi_arready_cmb,-- in
        ----------------
        Count_Down    =>  down_cnt_en_rx,   -- in
        Count_Out     =>  rx_fifo_count,    -- out std_logic_vector
        Carry_Out     =>  open              -- out
        );

        updown_cnt_en_rx <= s_axi_arready_cmb     or
                            spiXfer_done_to_axi_1 or
                            (down_cnt_en_rx); -- this is to make the counter enable for decreasing.
        down_cnt_en_rx   <= S_AXI4_RREADY and s_axi_rvalid_i;
        only_last_count  <= not(or_reduce(rx_fifo_count(RX_FIFO_CNTR_WIDTH-1 downto 0))) and
                            last_data_cmb;
        rx_fifo_not_empty <= or_reduce(rx_fifo_count(RX_FIFO_CNTR_WIDTH-1 downto 0));

LAST_DATA_ACKED_P: process (S_AXI4_ACLK) is
-----------------
begin
-----
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET)     then
            last_data_acked <= '0';
        else
            if(S_AXI4_RREADY = '1' and last_data_acked = '1') then -- AXI Ready and Rlast active
                last_data_acked <= '0';
            elsif(S_AXI4_RREADY = '0' and last_data_acked = '1')then-- AXI not Ready and Rlast active, then hold the RLAST signal
                last_data_acked <= '1';
            else
                last_data_acked <=(last_data_cmb and
                                   Rx_FIFO_rd_ack);


            end if;
        end if;
    end if;
end process LAST_DATA_ACKED_P;
------------------------------
S_AXI4_RLAST <= '1' when (last_data_cmb='1' and S_AXI4_ARESET /= ACTIVE_HIGH_RESET ) else '0';--last_data_acked;
--------------------------------
S_AXI4_RDATA_RESP_P : process (S_AXI4_ACLK) is
begin
  if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
    if (S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
       S_AXI4_RRESP_i <= (others => '0');
       --karS_AXI4_RDATA_i <= (others => '0');
    else-- if(S_AXI4_RREADY = '1' )then --  and (Rx_FIFO_Empty = '0')then
       S_AXI4_RRESP_i  <= --(rd_error_int or mst_modf_err_to_axi_clk) & '0';
                         (mst_modf_err_to_axi4_clk) & '0';
       --karS_AXI4_RDATA_i  <= Data_From_Rx_FIFO;
    end if;
  end if;
end process S_AXI4_RDATA_RESP_P;
--------------------------------
S_AXI4_RRESP <= (mst_modf_err_to_axi4_clk) & '0';--S_AXI4_RRESP_i;
S_AXI4_RDATA <= Data_From_Rx_FIFO;--S_AXI4_RDATA_i;
-------------------------------
-----------------------------
-- S_AXI_RVALID_I_P : below process generates the RVALID response on read channel
----------------------
--karS_AXI_RVALID_I_P : process (S_AXI4_ACLK) is
--kar  begin
--kar    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
--kar      if (S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
--kar          s_axi_rvalid_i <= '0';
--kar      elsif(S_AXI4_RREADY = '1' and (s_axi_rvalid_i = '1')) then -- and (s_axi_rvalid_i = '1') then -- AXI Ready and Rlast active
--kar          s_axi_rvalid_i <= '0';--not(Rx_FIFO_Empty);--Rx_FIFO_rd_ack; -- '0';
--kar      elsif(S_AXI4_RREADY = '1' and (s_axi_rvalid_i = '0')) then -- and (s_axi_rvalid_i = '1') then -- AXI Ready and Rlast active
--kar          s_axi_rvalid_i <= not(Rx_FIFO_Empty);--Rx_FIFO_rd_ack; -- '0';
--kar      elsif(S_AXI4_RREADY = '0') and (s_axi_rvalid_i = '1') then
--kar          s_axi_rvalid_i <= s_axi_rvalid_i;
--kar      else
--kar          s_axi_rvalid_i <= not(Rx_FIFO_Empty);--Rx_FIFO_rd_ack;
--kar      end if;
--kar    end if;
--karend process S_AXI_RVALID_I_P;
-----------------------------
--karS_AXI_RVALID_I_P : process (S_AXI4_ACLK) is
--kar  begin
--kar    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
--kar      if (S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
--kar          s_axi_rvalid_i <= '0';
--kar      else
--kar          s_axi_rvalid_i <= not(Rx_FIFO_Empty);
--kar      end if;
--kar  end if;
--kar  end process S_AXI_RVALID_I_P;
s_axi_rvalid_i <= not(Rx_FIFO_Empty);
S_AXI4_RVALID <= s_axi_rvalid_i;
fifo_ren <= S_AXI4_RREADY and s_axi_rvalid_i;

-- -----------------------------
--fifo_non_empty <= not(Rx_FIFO_Empty);
-----------------------------
-- REN_Generation : below process generates the Fifo_Ren
----------------------
--karREN_Generation : process (S_AXI4_ACLK) is
--kar  begin
--kar    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
--kar      if (S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
--kar          fifo_ren <= '0';
--kar      elsif(S_AXI4_RREADY = '1' and (s_axi_rvalid_i = '1')) then
--kar          fifo_ren <= '1';
--kar      else
--kar          fifo_ren <= '0';--Rx_FIFO_rd_ack;
--kar      end if;
--kar    end if;
--karend process REN_Generation;
-----------------------------

xip_pr_state_idle <= '1' when xip_sm_ps = IDLE else '0';
xip_ns_state_idle <= '1' when xip_sm_ns = IDLE else '0';

rready_i      <= S_AXI4_RREADY and not last_data_cmb;


------------------------------------------------------------------------------
XIP_trans_error_cmb <= not(or_reduce(S_AXI4_ARBURST)) and (S_AXI4_ARVALID);
-- XIP_TR_ERROR_PULSE_STRETCH_1: single pulse for AXI4 transaction error

LOGIC_GENERATION_FDR : if (Async_Clk = 0) generate
attribute ASYNC_REG          : string;
attribute ASYNC_REG of XIP_TRANS_ERROR_AXI2AXI4_CDC : label is "TRUE";
--attribute ASYNC_REG of Rx_FIFO_Empty_AXI42AXI : label is "TRUE";
attribute ASYNC_REG of CPHA_CPOL_ERR_AXI2AXI4_CDC  : label is "TRUE";
attribute ASYNC_REG of ARREADY_PULSE_AXI42AXI_CDC: label is "TRUE";
attribute ASYNC_REG of AXI4_TR_OVER_AXI42AXI_CDC   : label is "TRUE";
begin
XIP_TR_ERROR_PULSE_STRETCH_1: process(S_AXI4_ACLK)is
begin
     if(S_AXI4_ACLK'event and S_AXI4_ACLK= '1') then
           if(S_AXI4_ARESET = '1') then
               XIP_trans_error_int_2 <= '0';
           else
               XIP_trans_error_int_2 <= XIP_trans_error_cmb xor
                                        XIP_trans_error_int_2;
           end if;
     end if;
end process XIP_TR_ERROR_PULSE_STRETCH_1;
-------------------------------------

XIP_TRANS_ERROR_AXI2AXI4_CDC: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => XIP_trans_error_d1,
                         C  => S_AXI_ACLK,
                         D  => XIP_trans_error_int_2,
                         R  => S_AXI_ARESETN
                       );
XIP_TRANS_ERROR_AXI2AXI4_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => XIP_trans_error_d2,
                         C  => S_AXI_ACLK,
                         D  => XIP_trans_error_d1,
                         R  => S_AXI_ARESETN
                       );
XIP_TRANS_ERROR_AXI2AXI4_2: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => XIP_trans_error_d3,
                         C  => S_AXI_ACLK,
                         D  => XIP_trans_error_d2,
                         R  => S_AXI_ARESETN
                       );
XIP_trans_error <= XIP_trans_error_d2 xor XIP_trans_error_d3;


------------------------------------------------------------------------------
--mst_modf_err_to_axi <= mst_modf_err_d2;

-- TO XIP Status Register


-- LAST_DATA_PULSE_STRETCH_1: single pulse for AXI4 transaction completion
LAST_DATA_PULSE_STRETCH_1: process(S_AXI4_ACLK)is
begin
     if(S_AXI4_ACLK'event and S_AXI4_ACLK= '1') then
           if(S_AXI4_ARESET = '1') then
                   last_data_acked_int_2 <= '0';
           else
                  last_data_acked_int_2 <= last_data_acked xor
                                           last_data_acked_int_2;
           end if;
     end if;
end process LAST_DATA_PULSE_STRETCH_1;
-------------------------------------
AXI4_TR_OVER_AXI42AXI_CDC: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => axi4_tr_over_d1,
                         C  => S_AXI_ACLK,
                         D  => last_data_acked_int_2,
                         R  => S_AXI_ARESETN
                       );
AXI4_TR_OVER_AXI42AXI_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => axi4_tr_over_d2,
                         C  => S_AXI_ACLK,
                         D  => axi4_tr_over_d1,
                         R  => S_AXI_ARESETN
                       );
AXI4_TR_OVER_AXI42AXI_2: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => axi4_tr_over_d3,
                         C  => S_AXI_ACLK,
                         D  => axi4_tr_over_d2,
                         R  => S_AXI_ARESETN
                       );
axi4_tr_over <= axi4_tr_over_d2 xor axi4_tr_over_d3;
-------------------------------------------------------------
-- ARREADY_PULSE_STRETCH_1: single pulse for AXI4 transaction acceptance
ARREADY_PULSE_STRETCH_1: process(S_AXI4_ACLK)is
begin
     if(S_AXI4_ACLK'event and S_AXI4_ACLK= '1') then
           if(S_AXI4_ARESET = '1') then
                   s_axi_arready_int_2 <= '0';
           else
                   s_axi_arready_int_2 <= s_axi_arready_cmb xor
                                          s_axi_arready_int_2;
           end if;
     end if;
end process ARREADY_PULSE_STRETCH_1;
-------------------------------------
ARREADY_PULSE_AXI42AXI_CDC: component FDR
              generic map(INIT => '1'
              )port map (
                         Q  => arready_d1,
                         C  => S_AXI_ACLK,
                         D  => s_axi_arready_int_2,
                         R  => S_AXI_ARESETN
                       );
ARREADY_PULSE_AXI42AXI_2: component FDR
              generic map(INIT => '1'
              )port map (
                         Q  => arready_d2,
                         C  => S_AXI_ACLK,
                         D  => arready_d1,
                         R  => S_AXI_ARESETN
                       );
ARREADY_PULSE_AXI42AXI_3: component FDR    -- 2/21/2012
              generic map(INIT => '1'
              )port map (
                         Q  => arready_d3,
                         C  => S_AXI_ACLK,
                         D  => arready_d2,
                         R  => S_AXI_ARESETN
                       );
new_tr_at_axi4 <= arready_d2 xor arready_d3;
-------------------------------------


------------------------------------------------------------------------------
-- CPHA_CPOL_ERR_AXI2AXI4_CDC: CDC flop at cross clock boundary
CPHA_CPOL_ERR_AXI2AXI4_CDC: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => XIPSR_CPHA_CPOL_ERR_d1,
                         C  => S_AXI4_ACLK,
                         D  => XIPSR_CPHA_CPOL_ERR,
                         R  => S_AXI4_ARESET
                       );
CPHA_CPOL_ERR_AXI2AXI4_1: component FDR
              generic map(INIT => '0'
              )port map (
                         Q  => XIPSR_CPHA_CPOL_ERR_d2,
                         C  => S_AXI4_ACLK,
                         D  => XIPSR_CPHA_CPOL_ERR_d1,
                         R  => S_AXI4_ARESET
                       );
XIPSR_CPHA_CPOL_ERR_4 <= XIPSR_CPHA_CPOL_ERR_d2;
-------------------------------------------------------------------------------

end generate LOGIC_GENERATION_FDR;

LOGIC_GENERATION_CDC : if (Async_Clk = 1) generate
--=================================================================================

XIP_TR_ERROR_PULSE_STRETCH_1_P: process(S_AXI4_ACLK)is
begin
     if(S_AXI4_ACLK'event and S_AXI4_ACLK= '1') then
           if(S_AXI4_ARESET = '1') then
               XIP_trans_error_int_2 <= '0';
           else
               XIP_trans_error_int_2 <= XIP_trans_error_cmb xor
                                        XIP_trans_error_int_2;
           end if;
     end if;
end process XIP_TR_ERROR_PULSE_STRETCH_1_P;

XIP_TRANS_ERROR_AXI42AXI: entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2AXILITE 
                )

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI_ARESETN ,
        prmry_in             => XIP_trans_error_int_2 ,
        scndry_aclk          => S_AXI_ACLK ,
        prmry_vect_in        => (others => '0') ,
        scndry_resetn        => S_AXI_ARESETN ,
        scndry_out            => XIP_trans_error_d2
    ); 
	XIP_TR_ERROR_PULSE_STRETCH_1: process(S_AXI_ACLK)is
begin
     if(S_AXI_ACLK'event and S_AXI_ACLK= '1') then
     
     XIP_trans_error_d3 <= XIP_trans_error_d2 ;
              
           end if;
end process XIP_TR_ERROR_PULSE_STRETCH_1;
XIP_trans_cdc_to_error <= XIP_trans_error_d2 xor XIP_trans_error_d3;
XIP_trans_error <= XIP_trans_cdc_to_error;
--=================================================================================
LAST_DATA_PULSE_STRETCH_1_CDC: process(S_AXI4_ACLK)is
begin
     if(S_AXI4_ACLK'event and S_AXI4_ACLK= '1') then
           if(S_AXI4_ARESET = '1') then
                   last_data_acked_int_2 <= '0';
                   --axi4_tr_over_d1       <= '0';
           else
                  last_data_acked_int_2 <= last_data_acked xor
                                           last_data_acked_int_2;
                  --axi4_tr_over_d1       <= last_data_acked_int_2;
           end if;
     end if;
end process LAST_DATA_PULSE_STRETCH_1_CDC;

AXI4_TR_OVER_AXI42AXI: entity lib_cdc_v1_0_2.cdc_sync 
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 1 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2AXILITE 
                )

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI4_ARESET ,
        prmry_in             => last_data_acked_int_2 ,
        scndry_aclk          => S_AXI_ACLK ,
            prmry_vect_in        => (others => '0') ,
        scndry_resetn        => S_AXI_ARESETN ,
        scndry_out           => axi4_tr_over_d2
    ); 
	LAST_DATA_PULSE_STRETCH_1: process(S_AXI_ACLK)is
begin
     if(S_AXI_ACLK'event and S_AXI_ACLK= '1') then
          
               axi4_tr_over_d3 <= axi4_tr_over_d2 ;
              
         --  end if;
     end if;
end process LAST_DATA_PULSE_STRETCH_1;
axi4_tr_over <= axi4_tr_over_d2 xor axi4_tr_over_d3;
--=================================================================================

ARREADY_PULSE_STRETCH_1_CDC: process(S_AXI4_ACLK)is
begin
     if(S_AXI4_ACLK'event and S_AXI4_ACLK= '1') then
           if(S_AXI4_ARESET = '1') then
                   s_axi_arready_int_2 <= '1';
                   --arready_d1          <= '0';
           else
                   s_axi_arready_int_2 <= s_axi_arready_cmb xor
                                          s_axi_arready_int_2;
                   --arready_d1          <= s_axi_arready_int_2;
           end if;
     end if;
end process ARREADY_PULSE_STRETCH_1_CDC;


ARREADY_PULSE_AXI42AXI: entity lib_cdc_v1_0_2.cdc_sync 
    generic map (
        C_CDC_TYPE                  => 1 , -- 2 is ack based level sync
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 1 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2AXILITE 
                )

    port map (
        prmry_aclk           => S_AXI4_ACLK , 
        prmry_resetn         => S_AXI4_ARESET ,
        prmry_in             => s_axi_arready_int_2 ,
        scndry_aclk          => S_AXI_ACLK ,
        prmry_vect_in        => (others => '0') ,
        scndry_resetn        => S_AXI_ARESETN ,
        scndry_out            => arready_d2
    );  
	ARREADY_PULSE_STRETCH_1: process(S_AXI_ACLK)is
begin
     if(S_AXI_ACLK'event and S_AXI_ACLK= '1') then
           
               arready_d3 <= arready_d2;
              
          -- end if;
     end if;
end process ARREADY_PULSE_STRETCH_1;
new_tr_at_axi4 <= arready_d2 xor arready_d3;
--==================================================================================

CPHA_CPOL_ERR_AXI2AXI4: entity lib_cdc_v1_0_2.cdc_sync 
    generic map (
        C_CDC_TYPE                  => 1 , -- 1 is level synch
        C_RESET_STATE               => 0 , -- no reset to be used in synchronisers
        C_SINGLE_BIT                => 1 , 
        C_FLOP_INPUT                => 0 ,
        C_VECTOR_WIDTH              => 1 ,
        C_MTBF_STAGES               => MTBF_STAGES_AXI2AXILITE 
                )

    port map (
        prmry_aclk           => S_AXI_ACLK , 
        prmry_resetn         => S_AXI_ARESETN ,
        prmry_in             => XIPSR_CPHA_CPOL_ERR ,
        scndry_aclk          => S_AXI4_ACLK ,
            prmry_vect_in        => (others => '0') ,
        scndry_resetn        => S_AXI4_ARESET ,
        scndry_out           => XIPSR_CPHA_CPOL_ERR_4
    ); 
--==================================================================================

end generate LOGIC_GENERATION_CDC;

TO_XIPSR_axi_rx_empty <= Rx_FIFO_Empty_Synced_in_AXI_domain;
--XIPSR_RX_EMPTY_P: process(S_AXI_ACLK)is
--begin
--    if(S_AXI_ACLK'event and S_AXI_ACLK = '1')then
--        if(S_AXI_ARESETN =  ACTIVE_HIGH_RESET) then
--            TO_XIPSR_axi_rx_empty <= '1';
--        elsif(axi4_tr_over = '1')then
--            TO_XIPSR_axi_rx_empty <= '1';
--        elsif(new_tr_at_axi4 = '1')then
--            TO_XIPSR_axi_rx_empty <= '0';
--        end if;
--    end if;
--end process XIPSR_RX_EMPTY_P;
-------------------------------------

TO_XIPSR_trans_error      <= XIP_trans_error;
TO_XIPSR_mst_modf_err     <= mst_modf_err_to_axi_clk;
TO_XIPSR_axi_rx_full      <= Rx_FIFO_Full_to_axi_clk;


-- XIP_PS_TO_NS_PROCESS: stores the next state memory
XIP_PS_TO_NS_PROCESS: process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
            xip_sm_ps <= IDLE;
        else
            xip_sm_ps <= xip_sm_ns;
        end if;
    end if;
end process XIP_PS_TO_NS_PROCESS;
-----------------------------
-- XIP_SM_P: below state machine is AXI interface state machine and controls the 
--           acceptance of new transaction as well as monitors data transaction
XIP_SM_P:process(
                 xip_sm_ps              ,
                 S_AXI4_ARVALID          ,
                 S_AXI4_RREADY          ,
                 S_AXI4_ARBURST         ,
                 XIP_trans_error_cmb        ,
                 mst_modf_err_to_axi4_clk,
                 Rx_FIFO_Full_to_Axi4_clk,
                 XIPSR_CPHA_CPOL_ERR_4  ,
                 Rx_FIFO_Empty          ,
                 wb_hpm_done_to_axi     ,
                 spiXfer_done_to_axi_1  ,
                 last_data_cmb          ,
                 Rx_FIFO_rd_ack         ,--,
                 last_data_acked
                 --wrap_around_to_axi_clk ,
                 --last_bt_one_data_cmb   ,
                 --Rx_FIFO_Empty          ,
                 --only_last_count        ,
                 --rx_fifo_not_empty      ,
                 --rx_fifo_count          ,
                 )is

begin
-----
    s_axi_arready_cmb <= '0';
    load_axi_data_frm_axi <= '0';
    load_cmd          <= '0';
    s_axi_rlast_cmb <= '0';
    s_axi_rvalid_cmb  <= '0';
    last_data <= '0';
    --IO0_T_cntrl_axi <= '1';
    --IO1_T_cntrl_axi <= '1';
    --IO2_T_cntrl_axi <= '1';
    --IO3_T_cntrl_axi <= '1';
    --SCK_T_cntrl_axi <= '1';

    temp_i          <= '0';

    case xip_sm_ps is
        when IDLE      => --if(XIP_cmd_error = '0') then
                            if(S_AXI4_ARVALID = '1')           and
                              (XIP_trans_error_cmb = '0')          and
                              (mst_modf_err_to_axi4_clk = '0') and
                              (Rx_FIFO_Full_to_axi4_clk = '0') and
                              (XIPSR_CPHA_CPOL_ERR_4 = '0')    and
                              (Rx_FIFO_Empty = '1')            and
                              (wb_hpm_done_to_axi = '1')
                              then
                              s_axi_arready_cmb     <= S_AXI4_ARVALID;
                              load_axi_data_frm_axi <= S_AXI4_ARVALID;
                              load_cmd              <= S_AXI4_ARVALID;
                              xip_sm_ns             <= RD_BURST;
                          else
                              xip_sm_ns <= IDLE;
                          end if;
        when RD_BURST =>
                         --if(last_data_cmb = '1') and (Rx_FIFO_rd_ack = '1') then--(rx_fifo_count = "000001") then
						 if (last_data_acked = '1') then
                             if(S_AXI4_RREADY = '1') then
                                 temp_i    <= '1';
                                 xip_sm_ns <= IDLE;
                             else
                                 xip_sm_ns <= RD_BURST;
                             end if;
                         else
                             xip_sm_ns <= RD_BURST;
                         end if;
        -- coverage off
        when others => xip_sm_ns <= IDLE;
        -- coverage on
    end case;
end process XIP_SM_P;
----------------------
-- AXI_24_BIT_ADDR_STORE_GEN: stores 24 bit axi address
AXI_24_BIT_ADDR_STORE_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
begin
    LOAD_TRANSMIT_ADDR_P:process(S_AXI4_ACLK)is
    -----
    begin
    -----
         if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
            if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
                Transmit_addr_int <= (others => '0');
            elsif(load_axi_data_frm_axi = '1') then
                Transmit_addr_int <= S_AXI4_ARADDR(23 downto 0);-- & XIPCR_7_0_CMD;
            end if;
         end if;
    end process LOAD_TRANSMIT_ADDR_P;
end generate AXI_24_BIT_ADDR_STORE_GEN;
-----------------------------------------
-- AXI_32_BIT_ADDR_STORE_GEN: stores 32 bit axi address
AXI_32_BIT_ADDR_STORE_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate -- 3/30/2013 updated for 32 or 24 bit addressing modes
begin
    LOAD_TRANSMIT_ADDR_P:process(S_AXI4_ACLK)is
    -----
    begin
    -----
         if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
            if(S_AXI4_ARESET =  ACTIVE_HIGH_RESET) then
                Transmit_addr_int <= (others => '0');
            elsif(load_axi_data_frm_axi = '1') then
                Transmit_addr_int <= S_AXI4_ARADDR(C_SPI_MEM_ADDR_BITS-1 downto 0);-- & XIPCR_7_0_CMD;
            end if;
         end if;
    end process LOAD_TRANSMIT_ADDR_P;
end generate AXI_32_BIT_ADDR_STORE_GEN;
-----------------------------------------
                         --      24/32-bit     --
  --    AXI Clk domain   -- __________________ SPI clk domain
  --Dout                 --|AXI clk           |-- Din
  --Rd_en                --|                  |-- Wr_en
  --Rd_clk               --|                  |-- Wr_clk
                         --|                  |--
  --Rx_FIFO_Empty        --|    Rx FIFO       |-- Rx_FIFO_Full_org
  --Rx_FIFO_almost_Empty --|                  |-- Rx_FIFO_almost_Full
  --Rx_FIFO_occ_Reversed --|                  |--
  --Rx_FIFO_rd_ack       --|                  |--
                         --|                  |--
                         --|                  |--
                         --|                  |--
                         --|__________________|--


-------------------------------------------------------------------------------
XIP_RECEIVE_FIFO_II: entity lib_fifo_v1_0_6.async_fifo_fg
  generic map(
        -- 3/30/2013 starts
        C_PRELOAD_LATENCY  => 0                  ,-- this is newly added and async_fifo_fg is referred from proc common v4_0
        C_PRELOAD_REGS     => 1                  ,-- this is newly added and async_fifo_fg is referred from proc common v4_0
        -- 3/30/2013 ends

        -- variables
        C_ALLOW_2N_DEPTH   => 1                   , -- : Integer := 0;  -- New paramter to leverage FIFO Gen 2**N depth
        C_FAMILY           => C_FAMILY            , -- : String  := "virtex5";  -- new for FIFO Gen
        C_DATA_WIDTH       => C_S_AXI4_DATA_WIDTH , -- : integer := 16;
        C_FIFO_DEPTH       => C_XIP_FIFO_DEPTH    , -- : integer := 256;
        C_RD_COUNT_WIDTH   => C_RD_COUNT_WIDTH_INT, -- : integer := 3 ;
        C_WR_COUNT_WIDTH   => C_WR_COUNT_WIDTH_INT, -- : integer := 3 ;
        C_HAS_ALMOST_EMPTY => 1                   , -- : integer := 1 ;
        C_HAS_ALMOST_FULL  => 1                   , -- : integer := 1 ;
        C_HAS_RD_ACK       => 1                   , -- : integer := 0 ;
        C_HAS_RD_COUNT     => 1                   , -- : integer := 1 ;
        C_HAS_WR_ACK       => 1                   , -- : integer := 0 ;
        C_HAS_WR_COUNT     => 1                   , -- : integer := 1 ;
        -- constants
        C_HAS_RD_ERR       => 0                   , -- : integer := 0 ;
        C_HAS_WR_ERR       => 0                   , -- : integer := 0 ;
        C_RD_ACK_LOW       => 0                   , -- : integer := 0 ;
        C_RD_ERR_LOW       => 0                   , -- : integer := 0 ;
        C_WR_ACK_LOW       => 0                   , -- : integer := 0 ;
        C_WR_ERR_LOW       => 0                   , -- : integer := 0
        C_ENABLE_RLOCS     => 0                   , -- : integer := 0 ;  -- not supported in FG
        C_USE_BLOCKMEM     => 0                     -- : integer := 1 ;  -- 0 = distributed RAM, 1 = BRAM
    )
  port map(
        Dout               => Data_From_Rx_FIFO           , -- : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
        Rd_en              => fifo_ren                    , --S_AXI4_RREADY               , -- : in std_logic := '0';
        Rd_clk             => S_AXI4_ACLK                 , -- : in std_logic := '1';
        Rd_ack             => Rx_FIFO_rd_ack              , -- : out std_logic;
        ------
        Din                => Data_To_Rx_FIFO             , -- : in std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');
        Wr_en              => store_date_in_drr_fifo_en   , --SPIXfer_done_Rx_Wr_en, --            , -- : in std_logic := '1';
        Wr_clk             => EXT_SPI_CLK                 , -- : in std_logic := '1';
        Wr_ack             => open, -- Rx_FIFO_wr_ack_open, -- : out std_logic;
        ------
        Full               => Rx_FIFO_Full_org, --Rx_FIFO_Full, -- : out std_logic;
        Empty              => Rx_FIFO_Empty               , -- : out std_logic;
        Almost_full        => Rx_FIFO_almost_Full         , -- : out std_logic;
        Almost_empty       => Rx_FIFO_almost_Empty        , -- : out std_logic;
        Rd_count           => open                        , -- : out std_logic_vector(C_RD_COUNT_WIDTH-1 downto 0);
        ------
        Ainit              => Rst_to_spi               ,--reset_RcFIFO_ptr_int, -- reset_RcFIFO_ptr_to_spi_clk ,--Rx_FIFO_ptr_RST             , -- : in std_logic := '1';
        Wr_count           => open                        , -- : out std_logic_vector(C_WR_COUNT_WIDTH-1 downto 0);
        Rd_err             => rd_error_int                , -- : out std_logic;
        Wr_err             => open                          -- : out std_logic
    );
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- from SPI clock
spiXfer_done_frm_spi_clk      <= store_date_in_drr_fifo_en; --spiXfer_done_int;
mst_modf_err_frm_spi_clk      <= not SPISEL_sync; -- 9/7/2013 -- MODF_strobe; -- 9/7/2013
--wrap_around_frm_spi_clk     <= wrap_around;
wb_hpm_done_frm_spi_clk       <= wb_hpm_done;
-- from AXI clocks
--size_length_frm_axi_clk       <= size_length;
one_byte_xfer_frm_axi_clk     <= one_byte_xfer;
two_byte_xfer_frm_axi_clk     <= two_byte_xfer;
four_byte_xfer_frm_axi_clk    <= four_byte_xfer;
load_axi_data_frm_axi_clk     <= load_axi_data_frm_Axi;-- 1 bit
Transmit_Addr_frm_axi_clk     <= Transmit_addr_int;    -- 24 bit
load_cmd_frm_axi_clk          <= load_cmd;
CPOL_frm_axi_clk              <= XIPCR_1_CPOL;         -- 1 bit
CPHA_frm_axi_clk              <= XIPCR_0_CPHA;         -- 1 bit

SS_frm_axi_clk                <= SS_frm_axi;    -- _reg;   -- based upon C_NUM_SS_BITS
type_of_burst_frm_axi_clk     <= type_of_burst; -- 1 bit signal take MSB only to differentiate WRAP and INCR burst
axi_length_frm_axi_clk        <= axi_length;    -- 8 bit used for WRAP transfer
dtr_length_frm_axi_clk        <= dtr_length;    -- 8 bit used for internbal counter

XIP_CLK_DOMAIN_SIGNALS:entity axi_quad_spi_v3_2_9.xip_cross_clk_sync
     generic map(
        C_S_AXI4_DATA_WIDTH     => C_S_AXI4_DATA_WIDTH ,
        Async_Clk               => Async_Clk          ,
        C_NUM_SS_BITS           => C_NUM_SS_BITS       ,
        C_SPI_MEM_ADDR_BITS         => XIP_ADDR_BITS
      )
     port map(
      EXT_SPI_CLK               => EXT_SPI_CLK   ,

      S_AXI4_ACLK               => S_AXI4_ACLK   ,
      S_AXI4_ARESET             => S_AXI4_ARESET ,

      S_AXI_ACLK                => S_AXI_ACLK    ,
      S_AXI_ARESETN             => S_AXI_ARESETN ,

      Rst_from_axi_cdc_to_spi       => Rst_to_spi    ,
      ----------------------------
      spiXfer_done_cdc_from_spi      => spiXfer_done_frm_spi_clk     ,
      spiXfer_done_cdc_to_axi_1     => spiXfer_done_to_axi_1        ,
      ----------------------------
      mst_modf_err_cdc_from_spi      => mst_modf_err_frm_spi_clk     ,
      mst_modf_err_cdc_to_axi       => mst_modf_err_to_axi_clk      ,
      mst_modf_err_cdc_to_axi4      => mst_modf_err_to_axi4_clk     ,
      ----------------------------
      one_byte_xfer_cdc_from_axi     => one_byte_xfer_frm_axi_clk    ,
      one_byte_xfer_cdc_to_spi      => one_byte_xfer_to_spi_clk     ,
      ----------------------------
      two_byte_xfer_cdc_from_axi     => two_byte_xfer_frm_axi_clk    ,
      two_byte_xfer_cdc_to_spi      => two_byte_xfer_to_spi_clk     ,
      ----------------------------
      four_byte_xfer_cdc_from_axi    => four_byte_xfer_frm_axi_clk   ,
      four_byte_xfer_cdc_to_spi     => four_byte_xfer_to_spi_clk    ,
      ----------------------------
      load_axi_data_cdc_from_axi     => load_axi_data_frm_axi_clk    ,
      load_axi_data_cdc_to_spi      => load_axi_data_to_spi_clk     ,
      ----------------------------
      Transmit_Addr_cdc_from_axi     => Transmit_Addr_frm_axi_clk    ,
      Transmit_Addr_cdc_to_spi      => Transmit_Addr_to_spi_clk     ,
      ----------------------------
      load_cmd_cdc_from_axi          => load_cmd_frm_axi_clk         ,
      load_cmd_cdc_to_spi           => load_cmd_to_spi_clk          ,
      ----------------------------
      CPOL_cdc_from_axi              => CPOL_frm_axi_clk             ,
      CPOL_cdc_to_spi               => CPOL_to_spi_clk              ,
      ----------------------------
      CPHA_cdc_from_axi              => CPHA_frm_axi_clk             ,
      CPHA_cdc_to_spi               => CPHA_to_spi_clk              ,
      ------------------------------
      SS_cdc_from_axi                => SS_frm_axi_clk               ,
      SS_cdc_to_spi                 => SS_to_spi_clk                ,
      ----------------------------
      type_of_burst_cdc_from_axi     => type_of_burst_frm_axi_clk    ,
      type_of_burst_cdc_to_spi      => type_of_burst_to_spi_clk     ,
      ----------------------------
      axi_length_cdc_from_axi        => axi_length_frm_axi_clk       ,
      axi_length_cdc_to_spi         => axi_length_to_spi_clk        ,
      ----------------------------
      dtr_length_cdc_from_axi        => dtr_length_frm_axi_clk       ,
      dtr_length_cdc_to_spi         => dtr_length_to_spi_clk        , --,
      ----------------------------
      Rx_FIFO_Full_cdc_from_spi      => Rx_FIFO_Full                 ,
      Rx_FIFO_Full_cdc_to_axi       => Rx_FIFO_Full_to_axi_clk      ,
      Rx_FIFO_Full_cdc_to_axi4      => Rx_FIFO_Full_to_axi4_clk     ,
      ----------------------------
      wb_hpm_done_cdc_from_spi       => wb_hpm_done_frm_spi_clk      ,
      wb_hpm_done_cdc_to_axi        => wb_hpm_done_to_axi
     );

-------------------------------------------------------------------------------
-- STORE_NEW_TR_P: This process is used in INCR and WRAP to check for any new transaction from AXI
STORE_NEW_TR_32_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
begin
-----
     -------------------------------------
     STORE_NEW_TR_P:process(EXT_SPI_CLK)is
     -----
     begin
     -----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
             if(Rst_to_spi = '1') then
                     new_tr <= '0';
             elsif( (load_axi_data_to_spi_clk = '1') 
                 or (load_wr_hpm = '1') -- needed for enabling 32 bit addressing mode
                 or (load_wr_en = '1')  -- needed for write enabling before enabling the 32 bit addressing mode
                 ) then
                     new_tr <= '1';
             elsif(SR_5_Tx_Empty_int = '1') then --(wrap_around = '0' and qspi_cntrl_ns = IDLE)then
                     new_tr <= '0';
             end if;
     end if;
     end process STORE_NEW_TR_P;
     -------------------------------------
end generate STORE_NEW_TR_32_BIT_ADDR_GEN;
---------------------------------------------

STORE_NEW_TR_24_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
begin
-----
        -------------------------------------
	STORE_NEW_TR_P:process(EXT_SPI_CLK)is
	-----
	begin
	-----
	if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
		if(Rst_to_spi = '1') then
			new_tr <= '0';
		elsif(  (load_axi_data_to_spi_clk = '1') 
		     or (load_wr_hpm = '1') 
                 -- or (load_wr_en = '1') 
                     ) then
			new_tr <= '1';
		elsif(SR_5_Tx_Empty_int = '1') then --(wrap_around = '0' and qspi_cntrl_ns = IDLE)then
			new_tr <= '0';
		end if;
	end if;
	end process STORE_NEW_TR_P;
        -------------------------------------
end generate STORE_NEW_TR_24_BIT_ADDR_GEN;
-------------------------------------------------------------------------------

-- STORE_INITAL_ADDR_P: The address frm AXI should be stored in the SPI environment
-- as the address generation logic will work in this domain.
STORE_24_BIT_SPI_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
begin
-----
    -------------------------------------
    STORE_INITAL_ADDR_P:process(EXT_SPI_CLK)is
    -----
    begin
    -----
         if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
             if(Rst_to_spi = '1') then
                spi_addr <= (others => '0');
             elsif(load_axi_data_to_spi_clk = '1')then
                spi_addr <= "00000000" & Transmit_Addr_to_spi_clk;-- (31 downto 8);
             elsif(load_wrap_addr = '1')then --  and (type_of_burst_to_spi = '1') then
                spi_addr <= "00000000" & spi_addr_wrap;
             end if;
         end if;
    end process STORE_INITAL_ADDR_P;
    -------------------------------------
end generate STORE_24_BIT_SPI_ADDR_GEN;
-----------------------------------------

STORE_32_BIT_SPI_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate -- 3/30/2013
begin
-----
     ----------------------------------
     STORE_INITAL_ADDR_P:process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(Rst_to_spi = '1') then
                 spi_addr <= (others => '0');
              elsif(load_axi_data_to_spi_clk = '1')then
                 spi_addr <= Transmit_Addr_to_spi_clk;-- (31 downto 0);
              elsif(load_wrap_addr = '1')then --  and (type_of_burst_to_spi = '1') then
                 spi_addr <= spi_addr_wrap;
              end if;
          end if;
     end process STORE_INITAL_ADDR_P;
     ----------------------------------
end generate STORE_32_BIT_SPI_ADDR_GEN;
---------------------------------------
-------------------------------------------------------------------------------

-- below signals will store the length of AXI transaction in the SPI domain
axi_len_two     <= not(or_Reduce(axi_length_to_spi_clk(3 downto 1))) and
                                 axi_length_to_spi_clk(0);
axi_len_four    <= not(or_Reduce(axi_length_to_spi_clk(3 downto 2))) and
                       and_reduce(axi_length_to_spi_clk(1 downto 0));
axi_len_eight   <= not(axi_length_to_spi_clk(3)) and
                      and_Reduce(axi_length_to_spi_clk(2 downto 0));
axi_len_sixteen <= and_reduce(axi_length_to_spi_clk(3 downto 0));
-------------------------------------------------------------------------------

-- below signals store the WRAP information in SPI domain
wrap_two       <= '1' when (type_of_burst_to_spi_clk = '1' and
                            axi_len_two = '1')
                  else
                  '0';
wrap_four      <= '1' when (type_of_burst_to_spi_clk = '1' and
                            axi_len_four = '1')
                  else
                  '0';
wrap_eight     <= '1' when (type_of_burst_to_spi_clk = '1' and
                            axi_len_eight = '1')
                  else
                  '0';
wrap_sixteen   <= '1' when (type_of_burst_to_spi_clk = '1' and
                            axi_len_sixteen = '1')
                  else
                  '0';
-------------------------------------------------------------------------------

-- SPI_ADDRESS_REG: This process stores the initial address coming from the AXI in
--                  two registers. one register will store this address till the
--                  transaction ends, while other will be updated based upon type of
--                  transaction as well as at the end of each SPI transfer. this is
--                  used for internal use only.
SPI_24_BIT_ADDRESS_REG_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate 
begin
-----
    SPI_ADDRESS_REG : process(EXT_SPI_CLK) is
    --variable xfer : std_logic_vector(2 downto 0);
    begin
    --   xfer := four_byte_xfer_to_spi_clk & two_byte_xfer_to_spi_clk & one_byte_xfer_to_spi_clk;
       if (EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
           if (Rst_to_spi = RESET_ACTIVE) then
              spi_addr_i <= (others => '0');
              spi_addr_int <= (others => '0');
           else
              if (load_cmd_to_spi_clk = '1') then
                     spi_addr_i   <= Transmit_Addr_to_spi_clk(23 downto 0);
                     spi_addr_int <= Transmit_Addr_to_spi_clk(23 downto 0);
              -- below is address generation for the WRAP mode
              elsif (type_of_burst_to_spi_clk = '1')  and
                    (SPIXfer_done_int_pulse_d2 = '1') and
                    (cmd_addr_sent = '1') then
                  spi_addr_int(23 downto 0) <= spi_addr_int(23 downto 0) + '1';
                  case size_length_cntr is
                  when "00" => -- 8-bit access
                    if(wrap_two = '1') then
                      spi_addr_i(23 downto 1) <= spi_addr_i(23 downto 1);
                      spi_addr_i(0)           <= not (spi_addr_i(0));
                    elsif(wrap_four = '1') then -- the byte address increment will take 2 address bits
                      spi_addr_i(23 downto 2) <= spi_addr_i(23 downto 2);
                      spi_addr_i(1 downto 0)  <= spi_addr_i(1 downto 0) + "01";
                    elsif(wrap_eight = '1') then -- the byte address increment will take 3 address bits
                      spi_addr_i(23 downto 3) <= spi_addr_i(23 downto 3);
                      spi_addr_i(2 downto 0)  <= spi_addr_i(2 downto 0) + "001";
                    elsif(wrap_sixteen = '1') then -- the byte address increment will take 4 address bits for 16's wrap
                      spi_addr_i(23 downto 4) <= spi_addr_i(23 downto 4);
                      spi_addr_i(3 downto 0)  <= spi_addr_i(3 downto 0) + "0001";
                    else
                      spi_addr_i <= spi_addr_i + "0001";
                    end if;
                  when "01" => -- 16-bit access
                    if(wrap_two = '1') then
                      spi_addr_i(23 downto 2) <= spi_addr_i(23 downto 2);
                      spi_addr_i(1 downto 0)  <= spi_addr_i(1 downto 0) + "10";
                    elsif(wrap_four = '1') then
                      spi_addr_i(23 downto 3) <= spi_addr_i(23 downto 3);
                      spi_addr_i(2 downto 0)  <= spi_addr_i(2 downto 0) + "010";
                    elsif(wrap_eight = '1') then
                      spi_addr_i(23 downto 4) <= spi_addr_i(23 downto 4);
                      spi_addr_i(3 downto 0)  <= spi_addr_i(3 downto 0) + "0010";
                    elsif(wrap_sixteen = '1') then
                      spi_addr_i(23 downto 5) <= spi_addr_i(23 downto 5);
                      spi_addr_i(4 downto 0)  <= spi_addr_i(4 downto 0) + "00010";
                    else
                      spi_addr_i <= spi_addr_i + "0010";
                    end if;
                when "10" => -- 32-bit access
                    if(wrap_two = '1') then
                      spi_addr_i(23 downto 3) <= spi_addr_i(23 downto 3);
                      spi_addr_i(2 downto 0)  <=spi_addr_i(2 downto 0) + "100";
                    elsif(wrap_four = '1') then
                      spi_addr_i(23 downto 4) <= spi_addr_i(23 downto 4);
                      spi_addr_i(3 downto 0)  <=spi_addr_i(3 downto 0) + "0100";
                    elsif(wrap_eight = '1') then
                      spi_addr_i(23 downto 5) <= spi_addr_i(23 downto 5);
                      spi_addr_i(4 downto 0)  <=spi_addr_i(4 downto 0) + "00100";
                    elsif(wrap_sixteen = '1') then
                      spi_addr_i(23 downto 6) <= spi_addr_i(23 downto 6);
                      spi_addr_i(5 downto 0)  <=spi_addr_i(5 downto 0) + "000100";
                    else
                       spi_addr_i <= spi_addr_i + "0100";
                    end if;
                  -- coverage off
                  when others =>
                    spi_addr_i <= spi_addr_i;
                  -- coverage on
                  end case;
           -- below is address generation for the INCR mode
           elsif (type_of_burst_to_spi_clk = '0')  and
                 (SPIXfer_done_int_pulse_d2 = '1') and
                 (cmd_addr_sent = '1') then
                  spi_addr_i(23 downto 0) <= spi_addr_i(23 downto 0) + '1';
           end if;
       end if;
      end if;
    end process SPI_ADDRESS_REG;
    ----------------------------------
end generate SPI_24_BIT_ADDRESS_REG_GEN;
----------------------------------------

SPI_32_BIT_ADDRESS_REG_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate 
begin
-----
    SPI_ADDRESS_REG : process(EXT_SPI_CLK) is
    --variable xfer : std_logic_vector(2 downto 0);
    begin
    --   xfer := four_byte_xfer_to_spi_clk & two_byte_xfer_to_spi_clk & one_byte_xfer_to_spi_clk;
       if (EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
           if (Rst_to_spi = RESET_ACTIVE) then
              spi_addr_i <= (others => '0');
              spi_addr_int <= (others => '0');
           else
              if (load_cmd_to_spi_clk = '1') then
                     spi_addr_i   <= Transmit_Addr_to_spi_clk(31 downto 0);
                     spi_addr_int <= Transmit_Addr_to_spi_clk(31 downto 0);
              -- below is address generation for the WRAP mode
              elsif (type_of_burst_to_spi_clk = '1')  and
                    (SPIXfer_done_int_pulse_d2 = '1') and
                    (cmd_addr_sent = '1') then
                  spi_addr_int(31 downto 0) <= spi_addr_int(31 downto 0) + '1';

                  case size_length_cntr is
                    when "00" => -- 8-bit access
                      if(wrap_two = '1') then
                        spi_addr_i(31 downto 1) <= spi_addr_i(31 downto 1);
                        spi_addr_i(0)           <= not (spi_addr_i(0));
                      elsif(wrap_four = '1') then -- the byte address increment will take 2 address bits
                        spi_addr_i(31 downto 2) <= spi_addr_i(31 downto 2);
                        spi_addr_i(1 downto 0)  <= spi_addr_i(1 downto 0) + "01";
                      elsif(wrap_eight = '1') then -- the byte address increment will take 3 address bits
                        spi_addr_i(31 downto 3) <= spi_addr_i(31 downto 3);
                        spi_addr_i(2 downto 0)  <= spi_addr_i(2 downto 0) + "001";
                      elsif(wrap_sixteen = '1') then -- the byte address increment will take 4 address bits for 16's wrap
                        spi_addr_i(31 downto 4) <= spi_addr_i(31 downto 4);
                        spi_addr_i(3 downto 0)  <= spi_addr_i(3 downto 0) + "0001";
                      else
                        spi_addr_i <= spi_addr_i + "0001";
                      end if;
                    when "01" => -- 16-bit access
                      if(wrap_two = '1') then
                        spi_addr_i(31 downto 2) <= spi_addr_i(31 downto 2);
                        spi_addr_i(1 downto 0)  <= spi_addr_i(1 downto 0) + "10";
                      elsif(wrap_four = '1') then
                        spi_addr_i(31 downto 3) <= spi_addr_i(31 downto 3);
                        spi_addr_i(2 downto 0)  <= spi_addr_i(2 downto 0) + "010";
                      elsif(wrap_eight = '1') then
                        spi_addr_i(31 downto 4) <= spi_addr_i(31 downto 4);
                        spi_addr_i(3 downto 0)  <= spi_addr_i(3 downto 0) + "0010";
                      elsif(wrap_sixteen = '1') then
                        spi_addr_i(31 downto 5) <= spi_addr_i(31 downto 5);
                        spi_addr_i(4 downto 0)  <= spi_addr_i(4 downto 0) + "00010";
                      else
                        spi_addr_i <= spi_addr_i + "0010";
                      end if;
                    when "10" => -- 32-bit access
                      if(wrap_two = '1') then
                        spi_addr_i(31 downto 3) <= spi_addr_i(31 downto 3);
                        spi_addr_i(2 downto 0)  <=spi_addr_i(2 downto 0) + "100";
                      elsif(wrap_four = '1') then
                        spi_addr_i(31 downto 4) <= spi_addr_i(31 downto 4);
                        spi_addr_i(3 downto 0)  <=spi_addr_i(3 downto 0) + "0100";
                      elsif(wrap_eight = '1') then
                        spi_addr_i(31 downto 5) <= spi_addr_i(31 downto 5);
                        spi_addr_i(4 downto 0)  <=spi_addr_i(4 downto 0) + "00100";
                      elsif(wrap_sixteen = '1') then
                        spi_addr_i(31 downto 6) <= spi_addr_i(31 downto 6);
                        spi_addr_i(5 downto 0)  <=spi_addr_i(5 downto 0) + "000100";
                      else
                         spi_addr_i <= spi_addr_i + "0100";
                      end if;
                  -- coverage off
                  when others =>
                    spi_addr_i <= spi_addr_i;
                  -- coverage on
                  end case;
           -- below is address generation for the INCR mode
           elsif (type_of_burst_to_spi_clk = '0')  and
                 (SPIXfer_done_int_pulse_d2 = '1') and
                 (cmd_addr_sent = '1') then
                  spi_addr_i(31 downto 0) <= spi_addr_i(31 downto 0) + '1';
           end if;
       end if;
      end if;
    end process SPI_ADDRESS_REG;
end generate SPI_32_BIT_ADDRESS_REG_GEN;
----------------------------------------

-- SPI_WRAP_ADDR_REG: this is separate process used for WRAP address generation
SPI_24_WRAP_ADDR_REG_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate 
begin
  SPI_WRAP_ADDR_REG : process(EXT_SPI_CLK) is
  --variable xfer : std_logic_vector(2 downto 0);
  begin
  --   xfer := four_byte_xfer_to_spi_clk & two_byte_xfer_to_spi_clk & one_byte_xfer_to_spi_clk;
     if (EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
         if (Rst_to_spi = RESET_ACTIVE) then
            spi_addr_wrap <= (others => '0');
         else
            if (load_cmd_to_spi_clk = '1') then
                   spi_addr_wrap   <= Transmit_Addr_to_spi_clk(23 downto 0);
            elsif(wrap_ack_1 = '1') then
                   spi_addr_wrap <= spi_addr_wrap_1;
            -- below is address generation for the WRAP mode
            elsif (type_of_burst_to_spi_clk = '1') and
                  (store_date_in_drr_fifo = '1')   and
                  (cmd_addr_sent = '1') then
                case size_length_cntr_fixed is
                when "00" => -- 8-bit access
                  if(wrap_two = '1') then
                    spi_addr_wrap(23 downto 1) <= spi_addr_wrap(23 downto 1);
                    spi_addr_wrap(0)           <= not (spi_addr_wrap(0));
                  elsif(wrap_four = '1') then -- the byte address increment will take 2 address bits
                    spi_addr_wrap(23 downto 2) <= spi_addr_wrap(23 downto 2);
                    spi_addr_wrap(1 downto 0)  <= spi_addr_wrap(1 downto 0) + "01";
                  elsif(wrap_eight = '1') then -- the byte address increment will take 3 address bits
                    spi_addr_wrap(23 downto 3) <= spi_addr_wrap(23 downto 3);
                    spi_addr_wrap(2 downto 0)  <= spi_addr_wrap(2 downto 0) + "001";
                  elsif(wrap_sixteen = '1') then -- the byte address increment will take 4 address bits for 16's wrap
                    spi_addr_wrap(23 downto 4) <= spi_addr_wrap(23 downto 4);
                    spi_addr_wrap(3 downto 0)  <= spi_addr_wrap(3 downto 0) + "0001";
                  else
                    spi_addr_wrap <= spi_addr_wrap + "0001";
                  end if;
                when "01" => -- 16-bit access
                  if(wrap_two = '1') then
                    spi_addr_wrap(23 downto 2) <= spi_addr_wrap(23 downto 2);
                    spi_addr_wrap(1 downto 0)  <= spi_addr_wrap(1 downto 0) + "10";
                  elsif(wrap_four = '1') then
                    spi_addr_wrap(23 downto 3) <= spi_addr_wrap(23 downto 3);
                    spi_addr_wrap(2 downto 0)  <= spi_addr_wrap(2 downto 0) + "010";
                  elsif(wrap_eight = '1') then
                    spi_addr_wrap(23 downto 4) <= spi_addr_wrap(23 downto 4);
                    spi_addr_wrap(3 downto 0)  <= spi_addr_wrap(3 downto 0) + "0010";
                  elsif(wrap_sixteen = '1') then
                    spi_addr_wrap(23 downto 5) <= spi_addr_wrap(23 downto 5);
                    spi_addr_wrap(4 downto 0)  <= spi_addr_wrap(4 downto 0) + "00010";
                  else
                    spi_addr_wrap <= spi_addr_wrap + "0010";
                  end if;
                when "10" => -- 32-bit access
                    if(wrap_two = '1') then
                      spi_addr_wrap(23 downto 3) <= spi_addr_wrap(23 downto 3);
                      spi_addr_wrap(2 downto 0)  <=spi_addr_wrap(2 downto 0) + "100";
                    elsif(wrap_four = '1') then
                      spi_addr_wrap(23 downto 4) <= spi_addr_wrap(23 downto 4);
                      spi_addr_wrap(3 downto 0)  <=spi_addr_wrap(3 downto 0) + "0100";
                    elsif(wrap_eight = '1') then
                      spi_addr_wrap(23 downto 5) <= spi_addr_wrap(23 downto 5);
                      spi_addr_wrap(4 downto 0)  <=spi_addr_wrap(4 downto 0) + "00100";
                    elsif(wrap_sixteen = '1') then
                      spi_addr_wrap(23 downto 6) <= spi_addr_wrap(23 downto 6);
                      spi_addr_wrap(5 downto 0)  <=spi_addr_wrap(5 downto 0) + "000100";
                    else
                       spi_addr_wrap <= spi_addr_wrap + "0100";
                    end if;
                -- coverage off
                when others =>
                  spi_addr_wrap <= spi_addr_wrap;
                -- coverage on
                end case;
         end if;
     end if;
    end if;
  end process SPI_WRAP_ADDR_REG;
end generate SPI_24_WRAP_ADDR_REG_GEN;
--------------------------------------
SPI_32_WRAP_ADDR_REG_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate 
begin
  SPI_WRAP_ADDR_REG : process(EXT_SPI_CLK) is
  --variable xfer : std_logic_vector(2 downto 0);
  begin
  --   xfer := four_byte_xfer_to_spi_clk & two_byte_xfer_to_spi_clk & one_byte_xfer_to_spi_clk;
     if (EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
         if (Rst_to_spi = RESET_ACTIVE) then
            spi_addr_wrap <= (others => '0');
         else
            if (load_cmd_to_spi_clk = '1') then
                   spi_addr_wrap   <= Transmit_Addr_to_spi_clk(31 downto 0);
            elsif(wrap_ack_1 = '1') then
                   spi_addr_wrap <= spi_addr_wrap_1;
            -- below is address generation for the WRAP mode
            elsif (type_of_burst_to_spi_clk = '1') and
                  (store_date_in_drr_fifo = '1')   and
                  (cmd_addr_sent = '1') then
                case size_length_cntr_fixed is
                  when "00" => -- 8-bit access
                    if(wrap_two = '1') then
                      spi_addr_wrap(31 downto 1) <= spi_addr_wrap(31 downto 1);
                      spi_addr_wrap(0)           <= not (spi_addr_wrap(0));
                    elsif(wrap_four = '1') then -- the byte address increment will take 2 address bits
                      spi_addr_wrap(31 downto 2) <= spi_addr_wrap(31 downto 2);
                      spi_addr_wrap(1 downto 0)  <= spi_addr_wrap(1 downto 0) + "01";
                    elsif(wrap_eight = '1') then -- the byte address increment will take 3 address bits
                      spi_addr_wrap(31 downto 3) <= spi_addr_wrap(31 downto 3);
                      spi_addr_wrap(2 downto 0)  <= spi_addr_wrap(2 downto 0) + "001";
                    elsif(wrap_sixteen = '1') then -- the byte address increment will take 4 address bits for 16's wrap
                      spi_addr_wrap(31 downto 4) <= spi_addr_wrap(31 downto 4);
                      spi_addr_wrap(3 downto 0)  <= spi_addr_wrap(3 downto 0) + "0001";
                    else
                      spi_addr_wrap <= spi_addr_wrap + "0001";
                    end if;
                  when "01" => -- 16-bit access
                    if(wrap_two = '1') then
                      spi_addr_wrap(31 downto 2) <= spi_addr_wrap(31 downto 2);
                      spi_addr_wrap(1 downto 0)  <= spi_addr_wrap(1 downto 0) + "10";
                    elsif(wrap_four = '1') then
                      spi_addr_wrap(31 downto 3) <= spi_addr_wrap(31 downto 3);
                      spi_addr_wrap(2 downto 0)  <= spi_addr_wrap(2 downto 0) + "010";
                    elsif(wrap_eight = '1') then
                      spi_addr_wrap(31 downto 4) <= spi_addr_wrap(31 downto 4);
                      spi_addr_wrap(3 downto 0)  <= spi_addr_wrap(3 downto 0) + "0010";
                    elsif(wrap_sixteen = '1') then
                      spi_addr_wrap(31 downto 5) <= spi_addr_wrap(31 downto 5);
                      spi_addr_wrap(4 downto 0)  <= spi_addr_wrap(4 downto 0) + "00010";
                    else
                      spi_addr_wrap <= spi_addr_wrap + "0010";
                    end if;
                  when "10" => -- 32-bit access
                    if(wrap_two = '1') then
                      spi_addr_wrap(31 downto 3) <= spi_addr_wrap(31 downto 3);
                      spi_addr_wrap(2 downto 0)  <=spi_addr_wrap(2 downto 0) + "100";
                    elsif(wrap_four = '1') then
                      spi_addr_wrap(31 downto 4) <= spi_addr_wrap(31 downto 4);
                      spi_addr_wrap(3 downto 0)  <=spi_addr_wrap(3 downto 0) + "0100";
                    elsif(wrap_eight = '1') then
                      spi_addr_wrap(31 downto 5) <= spi_addr_wrap(31 downto 5);
                      spi_addr_wrap(4 downto 0)  <=spi_addr_wrap(4 downto 0) + "00100";
                    elsif(wrap_sixteen = '1') then
                      spi_addr_wrap(31 downto 6) <= spi_addr_wrap(31 downto 6);
                      spi_addr_wrap(5 downto 0)  <=spi_addr_wrap(5 downto 0) + "000100";
                    else
                       spi_addr_wrap <= spi_addr_wrap + "0100";
                    end if;
                  -- coverage off
                  when others =>
                    spi_addr_wrap <= spi_addr_wrap;
                  -- coverage on
                end case;
         end if;
     end if;
    end if;
  end process SPI_WRAP_ADDR_REG;
  ----------------------------------
end generate SPI_32_WRAP_ADDR_REG_GEN;

--------------------------------------
-------------------------------------------------------------------------------
-- SPI_WRAP_ADDR_REG: this is separate process used for WRAP address generation
LOAD_SPI_WRAP_ADDR_REG : process(EXT_SPI_CLK) is
begin
-----
   if (EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
       if (Rst_to_spi = RESET_ACTIVE) then
          spi_addr_wrap_1 <= (others => '0');
       else
          if (wrap_around = '1') then
          -- below is address generation for the WRAP mode
              case size_length_cntr_fixed is
                when "00" => -- 8-bit access
                  if(wrap_two = '1') then
                    spi_addr_wrap_1 <= spi_addr_wrap + '1';
                  elsif(wrap_four = '1') then -- the byte address increment will take 2 address bits
                    spi_addr_wrap_1 <= spi_addr_wrap + "01";
                  elsif(wrap_eight = '1') then -- the byte address increment will take 3 address bits
                    spi_addr_wrap_1 <= spi_addr_wrap + "001";
                  elsif(wrap_sixteen = '1') then -- the byte address increment will take 4 address bits for 16's wrap
                    spi_addr_wrap_1 <= spi_addr_wrap + "0001";
                  else
                    spi_addr_wrap_1 <= spi_addr_wrap + "0001";
                  end if;
                when "01" => -- 16-bit access
                  if(wrap_two = '1') then
                    spi_addr_wrap_1 <= spi_addr_wrap + "10";
                  elsif(wrap_four = '1') then
                    spi_addr_wrap_1 <= spi_addr_wrap + "010";
                  elsif(wrap_eight = '1') then
                    spi_addr_wrap_1 <= spi_addr_wrap + "0010";
                  elsif(wrap_sixteen = '1') then
                    spi_addr_wrap_1 <= spi_addr_wrap + "00010";
                  else
                    spi_addr_wrap_1 <= spi_addr_wrap + "0010";
                  end if;
                when "10" => -- 32-bit access
                  if(wrap_two = '1') then
                    spi_addr_wrap_1 <=spi_addr_wrap + "100";
                  elsif(wrap_four = '1') then
                    spi_addr_wrap_1 <=spi_addr_wrap + "0100";
                  elsif(wrap_eight = '1') then
                    spi_addr_wrap_1 <=spi_addr_wrap + "00100";
                  elsif(wrap_sixteen = '1') then
                    spi_addr_wrap_1 <=spi_addr_wrap + "000100";
                  else
                    spi_addr_wrap_1 <=spi_addr_wrap + "0100";
                  end if;
                -- coverage off
                when others =>
                  spi_addr_wrap_1 <= spi_addr_wrap;
                -- coverage on
              end case;
       end if;
   end if;
  end if;
end process LOAD_SPI_WRAP_ADDR_REG;
-------------------------------------------------------------------------------
-- WRAP_AROUND_GEN_P : WRAP boundary detection logic
WRAP_AROUND_GEN_P:process(EXT_SPI_CLK)is
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
         if(  (Rst_to_spi = '1')
	    or(rst_wrap_around = '1')
	   ) then
              wrap_around <= '0';
         elsif(type_of_burst_to_spi_clk = '1')then
             case size_length_cntr_fixed is
                 when "00" => -- byte transfer
                     if(wrap_two = '1')         and
                       (spi_addr_wrap(1) = '1') and
                       (store_date_in_drr_fifo = '1')then -- then
                       wrap_around <= --spi_addr_wrap(1) and
                                      not SR_5_Tx_Empty;
                     elsif(wrap_four = '1')                  and
                          (spi_addr_wrap(1 downto 0) = "11") and
                          (store_date_in_drr_fifo = '1')then -- then -- the byte address increment will take 2 address bits
                       wrap_around <= --and_reduce(spi_addr_wrap(1 downto 0)) and
                                      not SR_5_Tx_Empty;
                     elsif(wrap_eight = '1')                  and
                          (spi_addr_wrap(2 downto 0) = "111") and
                          (store_date_in_drr_fifo = '1')then -- then -- the byte address increment will take 3 address bits
                       wrap_around <= --and_reduce(spi_addr_wrap(2 downto 0)) and
                                      not SR_5_Tx_Empty;
                     elsif(wrap_sixteen = '1')                 and
                          (spi_addr_wrap(3 downto 0) = "1111") and
                          (store_date_in_drr_fifo = '1')then -- the byte address increment will take 4 address bits for 16's wrap
                       wrap_around <= --and_reduce(spi_addr_wrap(3 downto 0)) and
                                      not SR_5_Tx_Empty;
                     else
                       wrap_around <= '0';
                     end if;
                 when "01" => -- 16-bit access
                     if(wrap_two = '1') then -- and (spi_addr_wrap(1 downto 0) = "10") and (store_date_in_drr_fifo = '1')then
                       wrap_around <= not SR_5_Tx_Empty      and
                                      store_date_in_drr_fifo and
                                      wrp_addr_len_2_siz_16;
                     elsif(wrap_four = '1') then -- and (spi_addr_wrap(2 downto 0) = "110") and (store_date_in_drr_fifo = '1')then
                       wrap_around <= not SR_5_Tx_Empty      and
                                      store_date_in_drr_fifo and
                                      wrp_addr_len_4_siz_16;
                     elsif(wrap_eight = '1') then -- and (spi_addr_wrap(3 downto 0) = "1110") and (store_date_in_drr_fifo = '1')then
                       wrap_around <= not SR_5_Tx_Empty      and
                                      store_date_in_drr_fifo and
                                      wrp_addr_len_8_siz_16;
                     elsif(wrap_sixteen = '1') then -- and (spi_addr_wrap(4 downto 0) =  "11110") and (store_date_in_drr_fifo = '1') then
                       wrap_around <= not SR_5_Tx_Empty      and
                                      store_date_in_drr_fifo and
                                      wrp_addr_len_16_siz_16;
                     else
                       wrap_around <= '0';
                     end if;
                 when "10" => -- 32-bit access
                     if(wrap_two = '1') then -- and (spi_addr_wrap(2 downto 0) = "100") and (store_date_in_drr_fifo = '1') then
                       wrap_around <= not SR_5_Tx_Empty      and
                                      store_date_in_drr_fifo and
                                      wrp_addr_len_2_siz_32;
                     elsif(wrap_four = '1') then -- and (spi_addr_wrap(3 downto 0) = "1100") and (store_date_in_drr_fifo = '1') then
                       wrap_around <= not SR_5_Tx_Empty      and
                                      store_date_in_drr_fifo and
                                      wrp_addr_len_4_siz_32;
                     elsif(wrap_eight = '1') then -- and (spi_addr_wrap(4 downto 0) = "11100") and (store_date_in_drr_fifo = '1') then
                       wrap_around <= not SR_5_Tx_Empty      and
                                      store_date_in_drr_fifo and
                                      wrp_addr_len_8_siz_32;
                     elsif(wrap_sixteen = '1') then --and (spi_addr_wrap(5 downto 0) = "111100") and (store_date_in_drr_fifo = '1') then
                       wrap_around <=  not SR_5_Tx_Empty      and
                                       store_date_in_drr_fifo and
                                       wrp_addr_len_16_siz_32;
                     else
                       wrap_around <= '0';
                     end if;
                 -- coverage off
                 when others => wrap_around <= wrap_around;
                 -- coverage on
                 end case;
         end if;
     end if;
end process WRAP_AROUND_GEN_P;
-------------------------------------------------------------------------------
load_wrap_addr <= wrap_around;

wrp_addr_len_16_siz_32 <= '1' when (spi_addr_wrap(5 downto 0) = "111100") else '0';
wrp_addr_len_8_siz_32  <= '1' when (spi_addr_wrap(4 downto 0) =  "11100") else '0';
wrp_addr_len_4_siz_32  <= '1' when (spi_addr_wrap(3 downto 0) =   "1100") else '0';
wrp_addr_len_2_siz_32  <= '1' when (spi_addr_wrap(2 downto 0) =    "100") else '0';
-----------------------------------------------------------------------------------
wrp_addr_len_16_siz_16 <= '1' when (spi_addr_wrap(4 downto 0) =  "11110") else '0';
wrp_addr_len_8_siz_16  <= '1' when (spi_addr_wrap(3 downto 0) =   "1110") else '0';
wrp_addr_len_4_siz_16  <= '1' when (spi_addr_wrap(2 downto 0) =    "110") else '0';
wrp_addr_len_2_siz_16  <= '1' when (spi_addr_wrap(1 downto 0) =     "10") else '0';
-----------------------------------------------------------------------------------
-- LEN_CNTR_P: This is data length counter. this counter will start decrementing
--             only when the first 4 bytes are transferred from SPI.
LEN_CNTR_24_BIT_GEN:  if C_SPI_MEM_ADDR_BITS = 24 generate 
begin
-----
  LEN_CNTR_P:process(EXT_SPI_CLK)is
  begin
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(Rst_to_spi = '1') then
               length_cntr <= (others => '0');
           elsif(load_wr_hpm='1') then
               length_cntr <= "00000011";
           elsif(load_cmd_to_spi_clk = '1')then
               length_cntr <= dtr_length_to_spi_clk;
           elsif((SPIXfer_done_int = '1')  and
                 (((size_length_cntr = "00") and
                   (cmd_addr_sent = '1')
                   )or
                   (hpm_under_process_d1 = '1'))
                   )then
               length_cntr <= length_cntr - "00000001";
           end if;
       end if;
  end process LEN_CNTR_P;
  -----------------------
end generate LEN_CNTR_24_BIT_GEN;
---------------------------------
LEN_CNTR_32_BIT_GEN:  if C_SPI_MEM_ADDR_BITS = 32 generate 
begin
-----
  LEN_CNTR_P:process(EXT_SPI_CLK)is
  begin
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(Rst_to_spi = '1') then
               length_cntr <= (others => '0');
           elsif(load_wr_hpm='1') then
               length_cntr <= "00000000";
           elsif(load_cmd_to_spi_clk = '1')then
               length_cntr <= dtr_length_to_spi_clk;
           elsif((SPIXfer_done_int = '1')  and
                 (((size_length_cntr = "00") and
                   (cmd_addr_sent = '1')
                   )or
                   (hpm_under_process_d1 = '1') or (wr_en_under_process_d1 = '1'))
                   )then
               length_cntr <= length_cntr - "00000001";
           end if;
       end if;
  end process LEN_CNTR_P;
  -----------------------
end generate LEN_CNTR_32_BIT_GEN;
---------------------------------
-------------------------------------------------------------------------------
SR_5_TX_EMPTY_32_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
begin

    SR_5_Tx_Empty_int<= (not(or_reduce(length_cntr)) and
                         store_date_in_drr_fifo      and
                         cmd_addr_sent)
                         or
                        (-- (hpm_under_process_d1 or wr_en_under_process_d1)       and
                        (hpm_under_process or wr_en_under_process)       and
                         not(or_reduce(length_cntr)) and
                         SPIXfer_done_int_pulse);

    -- LEN_CNTR_P: This is data length counter. this counter will start decrementing
    --             only when the first 4 bytesfor 24 bit addressing and 5 bytes for 32 bit addressing mode are transferred from SPI.
    SR_5_TX_EMPTY_P:process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
             if(Rst_to_spi = '1') then
                 SR_5_Tx_Empty <= '1';
             elsif(load_cmd_to_spi_clk = '1') or (load_wr_hpm = '1') or (load_wr_en = '1') then
                 SR_5_Tx_Empty <= '0';
             elsif(SR_5_Tx_Empty_int = '1')then
                 SR_5_Tx_Empty <= '1';
             end if;
         end if;
    end process SR_5_TX_EMPTY_P;

end generate SR_5_TX_EMPTY_32_BIT_ADDR_GEN;
-------------------------------------------------------------------------------

SR_5_TX_EMPTY_24_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
begin
     SR_5_Tx_Empty_int<= (not(or_reduce(length_cntr)) and
                         store_date_in_drr_fifo      and
                         cmd_addr_sent)
                         or
                         (-- (hpm_under_process_d1 or wr_en_under_process_d1)       and
                         (hpm_under_process 
                          --or wr_en_under_process
                          )   
			  and
                          not(
			      or_reduce(length_cntr)) 
			      and
                              SPIXfer_done_int_pulse
			      );

    -- LEN_CNTR_P: This is data length counter. this counter will start decrementing
    --             only when the first 4 bytesfor 24 bit addressing and 5 bytes for 32 bit addressing mode are transferred from SPI.
    SR_5_TX_EMPTY_P:process(EXT_SPI_CLK)is
    begin
         if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
             if(Rst_to_spi = '1') then
                 SR_5_Tx_Empty <= '1';
             elsif(load_cmd_to_spi_clk = '1') or (load_wr_hpm = '1') 
                  --or (load_wr_en = '1')
                  then
                 SR_5_Tx_Empty <= '0';
             elsif(SR_5_Tx_Empty_int = '1')then
                 SR_5_Tx_Empty <= '1';
             end if;
         end if;
    end process SR_5_TX_EMPTY_P;
end generate SR_5_TX_EMPTY_24_BIT_ADDR_GEN;

-------------------------------------------
DELAY_FIFO_EMPTY_P:process(EXT_SPI_CLK)is
begin
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
         if(Rst_to_spi = '1') then
             SR_5_Tx_Empty_d1 <= '1';
             SR_5_Tx_Empty_d2 <= '1';
         else
             SR_5_Tx_Empty_d1 <= SR_5_Tx_Empty;
             SR_5_Tx_Empty_d2 <= SR_5_Tx_Empty_d1;
         end if;
     end if;
end process DELAY_FIFO_EMPTY_P;
-------------------------------------------------------------------------------
last_bt_one_data <= not(or_reduce(length_cntr(7 downto 1))) and length_cntr(0);
-------------------------------------------------------------------------------

SIZE_CNTR_LD_SPI_CLK_P:process(EXT_SPI_CLK)is
-----
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
         if(Rst_to_spi = '1') then
             size_length_cntr_fixed <= (others => '0');
             size_length_cntr       <= (others => '0');
         elsif(
                (pr_state_idle = '1') or ((SPIXfer_done_int = '1') and
                                          (size_length_cntr = "00"))
                )then
             --if(one_byte_xfer_to_spi_clk = '1' )then
             --    size_length_cntr_fixed <= "00";
             --    size_length_cntr <= "00";             -- 1 byte
             --els
             if(two_byte_xfer_to_spi_clk = '1')then
                 size_length_cntr_fixed <= "01";
                 size_length_cntr <= "01";             -- half word
             elsif(four_byte_xfer_to_spi_clk = '1') then
                 size_length_cntr_fixed <= "10";
                 size_length_cntr <= "11";             -- word
             else
                 size_length_cntr_fixed <= "00";
                 size_length_cntr <= "00";             -- other and one_byte_xfer_to_spi_clk = '1' is merged here
             end if;
         elsif(SPIXfer_done_int = '1')        and
              (one_byte_xfer_to_spi_clk = '0')and
              (cmd_addr_sent = '1') then -- (size_length_cntr /= "00") then
             size_length_cntr <= size_length_cntr - "01";
         end if;
     end if;
end process SIZE_CNTR_LD_SPI_CLK_P;
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

store_date_in_drr_fifo <= not(or_reduce(size_length_cntr)) and
                          SPIXfer_done_int                 and 
                          cmd_addr_sent;
-------------------------------------------------------------------------------

STORE_STROBE_SPI_CLK_P:process(EXT_SPI_CLK)is
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
         if(Rst_to_spi = '1') then
             store_date_in_drr_fifo_d1 <= '0';
             store_date_in_drr_fifo_d2 <= '0';
             store_date_in_drr_fifo_d3 <= '0';
         else
             store_date_in_drr_fifo_d1 <= store_date_in_drr_fifo;
             store_date_in_drr_fifo_d2 <= store_date_in_drr_fifo_d1;
             store_date_in_drr_fifo_d3 <= store_date_in_drr_fifo_d2;
         end if;
     end if;
end process STORE_STROBE_SPI_CLK_P;
-------------------------------------------------------------------------------

MD_12_WR_EN_TO_FIFO_GEN: if C_SPI_MODE = 1 or C_SPI_MODE = 2 generate
begin
-----
     --------------------------------------------------------------------
     WB_FIFO_WR_EN_GEN: if C_SPI_MEMORY = 1 generate
     begin
     -----
	  store_date_in_drr_fifo_en <= store_date_in_drr_fifo_d3;
     end generate WB_FIFO_WR_EN_GEN;
     --------------------------------------------------------------------
     NM_FIFO_WR_EN_GEN: if C_SPI_MEMORY = 2 generate
     begin
     -----
          STORE_DATA_24_BIT_ADDRESS_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
          begin
               store_date_in_drr_fifo_en <= store_date_in_drr_fifo_d3;  
          end generate STORE_DATA_24_BIT_ADDRESS_GEN;
          -------------------------------------------
          STORE_DATA_32_BIT_ADDRESS_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
          begin
               store_date_in_drr_fifo_en <= store_date_in_drr_fifo_d3;     
          end generate STORE_DATA_32_BIT_ADDRESS_GEN;
          -------------------------------------------
     end generate NM_FIFO_WR_EN_GEN;
     --------------------------------------------------------------------
	      SP_FIFO_WR_EN_GEN: if C_SPI_MEMORY = 3 generate
     begin
     -----
          STORE_DATA_24_BIT_ADDRESS_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
          begin
               store_date_in_drr_fifo_en <= store_date_in_drr_fifo_d3;  
          end generate STORE_DATA_24_BIT_ADDRESS_GEN;
          -------------------------------------------
          STORE_DATA_32_BIT_ADDRESS_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
          begin
               store_date_in_drr_fifo_en <= store_date_in_drr_fifo_d3;     
          end generate STORE_DATA_32_BIT_ADDRESS_GEN;
          -------------------------------------------
     end generate SP_FIFO_WR_EN_GEN;

     --------------------------------------------------------------------
	 
end generate MD_12_WR_EN_TO_FIFO_GEN;


MD_0_WR_EN_TO_FIFO_GEN: if C_SPI_MODE = 0 generate
begin
-----
     WB_FIFO_WR_EN_GEN: if C_SPI_MEMORY = 1 generate
     begin
     -----
     store_date_in_drr_fifo_en <= store_date_in_drr_fifo;
     end generate WB_FIFO_WR_EN_GEN;

     NM_FIFO_WR_EN_GEN: if C_SPI_MEMORY = 2 generate
     begin
     -----
     store_date_in_drr_fifo_en <= store_date_in_drr_fifo;
     end generate NM_FIFO_WR_EN_GEN;
	 
	 SP_FIFO_WR_EN_GEN: if C_SPI_MEMORY = 3 generate
     begin
     -----
     store_date_in_drr_fifo_en <= store_date_in_drr_fifo;
     end generate SP_FIFO_WR_EN_GEN;

end generate MD_0_WR_EN_TO_FIFO_GEN;
-------------------------------------------------------------------------------
SHIFT_TX_REG_24_BIT_GEN: if  C_SPI_MEM_ADDR_BITS = 24 generate
begin
  SHIFT_TX_REG_SPI_CLK_P:process(EXT_SPI_CLK)is
  -----
  begin
  -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(Rst_to_spi = '1')then
               Tx_Data_d1 <= (others => '0');
           elsif(load_wr_hpm = '1') then
               Tx_Data_d1(31 downto 24) <= WB_wr_hpm_CMD;
               Tx_Data_d1(23 downto 0)  <= (others => '0');
           elsif(load_axi_data_to_spi_clk = '1')then
              Tx_Data_d1 <= SPI_cmd & Transmit_Addr_to_spi_clk; --  & SPI_cmd;-- (31 downto 8);
           elsif(wrap_around = '1') then
               Tx_Data_d1 <= SPI_cmd & spi_addr_wrap;--spi_addr_i & SPI_cmd;
           elsif(SPIXfer_done_int = '1')then
               Tx_Data_d1 <= --"11111111" & -- Tx_Data_d1(7 downto 0) &
                             --                 --Tx_Data_d1(31 downto 8);
                             --                 Tx_Data_d1(31 downto 8);
                             Tx_Data_d1(23 downto 0) & "11111111";
           end if;
       end if;
  end process SHIFT_TX_REG_SPI_CLK_P;
Transmit_Data <= Tx_Data_d1(31 downto 24);
end generate SHIFT_TX_REG_24_BIT_GEN;
-------------------------------------------------------
SHIFT_TX_REG_32_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
begin
  SHIFT_TX_REG_SPI_CLK_P:process(EXT_SPI_CLK)is
  -----
  begin
  -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(Rst_to_spi = '1')then
               Tx_Data_d1       <= (others => '0');
               --last_7_addr_bits <= (others => '0');
           elsif(load_wr_en = '1') then
               Tx_Data_d1(31 downto 24) <= "00000110"; ---nm_wr_en_CMD;
               Tx_Data_d1(23 downto 0)  <= (others => '0');
           elsif(load_wr_hpm = '1')then
               Tx_Data_d1(31 downto 24) <= "10110111"; ---nm_4byte_addr_en_CMD;
               Tx_Data_d1(23 downto 0)  <= (others => '0');
           elsif(load_axi_data_to_spi_clk = '1')then
              Tx_Data_d1        <= SPI_cmd & Transmit_Addr_to_spi_clk(31 downto 8); --  & SPI_cmd;-- (31 downto 8);
              last_7_addr_bits  <= Transmit_Addr_to_spi_clk(7 downto 0);
           --   internal_count    <= (others => '0');
           elsif(wrap_around = '1') then
               Tx_Data_d1        <= SPI_cmd & spi_addr_wrap(31 downto 8);--spi_addr_i & SPI_cmd;
               last_7_addr_bits  <= spi_addr_wrap(7 downto 0);
           elsif(SPIXfer_done_int = '1') then -- and internal_count < "0101")then
               Tx_Data_d1 <= --"11111111" & -- Tx_Data_d1(7 downto 0) &
                             --                 --Tx_Data_d1(31 downto 8);
                             --                 Tx_Data_d1(31 downto 8);
                             Tx_Data_d1(23 downto 0) & -- Transmit_Addr_to_spi_clk(7 downto 0);
                                                       -- spi_addr_wrap(7 downto 0);
                                                       last_7_addr_bits(7 downto 0);
           --    internal_count <= internal_count + "0001";
           --elsif(SPIXfer_done_int = '1' and internal_count = "0101") then
           --    Tx_Data_d1 <= (others => '1');
           end if;
       end if;
  end process SHIFT_TX_REG_SPI_CLK_P;

Transmit_Data <= Tx_Data_d1(31 downto 24);
  -- STORE_INFO_P:process(EXT_SPI_CLK)is
  -- -----
  -- begin
  -- -----
  --      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
  --          if(Rst_to_spi = '1')then
  --              data_loaded       <= '0';
  --              cmd_sent          <= '0';
  --          elsif(load_axi_data_to_spi_clk = '1' or wrap_around = '1) then
  --               data_loaded       <= '1';
  --          elsif(data_loaded = '1' and SPIXfer_done_int = '1') then
  --               cmd_sent          <= '1';
  --          end if;
  --      end if;
  -- end process STORE_INFO_P;

end generate SHIFT_TX_REG_32_BIT_GEN;
-------------------------------------------------------
-- Transmit_Data <= Tx_Data_d1(31 downto 24);
-------------------------------------------------------

-------------------------------------------------------------------------------
STD_MODE_CONTROL_GEN: if C_SPI_MODE = 0 generate
-----
begin
-----
     WB_MEM_STD_MD_GEN: if C_SPI_MODE = 0 and C_SPI_MEMORY = 1 generate
     -----------
       signal cmd_addr_cntr  : std_logic_vector(2 downto 0);
       signal hw_wd_cntr     : std_logic_vector(1 downto 0);
       -----
       begin
       -----
       wb_hpm_done    <= '1';
       load_wr_en     <= '0';-- 4/12/2013 applicable only for Numonyx memories
       ---- Std mode command = 0x0B - Fast Read
       SPI_cmd <= "00001011"; -- FAST_READ
       --                 |<---- cmd error
       -- WB 000 000 0100 0<-cmd error
       -- NM 000 000 0100 0
       
       
       Data_Dir            <= '0';
       Data_Mode_1         <= '0';
       Data_Mode_0         <= '0';
       Data_Phase          <= '0';
       --------------------
       Quad_Phase          <= '0';-- permanent '0'
       --------------------
       Addr_Mode_1         <= '0';
       Addr_Mode_0         <= '0';
       Addr_Bit            <= '0';
       Addr_Phase          <= '1';
       --------------------
       CMD_Mode_1          <= '0';
       CMD_Mode_0          <= '0';
       ---------------------------
       -- CMD_ADDR_CNTR_P: in each SPI transaction, the first 5 transactions are of
       --                  CMD, A0, A1, A2 and dummy. Total 5 bytes need to be removed from the
       --                  calculation of total no. of pure data bytes.
       --                  the actual data from the SPI memory will be stored in the
       --                  receive FIFO only when the first 5 bytes are transferred.
       --                  below counter is for that purpose only. This is applicable only for Winbond memory.
       CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
       begin
            if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                if(Rst_to_spi = '1') or (wrap_around = '1') then
                    cmd_addr_cntr <= "000";
                    cmd_addr_sent <= '0';
                elsif(pr_state_idle = '1')then
                    cmd_addr_cntr <= "000";
                    cmd_addr_sent <= wrap_around;
                elsif(SPIXfer_done_int = '1')then
                    if(cmd_addr_cntr = "101")then
                        cmd_addr_sent <= '1';
                    else
                        cmd_addr_cntr <= cmd_addr_cntr + "001";
                        cmd_addr_sent <= '0';
                    end if;
                end if;
            end if;
       end process CMD_ADDR_CNTR_P;
       ----------------------------
       
       -- TWO_BIT_CNTR_P: This is specifically used for HW data storage
       TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(load_axi_data_to_spi_clk = '1') or (wrap_around = '1') then
               hw_wd_cntr <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
               hw_wd_cntr <= hw_wd_cntr + "01";
           end if;
       end if;
       end process TWO_BIT_CNTR_P;
       ----------------------------------------------
       
       STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
            if(load_axi_data_to_spi_clk = '1') then
                    Data_To_Rx_FIFO_int <= (others => '0');
            elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
                if(one_byte_xfer_to_spi_clk = '1') then
                    case spi_addr_i(1 downto 0) is
                        when "00" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                receive_Data_int;
                        when "01" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(7 downto 0);
                        when "10" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(15 downto 0);
                        when "11" =>
                         Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(23 downto 0);
                        when others => null;
                    end case;
                elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                    if(spi_addr_i(1) = '0') then
                       Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                       Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                    else
                       Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                       Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                    end if;
                elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                    if(hw_wd_cntr = "00") then -- fill in D0
                        Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                        Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                    elsif(hw_wd_cntr = "01")then -- fill in D1
                        Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                        Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                        Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                    elsif(hw_wd_cntr = "10")then -- fill in D2
                        Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                        Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                        Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                    else
                        Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                        Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                    end if;
                else   -- adjustment for complete word
                       --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                       Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                end if;
        end if;
       end if;
       end process STORE_RX_DATA_SPI_CLK_P;
       ----------------------------
       Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
       ---------------------------------------
       RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
       -----
       begin 
       -----
           if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
              if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                      receive_Data_int  <= (others => '0');
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1')then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-2) downto 0) &
                                                                  IO1_I ; --MISO_I;

              end if;
           end if;
       end process RECEIVE_DATA_STROBE_PROCESS;
       -----------------------------------------
     end generate WB_MEM_STD_MD_GEN;
     ------------------------
     --------------------------------------------------------------------------
     NM_MEM_STD_MD_GEN: if C_SPI_MODE = 0 and C_SPI_MEMORY = 2 generate
       signal cmd_addr_cntr  : std_logic_vector(2 downto 0);
       signal hw_wd_cntr     : std_logic_vector(1 downto 0);
       -----
       begin
       -----
       ---- Std mode command = 0x0B - Fast Read
       STD_SPI_CMD_NM_24_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
       begin
         SPI_cmd <= "00001011";-- FAST_READ - 0x0Bh
         --                 |<---- cmd error
         -- NM 000 000 0100 0
         four_byte_en_done <= '1';
         wb_hpm_done <= '1'; 
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK, wb_hpm_done, wr_en_done_reg ) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        --case wb_hpm_done is
                        --    -- when "00"|"01" => -- write enable is under process
                        --    when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                        --                   Data_Dir            <= '0';                  
                        --                   Data_Mode_1         <= '0';                  
                        --                   Data_Mode_0         <= '0';                  
                        --                   Data_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   Quad_Phase          <= '0';-- permanent '0'  
                        --                   --------------------                         
                        --                   Addr_Mode_1         <= '0';                  
                        --                   Addr_Mode_0         <= '0';                  
                        --                   Addr_Bit            <= '0';                  
                        --                   Addr_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   CMD_Mode_1          <= '0';                  
                        --                   CMD_Mode_0          <= '0';                  
                        --    -- when "01"   => -- Enable 4 byte addressing is under process
                        --    --                Data_Dir            <= '0';                  
                        --    --                Data_Mode_1         <= '0';                  
                        --    --                Data_Mode_0         <= '0';                  
                        --    --                Data_Phase          <= '0';                  
                        --    --                --------------------                         
                        --    --                Quad_Phase          <= '0';-- permanent '0'  
                        --    --                --------------------                         
                        --    --                Addr_Mode_1         <= '0';                  
                        --    --                Addr_Mode_0         <= '0';                  
                        --    --                Addr_Bit            <= '0';                  
                        --    --                Addr_Phase          <= '0';                  
                        --    --                --------------------                         
                        --    --                CMD_Mode_1          <= '0';                  
                        --    --                CMD_Mode_0          <= '0';                  
                        --    -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                        --    when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                        --    -- coverage off
                        --    when others => 
                        --                   Data_Dir            <= '0';                  
                        --                   Data_Mode_1         <= '0';                  
                        --                   Data_Mode_0         <= '0';                  
                        --                   Data_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   Quad_Phase          <= '0';-- permanent '0'  
                        --                   --------------------                         
                        --                   Addr_Mode_1         <= '0';                  
                        --                   Addr_Mode_0         <= '0';                  
                        --                   Addr_Bit            <= '0';                  
                        --                   Addr_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   CMD_Mode_1          <= '0';                  
                        --                   CMD_Mode_0          <= '0';                  
                        --    -- coverage on
                        --end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         ---------------------------------------------------------------------
      end generate STD_SPI_CMD_NM_24_BIT_GEN;
       
      STD_SPI_CMD_NM_32_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
      begin
        SPI_cmd <= "00001100";-- FAST_READ_4Byte - 0x0Ch
        --                 |<---- cmd error
        -- NM 000 000 0100 0
      --end generate STD_SPI_CMD_NM_32_BIT_GEN;

      --NM_EN_32_ADDR_MD_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
      --begin
      -----
         nm_wr_en_CMD         <= "00000110"; -- 0x06 h Write Enable
         nm_4byte_addr_en_CMD <= "10110111"; -- 0xB7 h Enable 4 Byte Addressing Mode
         ----------------------------------------------------
         NM_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
         -----
         begin
         -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                 if(Rst_to_spi = RESET_ACTIVE) then
                     nm_wr_en_cntrl_ps      <= NM_WR_EN_IDLE;
                     wr_en_under_process_d1 <= '0';
                     wr_en_done_reg         <= '0';
                 else
                     nm_wr_en_cntrl_ps      <= nm_wr_en_cntrl_ns;
                     wr_en_under_process_d1 <= wr_en_under_process;
                     wr_en_done_reg         <= wr_en_done;

                 end if;
             end if;
         end process NM_PS_TO_NS_PROCESS;
         ----------------------------------
         --
         NM_WR_EN_CNTRL_PROCESS: process(
                                        nm_wr_en_cntrl_ps     ,
                                        --SPIXfer_done_int_pulse,
                                        --SPIXfer_done_int      ,
                                        Rst_to_spi            ,
                                        SR_5_Tx_Empty         ,
                                        wr_en_done_reg
                                        ) is
         -----
         begin
         -----
              --load_wr_en_cmd <= '0';
              --load_wr_sr_cmd <= '0';
              --load_wr_sr_d0  <= '0';
              --load_wr_sr_d1  <= '0';
              load_wr_en    <= '0';
              wr_en_done    <= '0';
              wr_en_under_process <= '0';
              case nm_wr_en_cntrl_ps is
                  when NM_WR_EN_IDLE => --load_wr_en_cmd <= '1';
                                      load_wr_en          <= '1';
                                      wr_en_under_process <= '1';
                                      nm_wr_en_cntrl_ns   <= NM_WR_EN;
                  when NM_WR_EN      => if (SR_5_Tx_Empty = '1')then
                                            --wr_en_done <= '1';
                                            nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                        else
                                            --wr_en_under_process <= '1';
                                            nm_wr_en_cntrl_ns <= NM_WR_EN;
                                        end if;
                                        wr_en_done          <= SR_5_Tx_Empty;
                                        wr_en_under_process <= not SR_5_Tx_Empty;

                  when NM_WR_EN_DONE => if (Rst_to_spi = '1') then
                                            nm_wr_en_cntrl_ns <= NM_WR_EN_IDLE;
                                        else
                                            nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                        end if;
                                        wr_en_done <= wr_en_done_reg;
              end case;
         end process NM_WR_EN_CNTRL_PROCESS;

           ----------------------------------------------------
           NM_4_BYTE_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
           -----
           begin
           -----
               if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                   if(Rst_to_spi = RESET_ACTIVE) then
                       nm_sm_4_byte_addr_ps           <= NM_32_BIT_IDLE;
                       --four_byte_addr_under_process_d1 <= '0';
                       hpm_under_process_d1   <= '0';
                       wr_en_done_d1          <= '0';
                       wr_en_done_d2          <= '0';
                       wb_hpm_done_reg        <= '0';
                   else
                       nm_sm_4_byte_addr_ps   <= nm_sm_4_byte_addr_ns;
                       hpm_under_process_d1   <= hpm_under_process;
                       --four_byte_en_done_reg           <= four_byte_en_done;   
                       wr_en_done_d1          <= wr_en_done_reg; -- wr_en_done;
                       wr_en_done_d2          <= wr_en_done_d1;
                       wb_hpm_done_reg        <= wb_hpm_done;
                   end if;
               end if;
           end process NM_4_BYTE_PS_TO_NS_PROCESS;
           ----------------------------------
           --
           NM_4_BYTE_ADDR_EN_PROCESS: process(
                                              nm_sm_4_byte_addr_ps  ,
                                              Rst_to_spi            ,
                                              SR_5_Tx_Empty         ,
                                              wr_en_done_d2         ,
                                              wb_hpm_done_reg
                                             ) is
           -----
           begin
           -----
                -- load_4_byte_addr_en     <= '0';
                load_wr_hpm <= '0';
                wb_hpm_done <= '0';
                hpm_under_process <= '0';
                four_byte_en_done          <= '0';
                four_byte_en_under_process <= '0';
                case nm_sm_4_byte_addr_ps is
                    when NM_32_BIT_IDLE     => if (wr_en_done_d2 = '1') then
                                                   --load_wr_hpm <= '1';
                                                   --hpm_under_process <= '1';
                                                   nm_sm_4_byte_addr_ns      <= NM_32_BIT_EN;
                                               else
                                                   nm_sm_4_byte_addr_ns      <= NM_32_BIT_IDLE;
                                               end if;
                                               load_wr_hpm       <= wr_en_done_d2; 
                                               hpm_under_process <= wr_en_done_d2;
           
                    when NM_32_BIT_EN      => if (SR_5_Tx_Empty = '1') then
                                                  -- wb_hpm_done        <= '1';
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                              else
                                                  -- hpm_under_process  <= '1';
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_EN;
                                              end if;
                                              wb_hpm_done        <= SR_5_Tx_Empty;
                                              hpm_under_process  <= not(SR_5_Tx_Empty);
                    when NM_32_BIT_EN_DONE => if(Rst_to_spi = '1')then
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_IDLE;
                                              else
                                                --  if (SR_5_Tx_Empty = '1')then
                                                --      --four_byte_en_done          <= '1';
                                                --      wb_hpm_done <= '1';
                                                --  else
                                                --      -- four_byte_en_under_process <= '1';
                                                --      hpm_under_process <= '1';
                                                --  end if;
                                                --  four_byte_en_done     <= four_byte_en_done_reg;     
                                                  -- wb_hpm_done <= '1';
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                              end if;
                                              wb_hpm_done <= wb_hpm_done_reg;
           
                end case;
           end process NM_4_BYTE_ADDR_EN_PROCESS;
           --------------------------------------
             DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK, wb_hpm_done, wr_en_done_reg) is -- wb_hpm_done, wr_en_done_reg) is
             variable temp: std_logic_vector(1 downto 0);
             begin
                   temp := wb_hpm_done & wr_en_done_reg;
                   if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                           case wb_hpm_done is
                               -- when "00"|"01" => -- write enable is under process
                    when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                              Data_Dir            <= '0';                  
                                              Data_Mode_1         <= '0';                  
                                              Data_Mode_0         <= '0';                  
                                              Data_Phase          <= '0';                  
                                              --------------------                         
                                              Quad_Phase          <= '0';-- permanent '0'  
                                              --------------------                         
                                              Addr_Mode_1         <= '0';                  
                                              Addr_Mode_0         <= '0';                  
                                              Addr_Bit            <= '0';                  
                                              Addr_Phase          <= '0';                  
                                              --------------------                         
                                              CMD_Mode_1          <= '0';                  
                                              CMD_Mode_0          <= '0';                  
                               -- when "01"   => -- Enable 4 byte addressing is under process
                               --                Data_Dir            <= '0';                  
                               --                Data_Mode_1         <= '0';                  
                               --                Data_Mode_0         <= '0';                  
                               --                Data_Phase          <= '0';                  
                               --                --------------------                         
                               --                Quad_Phase          <= '0';-- permanent '0'  
                               --                --------------------                         
                               --                Addr_Mode_1         <= '0';                  
                               --                Addr_Mode_0         <= '0';                  
                               --                Addr_Bit            <= '0';                  
                               --                Addr_Phase          <= '0';                  
                               --                --------------------                         
                               --                CMD_Mode_1          <= '0';                  
                               --                CMD_Mode_0          <= '0';                  
                               -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                    when '1'       => -- write enable and enable 4 byte addressing is also done
                                              Data_Dir            <= '0';                  
                                              Data_Mode_1         <= '0';                  
                                              Data_Mode_0         <= '0';                  
                                              Data_Phase          <= '1';                  
                                              --------------------                         
                                              Quad_Phase          <= '0';-- permanent '0'  
                                              --------------------                         
                                              Addr_Mode_1         <= '0';                  
                                              Addr_Mode_0         <= '0';                  
                                              Addr_Bit            <= '1';                  
                                              Addr_Phase          <= '1';                  
                                              --------------------                         
                                              CMD_Mode_1          <= '0';                  
                                              CMD_Mode_0          <= '0';                  
                               -- coverage off
                    when others => 
                                              Data_Dir            <= '0';                  
                                              Data_Mode_1         <= '0';                  
                                              Data_Mode_0         <= '0';                  
                                              Data_Phase          <= '0';                  
                                              --------------------                         
                                              Quad_Phase          <= '0';-- permanent '0'  
                                              --------------------                         
                                              Addr_Mode_1         <= '0';                  
                                              Addr_Mode_0         <= '0';                  
                                              Addr_Bit            <= '0';                  
                                              Addr_Phase          <= '0';                  
                                              --------------------                         
                                              CMD_Mode_1          <= '0';                  
                                              CMD_Mode_0          <= '0';                  
                               -- coverage on
                end case;
                   end if;
             end process DRIVE_CONTROL_SIG_P;
             ---------------------------------------------------------------------
      --end generate NM_EN_32_ADDR_MD_GEN;
       end generate STD_SPI_CMD_NM_32_BIT_GEN;
       ---------------------------------------
       -- wb_hpm_done    <= four_byte_en_done;
       
       --Data_Dir            <= '0';
       --Data_Mode_1         <= '0';
       --Data_Mode_0         <= '0';
       --Data_Phase          <= '0';
       ----------------------
       --Quad_Phase          <= '0';-- permanent '0'
       ----------------------
       --Addr_Mode_1         <= '0';
       --Addr_Mode_0         <= '0';
       --Addr_Bit            <= '0';
       --Addr_Phase          <= '1';
       ----------------------
       --CMD_Mode_1          <= '0';
       --CMD_Mode_0          <= '0';
       ---------------------------

       -----
       RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
       -----
       begin
       -----
           if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
              if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                      receive_Data_int  <= (others => '0');
              -- elsif(SPIXfer_done_int = '1') and (cmd_addr_cntr = "110")then
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1')then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-2) downto 0) &
                                                                  IO1_I ; --MISO_I;
              end if;
           end if;
       end process RECEIVE_DATA_STROBE_PROCESS;

       CMD_ADDR_24_BIT_CNTR_GEN : if  C_SPI_MEM_ADDR_BITS = 24 generate
       begin      
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the first 5 transactions are of
         --                  CMD, A0, A1, A2 and dummy. Total 5 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 5 bytes are transferred.
         --                  below counter is for that purpose only. Tihs is for 24 bit addressing mode only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         begin
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1') or (wrap_around = '1') then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1') then --  and store_date_in_drr_fifo_d3 = '1')then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= wrap_around;
                  elsif(SPIXfer_done_int = '1')then
                      if(cmd_addr_cntr = "101")then
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
         ----------------------------
       end generate CMD_ADDR_24_BIT_CNTR_GEN;
       --------------------------------------
       
       CMD_ADDR_32_BIT_CNTR_GEN : if C_SPI_MEM_ADDR_BITS = 32 generate
       begin      
         -- * -- -----
         -- * -- RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
         -- * -- -----
         -- * -- begin
         -- * -- -----
         -- * --     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
         -- * --        if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
         -- * --                receive_Data_int  <= (others => '0');
         -- * --        elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1') then  -- and (cmd_addr_cntr = "111")then
         -- * --                receive_Data_int  <= rx_shft_reg_mode_0011;
         -- * --        end if;
         -- * --     end if;
         -- * -- end process RECEIVE_DATA_STROBE_PROCESS;
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the first 6 transactions are of
         --                  CMD, A0, A1, A2, A3 and dummy. Total 6 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 6 bytes are transferred.
         --                  below counter is for that purpose only. This is for 32 bit addressing mode only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         begin
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1') or (wrap_around = '1') then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1' and store_date_in_drr_fifo_d3 = '1')then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= wrap_around;
                  elsif(SPIXfer_done_int = '1' and wb_hpm_done = '1')then
                      if(cmd_addr_cntr = "110")then
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
         ----------------------------
       end generate CMD_ADDR_32_BIT_CNTR_GEN;
       --------------------------------------
       
       -- TWO_BIT_CNTR_P: This is specifically used for HW data storage
       TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(load_axi_data_to_spi_clk = '1') or (wrap_around = '1') then
               hw_wd_cntr <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
               hw_wd_cntr <= hw_wd_cntr + "01";
           end if;
       end if;
       end process TWO_BIT_CNTR_P;
       ----------------------------------------------
       
       STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
            if(load_axi_data_to_spi_clk = '1') then
                    Data_To_Rx_FIFO_int <= (others => '0');
            elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
                if(one_byte_xfer_to_spi_clk = '1') then
                    case spi_addr_i(1 downto 0) is
                        when "00" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                receive_Data_int;
                        when "01" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(7 downto 0);
                        when "10" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(15 downto 0);
                        when "11" =>
                         Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(23 downto 0);
                        when others => null;
                    end case;
                elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                    if(spi_addr_i(1) = '0') then
                       Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                       Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                    else
                       Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                       Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                    end if;
                elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                    if(hw_wd_cntr = "00") then -- fill in D0
                        Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                        Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                    elsif(hw_wd_cntr = "01")then -- fill in D1
                        Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                        Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                        Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                    elsif(hw_wd_cntr = "10")then -- fill in D2
                        Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                        Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                        Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                    else
                        Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                        Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                    end if;
                else   -- adjustment for complete word
                       --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                       Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                end if;
        end if;
       end if;
       end process STORE_RX_DATA_SPI_CLK_P;
       ----------------------------
       Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
       ---------------------------------------
     end generate NM_MEM_STD_MD_GEN;
     ------------------------
	 
	     SP_MEM_STD_MD_GEN: if C_SPI_MODE = 0 and C_SPI_MEMORY = 3 generate
       signal cmd_addr_cntr  : std_logic_vector(2 downto 0);
       signal hw_wd_cntr     : std_logic_vector(1 downto 0);
       -----
       begin
       -----
       ---- Std mode command = 0x0B - Fast Read
       STD_SPI_CMD_SP_24_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
       begin
         SPI_cmd <= "00001011";-- FAST_READ - 0x0Bh
         --                 |<---- cmd error
         -- NM 000 000 0100 0
         four_byte_en_done <= '1';
         wb_hpm_done <= '1'; 
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        --case wb_hpm_done is
                        --    -- when "00"|"01" => -- write enable is under process
                        --    when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                        --                   Data_Dir            <= '0';                  
                        --                   Data_Mode_1         <= '0';                  
                        --                   Data_Mode_0         <= '0';                  
                        --                   Data_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   Quad_Phase          <= '0';-- permanent '0'  
                        --                   --------------------                         
                        --                   Addr_Mode_1         <= '0';                  
                        --                   Addr_Mode_0         <= '0';                  
                        --                   Addr_Bit            <= '0';                  
                        --                   Addr_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   CMD_Mode_1          <= '0';                  
                        --                   CMD_Mode_0          <= '0';                  
                        --    -- when "01"   => -- Enable 4 byte addressing is under process
                        --    --                Data_Dir            <= '0';                  
                        --    --                Data_Mode_1         <= '0';                  
                        --    --                Data_Mode_0         <= '0';                  
                        --    --                Data_Phase          <= '0';                  
                        --    --                --------------------                         
                        --    --                Quad_Phase          <= '0';-- permanent '0'  
                        --    --                --------------------                         
                        --    --                Addr_Mode_1         <= '0';                  
                        --    --                Addr_Mode_0         <= '0';                  
                        --    --                Addr_Bit            <= '0';                  
                        --    --                Addr_Phase          <= '0';                  
                        --    --                --------------------                         
                        --    --                CMD_Mode_1          <= '0';                  
                        --    --                CMD_Mode_0          <= '0';                  
                        --    -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                        --    when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                        --    -- coverage off
                        --    when others => 
                        --                   Data_Dir            <= '0';                  
                        --                   Data_Mode_1         <= '0';                  
                        --                   Data_Mode_0         <= '0';                  
                        --                   Data_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   Quad_Phase          <= '0';-- permanent '0'  
                        --                   --------------------                         
                        --                   Addr_Mode_1         <= '0';                  
                        --                   Addr_Mode_0         <= '0';                  
                        --                   Addr_Bit            <= '0';                  
                        --                   Addr_Phase          <= '0';                  
                        --                   --------------------                         
                        --                   CMD_Mode_1          <= '0';                  
                        --                   CMD_Mode_0          <= '0';                  
                        --    -- coverage on
                        --end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         ---------------------------------------------------------------------
      end generate STD_SPI_CMD_SP_24_BIT_GEN;
       
      STD_SPI_CMD_SP_32_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
      begin
        SPI_cmd <= "00001100";-- FAST_READ_4Byte - 0x0Ch
        --                 |<---- cmd error
        -- NM 000 000 0100 0
      --end generate STD_SPI_CMD_NM_32_BIT_GEN;

      --NM_EN_32_ADDR_MD_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
      --begin
      -----
         nm_wr_en_CMD         <= "00000110"; -- 0x06 h Write Enable
         nm_4byte_addr_en_CMD <= "10110111"; -- 0xB7 h Enable 4 Byte Addressing Mode
         ----------------------------------------------------
         SP_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
         -----
         begin
         -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                 if(Rst_to_spi = RESET_ACTIVE) then
                     nm_wr_en_cntrl_ps      <= NM_WR_EN_IDLE;
                     wr_en_under_process_d1 <= '0';
                     wr_en_done_reg         <= '0';
                 else
                     nm_wr_en_cntrl_ps      <= nm_wr_en_cntrl_ns;
                     wr_en_under_process_d1 <= wr_en_under_process;
                     wr_en_done_reg         <= wr_en_done;

                 end if;
             end if;
         end process SP_PS_TO_NS_PROCESS;
         ----------------------------------
         --
         SP_WR_EN_CNTRL_PROCESS: process(
                                        nm_wr_en_cntrl_ps     ,
                                        --SPIXfer_done_int_pulse,
                                        --SPIXfer_done_int      ,
                                        Rst_to_spi            ,
                                        SR_5_Tx_Empty         ,
                                        wr_en_done_reg
                                        ) is
         -----
         begin
         -----
              --load_wr_en_cmd <= '0';
              --load_wr_sr_cmd <= '0';
              --load_wr_sr_d0  <= '0';
              --load_wr_sr_d1  <= '0';
              load_wr_en    <= '0';
              wr_en_done    <= '0';
              wr_en_under_process <= '0';
              case nm_wr_en_cntrl_ps is
                  when NM_WR_EN_IDLE => --load_wr_en_cmd <= '1';
                                      load_wr_en          <= '1';
                                      wr_en_under_process <= '1';
                                      nm_wr_en_cntrl_ns   <= NM_WR_EN;
                  when NM_WR_EN      => if (SR_5_Tx_Empty = '1')then
                                            --wr_en_done <= '1';
                                            nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                        else
                                            --wr_en_under_process <= '1';
                                            nm_wr_en_cntrl_ns <= NM_WR_EN;
                                        end if;
                                        wr_en_done          <= SR_5_Tx_Empty;
                                        wr_en_under_process <= not SR_5_Tx_Empty;

                  when NM_WR_EN_DONE => if (Rst_to_spi = '1') then
                                            nm_wr_en_cntrl_ns <= NM_WR_EN_IDLE;
                                        else
                                            nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                        end if;
                                        wr_en_done <= wr_en_done_reg;
              end case;
         end process SP_WR_EN_CNTRL_PROCESS;

           ----------------------------------------------------
           SP_4_BYTE_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
           -----
           begin
           -----
               if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                   if(Rst_to_spi = RESET_ACTIVE) then
                       nm_sm_4_byte_addr_ps           <= NM_32_BIT_IDLE;
                       --four_byte_addr_under_process_d1 <= '0';
                       hpm_under_process_d1   <= '0';
                       wr_en_done_d1          <= '0';
                       wr_en_done_d2          <= '0';
                       wb_hpm_done_reg        <= '0';
                   else
                       nm_sm_4_byte_addr_ps   <= nm_sm_4_byte_addr_ns;
                       hpm_under_process_d1   <= hpm_under_process;
                       --four_byte_en_done_reg           <= four_byte_en_done;   
                       wr_en_done_d1          <= wr_en_done_reg; -- wr_en_done;
                       wr_en_done_d2          <= wr_en_done_d1;
                       wb_hpm_done_reg        <= wb_hpm_done;
                   end if;
               end if;
           end process SP_4_BYTE_PS_TO_NS_PROCESS;
           ----------------------------------
           --
           SP_4_BYTE_ADDR_EN_PROCESS: process(
                                              nm_sm_4_byte_addr_ps  ,
                                              Rst_to_spi            ,
                                              SR_5_Tx_Empty         ,
                                              wr_en_done_d2         ,
                                              wb_hpm_done_reg
                                             ) is
           -----
           begin
           -----
                -- load_4_byte_addr_en     <= '0';
                load_wr_hpm <= '0';
                wb_hpm_done <= '0';
                hpm_under_process <= '0';
                four_byte_en_done          <= '0';
                four_byte_en_under_process <= '0';
                case nm_sm_4_byte_addr_ps is
                    when NM_32_BIT_IDLE     => if (wr_en_done_d2 = '1') then
                                                   --load_wr_hpm <= '1';
                                                   --hpm_under_process <= '1';
                                                   nm_sm_4_byte_addr_ns      <= NM_32_BIT_EN;
                                               else
                                                   nm_sm_4_byte_addr_ns      <= NM_32_BIT_IDLE;
                                               end if;
                                               load_wr_hpm       <= wr_en_done_d2; 
                                               hpm_under_process <= wr_en_done_d2;
           
                    when NM_32_BIT_EN      => if (SR_5_Tx_Empty = '1') then
                                                  -- wb_hpm_done        <= '1';
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                              else
                                                  -- hpm_under_process  <= '1';
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_EN;
                                              end if;
                                              wb_hpm_done        <= SR_5_Tx_Empty;
                                              hpm_under_process  <= not(SR_5_Tx_Empty);
                    when NM_32_BIT_EN_DONE => if(Rst_to_spi = '1')then
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_IDLE;
                                              else
                                                --  if (SR_5_Tx_Empty = '1')then
                                                --      --four_byte_en_done          <= '1';
                                                --      wb_hpm_done <= '1';
                                                --  else
                                                --      -- four_byte_en_under_process <= '1';
                                                --      hpm_under_process <= '1';
                                                --  end if;
                                                --  four_byte_en_done     <= four_byte_en_done_reg;     
                                                  -- wb_hpm_done <= '1';
                                                  nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                              end if;
                                              wb_hpm_done <= wb_hpm_done_reg;
           
                end case;
           end process SP_4_BYTE_ADDR_EN_PROCESS;
           --------------------------------------
             DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK) is -- wb_hpm_done, wr_en_done_reg) is
             variable temp: std_logic_vector(1 downto 0);
             begin
                   temp := wb_hpm_done & wr_en_done_reg;
                   if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                           case wb_hpm_done is
                               -- when "00"|"01" => -- write enable is under process
                    when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                              Data_Dir            <= '0';                  
                                              Data_Mode_1         <= '0';                  
                                              Data_Mode_0         <= '0';                  
                                              Data_Phase          <= '0';                  
                                              --------------------                         
                                              Quad_Phase          <= '0';-- permanent '0'  
                                              --------------------                         
                                              Addr_Mode_1         <= '0';                  
                                              Addr_Mode_0         <= '0';                  
                                              Addr_Bit            <= '0';                  
                                              Addr_Phase          <= '0';                  
                                              --------------------                         
                                              CMD_Mode_1          <= '0';                  
                                              CMD_Mode_0          <= '0';                  
                               -- when "01"   => -- Enable 4 byte addressing is under process
                               --                Data_Dir            <= '0';                  
                               --                Data_Mode_1         <= '0';                  
                               --                Data_Mode_0         <= '0';                  
                               --                Data_Phase          <= '0';                  
                               --                --------------------                         
                               --                Quad_Phase          <= '0';-- permanent '0'  
                               --                --------------------                         
                               --                Addr_Mode_1         <= '0';                  
                               --                Addr_Mode_0         <= '0';                  
                               --                Addr_Bit            <= '0';                  
                               --                Addr_Phase          <= '0';                  
                               --                --------------------                         
                               --                CMD_Mode_1          <= '0';                  
                               --                CMD_Mode_0          <= '0';                  
                               -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                    when '1'       => -- write enable and enable 4 byte addressing is also done
                                              Data_Dir            <= '0';                  
                                              Data_Mode_1         <= '0';                  
                                              Data_Mode_0         <= '0';                  
                                              Data_Phase          <= '1';                  
                                              --------------------                         
                                              Quad_Phase          <= '0';-- permanent '0'  
                                              --------------------                         
                                              Addr_Mode_1         <= '0';                  
                                              Addr_Mode_0         <= '0';                  
                                              Addr_Bit            <= '1';                  
                                              Addr_Phase          <= '1';                  
                                              --------------------                         
                                              CMD_Mode_1          <= '0';                  
                                              CMD_Mode_0          <= '0';                  
                               -- coverage off
                    when others => 
                                              Data_Dir            <= '0';                  
                                              Data_Mode_1         <= '0';                  
                                              Data_Mode_0         <= '0';                  
                                              Data_Phase          <= '0';                  
                                              --------------------                         
                                              Quad_Phase          <= '0';-- permanent '0'  
                                              --------------------                         
                                              Addr_Mode_1         <= '0';                  
                                              Addr_Mode_0         <= '0';                  
                                              Addr_Bit            <= '0';                  
                                              Addr_Phase          <= '0';                  
                                              --------------------                         
                                              CMD_Mode_1          <= '0';                  
                                              CMD_Mode_0          <= '0';                  
                               -- coverage on
                end case;
                   end if;
             end process DRIVE_CONTROL_SIG_P;
             ---------------------------------------------------------------------
      --end generate NM_EN_32_ADDR_MD_GEN;
       end generate STD_SPI_CMD_SP_32_BIT_GEN;
       ---------------------------------------
       -- wb_hpm_done    <= four_byte_en_done;
       
       --Data_Dir            <= '0';
       --Data_Mode_1         <= '0';
       --Data_Mode_0         <= '0';
       --Data_Phase          <= '0';
       ----------------------
       --Quad_Phase          <= '0';-- permanent '0'
       ----------------------
       --Addr_Mode_1         <= '0';
       --Addr_Mode_0         <= '0';
       --Addr_Bit            <= '0';
       --Addr_Phase          <= '1';
       ----------------------
       --CMD_Mode_1          <= '0';
       --CMD_Mode_0          <= '0';
       ---------------------------

       -----
       RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
       -----
       begin
       -----
           if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
              if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                      receive_Data_int  <= (others => '0');
              -- elsif(SPIXfer_done_int = '1') and (cmd_addr_cntr = "110")then
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1')then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-2) downto 0) &
                                                                  IO1_I ; --MISO_I;
              end if;
           end if;
       end process RECEIVE_DATA_STROBE_PROCESS;

       CMD_ADDR_24_BIT_CNTR_GEN : if  C_SPI_MEM_ADDR_BITS = 24 generate
       begin      
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the first 5 transactions are of
         --                  CMD, A0, A1, A2 and dummy. Total 5 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 5 bytes are transferred.
         --                  below counter is for that purpose only. Tihs is for 24 bit addressing mode only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         begin
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1') or (wrap_around = '1') then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1') then --  and store_date_in_drr_fifo_d3 = '1')then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= wrap_around;
                  elsif(SPIXfer_done_int = '1')then
                      if(cmd_addr_cntr = "101")then
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
         ----------------------------
       end generate CMD_ADDR_24_BIT_CNTR_GEN;
       --------------------------------------
       
       CMD_ADDR_32_BIT_CNTR_GEN : if C_SPI_MEM_ADDR_BITS = 32 generate
       begin      
         -- * -- -----
         -- * -- RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
         -- * -- -----
         -- * -- begin
         -- * -- -----
         -- * --     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
         -- * --        if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
         -- * --                receive_Data_int  <= (others => '0');
         -- * --        elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1') then  -- and (cmd_addr_cntr = "111")then
         -- * --                receive_Data_int  <= rx_shft_reg_mode_0011;
         -- * --        end if;
         -- * --     end if;
         -- * -- end process RECEIVE_DATA_STROBE_PROCESS;
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the first 6 transactions are of
         --                  CMD, A0, A1, A2, A3 and dummy. Total 6 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 6 bytes are transferred.
         --                  below counter is for that purpose only. This is for 32 bit addressing mode only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         begin
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1') or (wrap_around = '1') then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1' and store_date_in_drr_fifo_d3 = '1')then
                      cmd_addr_cntr <= "000";
                      cmd_addr_sent <= wrap_around;
                  elsif(SPIXfer_done_int = '1' and wb_hpm_done = '1')then
                      if(cmd_addr_cntr = "110")then
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
         ----------------------------
       end generate CMD_ADDR_32_BIT_CNTR_GEN;
       --------------------------------------
       
       -- TWO_BIT_CNTR_P: This is specifically used for HW data storage
       TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(load_axi_data_to_spi_clk = '1') or (wrap_around = '1') then
               hw_wd_cntr <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
               hw_wd_cntr <= hw_wd_cntr + "01";
           end if;
       end if;
       end process TWO_BIT_CNTR_P;
       ----------------------------------------------
       
       STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
            if(load_axi_data_to_spi_clk = '1') then
                    Data_To_Rx_FIFO_int <= (others => '0');
            elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
                if(one_byte_xfer_to_spi_clk = '1') then
                    case spi_addr_i(1 downto 0) is
                        when "00" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                receive_Data_int;
                        when "01" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(7 downto 0);
                        when "10" =>
                         Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(15 downto 0);
                        when "11" =>
                         Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                Data_To_Rx_FIFO_int(23 downto 0);
                        when others => null;
                    end case;
                elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                    if(spi_addr_i(1) = '0') then
                       Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                       Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                    else
                       Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                       Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                    end if;
                elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                    if(hw_wd_cntr = "00") then -- fill in D0
                        Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                        Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                    elsif(hw_wd_cntr = "01")then -- fill in D1
                        Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                        Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                        Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                    elsif(hw_wd_cntr = "10")then -- fill in D2
                        Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                        Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                        Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                    else
                        Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                        Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                    end if;
                else   -- adjustment for complete word
                       --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                       Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                end if;
        end if;
       end if;
       end process STORE_RX_DATA_SPI_CLK_P;
       ----------------------------
       Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
       ---------------------------------------
     end generate SP_MEM_STD_MD_GEN;
 
end generate STD_MODE_CONTROL_GEN;

-------------------------------------------------------------------------------
DUAL_MODE_CONTROL_GEN: if C_SPI_MODE = 1 generate
signal cmd_addr_cntr : std_logic_vector(2 downto 0);-----
signal hw_wd_cntr    : std_logic_vector(1 downto 0);
begin
-----
        WB_MEM_DUAL_MD_GEN: if C_SPI_MEMORY = 1 generate
        -----
        begin
        -----
          wb_wr_hpm_CMD <= "10100011"; -- 0xA3 h HPM mode
          --
          ----------------------------------------------------
          WB_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
          -----
          begin
          -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                  if(Rst_to_spi = RESET_ACTIVE) then
                      wb_cntrl_ps        <= WB_IDLE;
                      hpm_under_process_d1 <= '0';
                  else
                      wb_cntrl_ps        <= wb_cntrl_ns;
                      hpm_under_process_d1 <= hpm_under_process;
                  end if;
              end if;
          end process WB_PS_TO_NS_PROCESS;
          ----------------------------------
          --
          WB_DUAL_CNTRL_PROCESS: process(
                                         wb_cntrl_ps           ,
                                         SPIXfer_done_int_pulse,
                                         SPIXfer_done_int      ,
                                         Rst_to_spi            ,
                                         SR_5_Tx_Empty
                                         ) is
          -----
          begin
          -----
               load_wr_en_cmd <= '0';
               load_wr_sr_cmd <= '0';
               load_wr_sr_d0  <= '0';
               load_wr_sr_d1  <= '0';
               load_wr_hpm    <= '0';
               wb_hpm_done    <= '0';
               hpm_under_process <= '0';
               case wb_cntrl_ps is
                   when WB_IDLE     => --load_wr_en_cmd <= '1';
                                        load_wr_hpm <= '1';
                                        hpm_under_process <= '1';
                                       wb_cntrl_ns <= WB_WR_HPM;
                   when WB_WR_HPM   => if (SR_5_Tx_Empty = '1')then
                                           wb_hpm_done <= '1';
                                           wb_cntrl_ns <= WB_DONE;
                                       else
                                           hpm_under_process <= '1';
                                           wb_cntrl_ns <= WB_WR_HPM;
                                       end if;
                   when WB_DONE     => if (Rst_to_spi = '1') then
                                           wb_cntrl_ns <= WB_IDLE;
                                       else
                                           wb_hpm_done <= '1';
                                           wb_cntrl_ns <= WB_DONE;
                                       end if;
               end case;
          end process WB_DUAL_CNTRL_PROCESS;
          
          ---- Dual mode command = 0x3B - DOFR
          --SPI_cmd <= "00111011";
          SPI_cmd <= "10111011"; -- 0xBB - DIOFR
          -- WB 0011 000 100 0
          -- NM 0011 000 100 0<-cmd error
          -- NM 0011 010 100 0<-cmd error -- For 0xbbh DIOFR
          Data_Dir            <= '0';
          Data_Mode_1         <= '0';
          Data_Mode_0         <= '1';
          Data_Phase          <= '1';
          --------------------
          Quad_Phase          <= '0';-- permanent '0'
          --------------------
          Addr_Mode_1         <= '0';
          Addr_Mode_0         <= '1'; -- <- '0' for DOFR, '1' for DIOFR
          Addr_Bit            <= '0';
          Addr_Phase          <= '1';
          --------------------
          CMD_Mode_1          <= '0';
          CMD_Mode_0          <= '0';
          
          ---------------------------------------------------------------------
          --RECEIVE_DATA_WB_GEN: if C_SPI_MEMORY = 1 and C_SPI_MODE /=0 generate
          --begin
          -----
          RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
          -----
          begin
          -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                 if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                         receive_Data_int  <= (others => '0');
                elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
                 elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1')then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-3) downto 0) &
                                                                  IO1_I &  -- MISO_I - MSB first
                                                                  IO0_I ;  -- MOSI_I
                 end if;
              end if;
          end process RECEIVE_DATA_STROBE_PROCESS;
          --end generate RECEIVE_DATA_WB_GEN;
          ---------------------------------------------------------------------
          -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 4 transactions are of
          --                  CMD, A0, A1, A2. Total 4 bytes need to be removed from the
          --                  calculation of total no. of pure data bytes.
          --                  the actual data from the SPI memory will be stored in the
          --                  receive FIFO only when the first 4 bytes are transferred.
          --                  below counter is for that purpose only.
          CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
          -----
          begin
          -----
               if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                   if(Rst_to_spi = '1') or (store_last_b4_wrap = '1') then
                       cmd_addr_cntr <= "000";--(others => '1');
                       cmd_addr_sent <= '0';
                   elsif(pr_state_idle = '1')then
                       cmd_addr_cntr <= "000";
                       cmd_addr_sent <= store_last_b4_wrap;
                   elsif(SPIXfer_done_int_pulse_d2 = '1')then
                       if(cmd_addr_cntr = "100")then
                           cmd_addr_sent <= '1';
                       else
                           cmd_addr_cntr <= cmd_addr_cntr + "001";
                           cmd_addr_sent <= '0';
                       end if;
                   end if;
               end if;
          end process CMD_ADDR_CNTR_P;
          ----------------------------
          TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') or (store_last_b4_wrap = '1') then
                  hw_wd_cntr <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
                  hw_wd_cntr <= hw_wd_cntr + "01";
              end if;
          end if;
          end process TWO_BIT_CNTR_P;
          ----------------------------------------------
          STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') then
                  Data_To_Rx_FIFO_int <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
                  if(one_byte_xfer_to_spi_clk = '1') then
                     case spi_addr_i(1 downto 0) is
                          when "00" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                             receive_Data_int;
                          when "01" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(7 downto 0);
                          when "10" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(15 downto 0);
                          when "11" =>
                                      Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(23 downto 0);
                          when others => null;
                     end case;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                     if(spi_addr_i(1) = '0') then
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                     else
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                     end if;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                     if(hw_wd_cntr = "00") then -- fill in D0
                         Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                         Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                     elsif(hw_wd_cntr = "01")then -- fill in D1
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                         Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                     elsif(hw_wd_cntr = "10")then -- fill in D2
                         Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                         Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                     else
                         Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                         Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                     end if;
                  else   -- adjustment for complete word
                     --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                     Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                  end if;
              end if;
          end if;
          end process STORE_RX_DATA_SPI_CLK_P;
          ----------------------------
          Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
          ---------------------------------------
        end generate WB_MEM_DUAL_MD_GEN;
        ---------------=============-------------------------------------------
        
        NM_MEM_DUAL_MD_GEN: if C_SPI_MEMORY = 2 generate
        -----
        begin
        -----
          --wb_hpm_done    <= '1';
          ---- Dual mode command = 0x3B - DOFR
          --SPI_cmd <= "00111011";
          --------------------------------------------------------
          DUAL_SPI_CMD_NM_24_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
          -----
          begin
          -----
              ---------------------------
              SPI_cmd <= "10111011"; -- 0xBB - DIOFR
              wb_hpm_done <= '1';
              --------------------------- 
              Data_Dir            <= '0';-- for BB       
              Data_Mode_1         <= '0';                       
              Data_Mode_0         <= '1';                       
              Data_Phase          <= '1';                       
              --------------------                      
              Quad_Phase          <= '0';-- permanent '0'       
              --------------------                      
              Addr_Mode_1         <= '0';                       
              Addr_Mode_0         <= '1';                       
              Addr_Bit            <= '0';                       
              Addr_Phase          <= '1';                       
              --------------------                      
              CMD_Mode_1          <= '0';                       
              CMD_Mode_0          <= '0';                        
              ---------------------------
          end generate DUAL_SPI_CMD_NM_24_GEN;
          ------------------------------------

          DUAL_SPI_CMD_NM_32_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
          -----
          begin
          -----
              
              SPI_cmd <= "10111100"; -- 0xBCh - DIOFR_4Byte

          end generate DUAL_SPI_CMD_NM_32_GEN;
          ------------------------------------
          
          NM_EN_32_ADDR_MD_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
          begin
          -----
             nm_wr_en_CMD         <= "00000110"; -- 0x06 h Write Enable
             nm_4byte_addr_en_CMD <= "10110111"; -- 0xB7 h Enable 4 Byte Addressing Mode
             ----------------------------------------------------
             NM_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
             -----
             begin
             -----
                 if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                     if(Rst_to_spi = RESET_ACTIVE) then
                         nm_wr_en_cntrl_ps      <= NM_WR_EN_IDLE;
                         wr_en_under_process_d1 <= '0';
                   wr_en_done_reg         <= '0';
                     else
                         nm_wr_en_cntrl_ps      <= nm_wr_en_cntrl_ns;
                         wr_en_under_process_d1 <= wr_en_under_process;
                   wr_en_done_reg         <= wr_en_done;
          
                     end if;
                 end if;
             end process NM_PS_TO_NS_PROCESS;
             ----------------------------------
             --
             NM_WR_EN_CNTRL_PROCESS: process(
                                            nm_wr_en_cntrl_ps     ,
                                            --SPIXfer_done_int_pulse,
                                            --SPIXfer_done_int      ,
                                            Rst_to_spi            ,
                                            SR_5_Tx_Empty         ,
                                            wr_en_done_reg
                                            ) is
             -----
             begin
             -----
                  --load_wr_en_cmd <= '0';
                  --load_wr_sr_cmd <= '0';
                  --load_wr_sr_d0  <= '0';
                  --load_wr_sr_d1  <= '0';
                  load_wr_en    <= '0';
                  wr_en_done    <= '0';
                  wr_en_under_process <= '0';
                  case nm_wr_en_cntrl_ps is
                      when NM_WR_EN_IDLE => --load_wr_en_cmd <= '1';
                                          load_wr_en          <= '1';
                                          wr_en_under_process <= '1';
                                          nm_wr_en_cntrl_ns   <= NM_WR_EN;
                      when NM_WR_EN      => if (SR_5_Tx_Empty = '1')then
                                                --wr_en_done <= '1';
                                                nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                            else
                                                --wr_en_under_process <= '1';
                                                nm_wr_en_cntrl_ns <= NM_WR_EN;
                                            end if;
                                            wr_en_done          <= SR_5_Tx_Empty;
                                            wr_en_under_process <= not SR_5_Tx_Empty;
          
                      when NM_WR_EN_DONE => if (Rst_to_spi = '1') then
                                                nm_wr_en_cntrl_ns <= NM_WR_EN_IDLE;
                                            else
                                                nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                            end if;
                                            wr_en_done <= wr_en_done_reg;
                  end case;
             end process NM_WR_EN_CNTRL_PROCESS;
          
               ----------------------------------------------------
               NM_4_BYTE_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
               -----
               begin
               -----
                   if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                       if(Rst_to_spi = RESET_ACTIVE) then
                           nm_sm_4_byte_addr_ps           <= NM_32_BIT_IDLE;
                           --four_byte_addr_under_process_d1 <= '0';
                     hpm_under_process_d1   <= '0';
                     wr_en_done_d1          <= '0';
                     wr_en_done_d2          <= '0';
                     wb_hpm_done_reg        <= '0';
                       else
                           nm_sm_4_byte_addr_ps   <= nm_sm_4_byte_addr_ns;
                           hpm_under_process_d1   <= hpm_under_process;
                           --four_byte_en_done_reg           <= four_byte_en_done;   
                     wr_en_done_d1          <= wr_en_done_reg; -- wr_en_done;
                     wr_en_done_d2          <= wr_en_done_d1;
                     wb_hpm_done_reg        <= wb_hpm_done;
                       end if;
                   end if;
               end process NM_4_BYTE_PS_TO_NS_PROCESS;
               ----------------------------------
               --
               NM_4_BYTE_ADDR_EN_PROCESS: process(
                                                  nm_sm_4_byte_addr_ps  ,
                                                  Rst_to_spi            ,
                                                  SR_5_Tx_Empty         ,
                                                  wr_en_done_d2         ,
                                            wb_hpm_done_reg
                                                 ) is
               -----
               begin
               -----
                    -- load_4_byte_addr_en     <= '0';
              load_wr_hpm <= '0';
                    wb_hpm_done <= '0';
              hpm_under_process <= '0';
                    four_byte_en_done          <= '0';
                    four_byte_en_under_process <= '0';
                    case nm_sm_4_byte_addr_ps is
                        when NM_32_BIT_IDLE     => if (wr_en_done_d2 = '1') then
                                                 --load_wr_hpm <= '1';
                                                 --hpm_under_process <= '1';
                                                       nm_sm_4_byte_addr_ns      <= NM_32_BIT_EN;
                                                   else
                                                       nm_sm_4_byte_addr_ns      <= NM_32_BIT_IDLE;
                                                   end if;
                                             load_wr_hpm       <= wr_en_done_d2; 
                                             hpm_under_process <= wr_en_done_d2;
               
                        when NM_32_BIT_EN      => if (SR_5_Tx_Empty = '1') then
                                                -- wb_hpm_done        <= '1';
                                                nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                            else
                                                -- hpm_under_process  <= '1';
                                                      nm_sm_4_byte_addr_ns <= NM_32_BIT_EN;
                                            end if;
                                                  wb_hpm_done        <= SR_5_Tx_Empty;
                                            hpm_under_process  <= not(SR_5_Tx_Empty);
                  when NM_32_BIT_EN_DONE => if(Rst_to_spi = '1')then
                                                      nm_sm_4_byte_addr_ns <= NM_32_BIT_IDLE;
                                                  else
                                                    --  if (SR_5_Tx_Empty = '1')then
                                                    --      --four_byte_en_done          <= '1';
                                              --      wb_hpm_done <= '1';
                                                    --  else
                                                    --      -- four_byte_en_under_process <= '1';
                                              --      hpm_under_process <= '1';
                                                    --  end if;
                                                    --  four_byte_en_done     <= four_byte_en_done_reg;     
                                                      -- wb_hpm_done <= '1';
                                                nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                                  end if;
                                                  wb_hpm_done <= wb_hpm_done_reg;
               
                    end case;
               end process NM_4_BYTE_ADDR_EN_PROCESS;
               --------------------------------------
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK, wb_hpm_done, wr_en_done_reg) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        case wb_hpm_done is
                            -- when "00"|"01" => -- write enable is under process
                            when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- when "01"   => -- Enable 4 byte addressing is under process
                            --                Data_Dir            <= '0';                  
                            --                Data_Mode_1         <= '0';                  
                            --                Data_Mode_0         <= '0';                  
                            --                Data_Phase          <= '0';                  
                            --                --------------------                         
                            --                Quad_Phase          <= '0';-- permanent '0'  
                            --                --------------------                         
                            --                Addr_Mode_1         <= '0';                  
                            --                Addr_Mode_0         <= '0';                  
                            --                Addr_Bit            <= '0';                  
                            --                Addr_Phase          <= '0';                  
                            --                --------------------                         
                            --                CMD_Mode_1          <= '0';                  
                            --                CMD_Mode_0          <= '0';                  
                            -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                            when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '1';                  
                                           Data_Phase          <= '1';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '1';                  
                                           Addr_Bit            <= '1';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage off
                            when others => 
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage on
                        end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         
         end generate NM_EN_32_ADDR_MD_GEN;
         --------------------------------------
         -- -- WB 0011 000 100 0
         -- -- NM 0011 000 100 0<-cmd error
         -- -- NM 0011 010 100 0<-cmd error -- For 0xbbh DIOFR
         --       0011 011 100 0
         -- Data_Dir            <= '0';<-- for BB       -- '0';<-- for BC
         -- Data_Mode_1         <= '0';                 -- '0';
         -- Data_Mode_0         <= '1';                 -- '1';
         -- Data_Phase          <= '1';                 -- '1';
         -- --------------------                        -- 
         -- Quad_Phase          <= '0';-- permanent '0' -- '0';
         -- --------------------                        -- 
         -- Addr_Mode_1         <= '0';                 -- '0';
         -- Addr_Mode_0         <= '1';                 -- '1';
         -- Addr_Bit            <= '0';                 -- '1';
         -- Addr_Phase          <= '1';                 -- '1';
         -- --------------------                        -- 
         -- CMD_Mode_1          <= '0';                 -- '0'
         -- CMD_Mode_0          <= '0';                 -- '0';

          ---------------------------------------------------------------------
          -- RECEIVE_DATA_STROBE_PROCESS : Strobe data from shift register to receive
          --                               data register
          --------------------------------
          -- For a SCK ratio of 2 the Done needs to be delayed by an extra cycle
          -- due to the serial input being captured on the falling edge of the PLB
          -- clock. this is purely required for dealing with the real SPI slave memories.
            --RECEIVE_DATA_NM_GEN: if C_SPI_MEMORY = 2 and C_SPI_MODE /=0 generate
            --begin
            -----
            RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
            -----
            begin
            -----
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                   if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                           receive_Data_int  <= (others => '0');
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-3) downto 0) &
                                                                  IO1_I &  -- MISO_I - MSB first
                                                                  IO0_I ;  -- MOSI_I
                   end if;
                end if;
            end process RECEIVE_DATA_STROBE_PROCESS;
            --end generate RECEIVE_DATA_NM_GEN;
            -----------------------------------------------------------------------------
          CMD_ADDR_NM_24_BIT_GEN: if  C_SPI_MEM_ADDR_BITS = 24 generate
          begin
            -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 4 transactions are of
            --                  CMD, A0, A1, A2. Total 4 bytes need to be removed from the
            --                  calculation of total no. of pure data bytes.
            --                  the actual data from the SPI memory will be stored in the
            --                  receive FIFO only when the first 4 bytes are transferred.
            --                  below counter is for that purpose only.
            CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
            -----
            begin
            -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                 if(Rst_to_spi = '1') or (store_last_b4_wrap = '1') then
                     cmd_addr_cntr <= "000";--(others => '1');
                     cmd_addr_sent <= '0';
                 elsif(pr_state_idle = '1')then
                     cmd_addr_cntr <= "000";
                     cmd_addr_sent <= store_last_b4_wrap;
                 elsif(SPIXfer_done_int_pulse_d2 = '1')then
                     if(cmd_addr_cntr = "101")then
                         cmd_addr_sent <= '1';
                     else
                         cmd_addr_cntr <= cmd_addr_cntr + "001";
                         cmd_addr_sent <= '0';
                     end if;
                 end if;
             end if;
            end process CMD_ADDR_CNTR_P;
            ----------------------------
          end generate CMD_ADDR_NM_24_BIT_GEN;
          ------------------------------------
          CMD_ADDR_NM_32_BIT_GEN: if  C_SPI_MEM_ADDR_BITS = 32 generate
          begin
            -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 5 transactions are of
            --                  CMD, A0, A1, A2, A3. Total 5 bytes need to be removed from the
            --                  calculation of total no. of pure data bytes.
            --                  the actual data from the SPI memory will be stored in the
            --                  receive FIFO only when the first 5 bytes are transferred.
            --                  below counter is for that purpose only. This is 4 byte addessing mode of NM memory.
            CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
            -----
            begin
            -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                 if(Rst_to_spi = '1') or (store_last_b4_wrap = '1') then
                     cmd_addr_cntr <= "000";--(others => '1');
                     cmd_addr_sent <= '0';
                 elsif(pr_state_idle = '1')then
                     cmd_addr_cntr <= "000";
                     cmd_addr_sent <= store_last_b4_wrap;
                 elsif(SPIXfer_done_int_pulse_d2 = '1')then
                     if(cmd_addr_cntr = "111")then
                         cmd_addr_sent <= '1';
                     else
                         cmd_addr_cntr <= cmd_addr_cntr + "001";
                         cmd_addr_sent <= '0';
                     end if;
                 end if;
             end if;
            end process CMD_ADDR_CNTR_P;
            ----------------------------
          end generate CMD_ADDR_NM_32_BIT_GEN;
          ------------------------------------
          
          TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') or (store_last_b4_wrap = '1') then
                  hw_wd_cntr <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
                  hw_wd_cntr <= hw_wd_cntr + "01";
              end if;
          end if;
          end process TWO_BIT_CNTR_P;
          ----------------------------------------------
          STORE_RX_DATA_32_BIT_ADDR: if C_SPI_MEM_ADDR_BITS = 32 generate
          begin
          -----
          STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') then
                  Data_To_Rx_FIFO_int <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d3 = '1') and (cmd_addr_sent = '1') then
                  if(one_byte_xfer_to_spi_clk = '1') then
                     case spi_addr_i(1 downto 0) is
                          when "00" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                             receive_Data_int;
                          when "01" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(7 downto 0);
                          when "10" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(15 downto 0);
                          when "11" =>
                                      Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(23 downto 0);
                          when others => null;
                     end case;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                     if(spi_addr_i(1) = '0') then
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                     else
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                     end if;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                     if(hw_wd_cntr = "00") then -- fill in D0
                         Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                         Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                     elsif(hw_wd_cntr = "01")then -- fill in D1
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                         Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                     elsif(hw_wd_cntr = "10")then -- fill in D2
                         Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                         Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                     else
                         Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                         Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                     end if;
                  else   -- adjustment for complete word
                     --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                     Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                  end if;
              end if;
          end if;
          end process STORE_RX_DATA_SPI_CLK_P;
          end generate STORE_RX_DATA_32_BIT_ADDR;

          STORE_RX_DATA_24_BIT_ADDR: if C_SPI_MEM_ADDR_BITS = 24 generate
          begin
          -----
          STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') then
                  Data_To_Rx_FIFO_int <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
                  if(one_byte_xfer_to_spi_clk = '1') then
                     case spi_addr_i(1 downto 0) is
                          when "00" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                             receive_Data_int;
                          when "01" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(7 downto 0);
                          when "10" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(15 downto 0);
                          when "11" =>
                                      Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(23 downto 0);
                          when others => null;
                     end case;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                     if(spi_addr_i(1) = '0') then
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                     else
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                     end if;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                     if(hw_wd_cntr = "00") then -- fill in D0
                         Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                         Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                     elsif(hw_wd_cntr = "01")then -- fill in D1
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                         Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                     elsif(hw_wd_cntr = "10")then -- fill in D2
                         Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                         Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                     else
                         Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                         Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                     end if;
                  else   -- adjustment for complete word
                     --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                     Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                  end if;
              end if;
          end if;
          end process STORE_RX_DATA_SPI_CLK_P;
          end generate STORE_RX_DATA_24_BIT_ADDR;

        ----------------------------
        Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
        ---------------------------------------
        end generate NM_MEM_DUAL_MD_GEN;
        SP_MEM_DUAL_MD_GEN: if C_SPI_MEMORY = 3 generate
        -----
        begin
        -----
          --wb_hpm_done    <= '1';
          ---- Dual mode command = 0x3B - DOFR
          --SPI_cmd <= "00111011";
          --------------------------------------------------------
          DUAL_SPI_CMD_NM_24_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
          -----
          begin
          -----
              ---------------------------
              SPI_cmd <= "10111011"; -- 0xBB - DIOFR
              wb_hpm_done <= '1';
              --------------------------- 
              Data_Dir            <= '0';-- for BB       
              Data_Mode_1         <= '0';                       
              Data_Mode_0         <= '1';                       
              Data_Phase          <= '1';                       
              --------------------                      
              Quad_Phase          <= '0';-- permanent '0'       
              --------------------                      
              Addr_Mode_1         <= '0';                       
              Addr_Mode_0         <= '1';                       
              Addr_Bit            <= '0';                       
              Addr_Phase          <= '1';                       
              --------------------                      
              CMD_Mode_1          <= '0';                       
              CMD_Mode_0          <= '0';                        
              ---------------------------
          end generate DUAL_SPI_CMD_NM_24_GEN;
          ------------------------------------

          DUAL_SPI_CMD_NM_32_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
          -----
          begin
          -----
              
              SPI_cmd <= "10111100"; -- 0xBCh - DIOFR_4Byte

          end generate DUAL_SPI_CMD_NM_32_GEN;
          ------------------------------------
          
          NM_EN_32_ADDR_MD_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
          begin
          -----
             nm_wr_en_CMD         <= "00000110"; -- 0x06 h Write Enable
             nm_4byte_addr_en_CMD <= "10110111"; -- 0xB7 h Enable 4 Byte Addressing Mode
             ----------------------------------------------------
             NM_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
             -----
             begin
             -----
                 if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                     if(Rst_to_spi = RESET_ACTIVE) then
                         nm_wr_en_cntrl_ps      <= NM_WR_EN_IDLE;
                         wr_en_under_process_d1 <= '0';
                   wr_en_done_reg         <= '0';
                     else
                         nm_wr_en_cntrl_ps      <= nm_wr_en_cntrl_ns;
                         wr_en_under_process_d1 <= wr_en_under_process;
                   wr_en_done_reg         <= wr_en_done;
          
                     end if;
                 end if;
             end process NM_PS_TO_NS_PROCESS;
             ----------------------------------
             --
             NM_WR_EN_CNTRL_PROCESS: process(
                                            nm_wr_en_cntrl_ps     ,
                                            --SPIXfer_done_int_pulse,
                                            --SPIXfer_done_int      ,
                                            Rst_to_spi            ,
                                            SR_5_Tx_Empty         ,
                                            wr_en_done_reg
                                            ) is
             -----
             begin
             -----
                  --load_wr_en_cmd <= '0';
                  --load_wr_sr_cmd <= '0';
                  --load_wr_sr_d0  <= '0';
                  --load_wr_sr_d1  <= '0';
                  load_wr_en    <= '0';
                  wr_en_done    <= '0';
                  wr_en_under_process <= '0';
                  case nm_wr_en_cntrl_ps is
                      when NM_WR_EN_IDLE => --load_wr_en_cmd <= '1';
                                          load_wr_en          <= '1';
                                          wr_en_under_process <= '1';
                                          nm_wr_en_cntrl_ns   <= NM_WR_EN;
                      when NM_WR_EN      => if (SR_5_Tx_Empty = '1')then
                                                --wr_en_done <= '1';
                                                nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                            else
                                                --wr_en_under_process <= '1';
                                                nm_wr_en_cntrl_ns <= NM_WR_EN;
                                            end if;
                                            wr_en_done          <= SR_5_Tx_Empty;
                                            wr_en_under_process <= not SR_5_Tx_Empty;
          
                      when NM_WR_EN_DONE => if (Rst_to_spi = '1') then
                                                nm_wr_en_cntrl_ns <= NM_WR_EN_IDLE;
                                            else
                                                nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                            end if;
                                            wr_en_done <= wr_en_done_reg;
                  end case;
             end process NM_WR_EN_CNTRL_PROCESS;
          
               ----------------------------------------------------
               NM_4_BYTE_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
               -----
               begin
               -----
                   if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                       if(Rst_to_spi = RESET_ACTIVE) then
                           nm_sm_4_byte_addr_ps           <= NM_32_BIT_IDLE;
                           --four_byte_addr_under_process_d1 <= '0';
                     hpm_under_process_d1   <= '0';
                     wr_en_done_d1          <= '0';
                     wr_en_done_d2          <= '0';
                     wb_hpm_done_reg        <= '0';
                       else
                           nm_sm_4_byte_addr_ps   <= nm_sm_4_byte_addr_ns;
                           hpm_under_process_d1   <= hpm_under_process;
                           --four_byte_en_done_reg           <= four_byte_en_done;   
                     wr_en_done_d1          <= wr_en_done_reg; -- wr_en_done;
                     wr_en_done_d2          <= wr_en_done_d1;
                     wb_hpm_done_reg        <= wb_hpm_done;
                       end if;
                   end if;
               end process NM_4_BYTE_PS_TO_NS_PROCESS;
               ----------------------------------
               --
               NM_4_BYTE_ADDR_EN_PROCESS: process(
                                                  nm_sm_4_byte_addr_ps  ,
                                                  Rst_to_spi            ,
                                                  SR_5_Tx_Empty         ,
                                                  wr_en_done_d2         ,
                                            wb_hpm_done_reg
                                                 ) is
               -----
               begin
               -----
                    -- load_4_byte_addr_en     <= '0';
              load_wr_hpm <= '0';
                    wb_hpm_done <= '0';
              hpm_under_process <= '0';
                    four_byte_en_done          <= '0';
                    four_byte_en_under_process <= '0';
                    case nm_sm_4_byte_addr_ps is
                        when NM_32_BIT_IDLE     => if (wr_en_done_d2 = '1') then
                                                 --load_wr_hpm <= '1';
                                                 --hpm_under_process <= '1';
                                                       nm_sm_4_byte_addr_ns      <= NM_32_BIT_EN;
                                                   else
                                                       nm_sm_4_byte_addr_ns      <= NM_32_BIT_IDLE;
                                                   end if;
                                             load_wr_hpm       <= wr_en_done_d2; 
                                             hpm_under_process <= wr_en_done_d2;
               
                        when NM_32_BIT_EN      => if (SR_5_Tx_Empty = '1') then
                                                -- wb_hpm_done        <= '1';
                                                nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                            else
                                                -- hpm_under_process  <= '1';
                                                      nm_sm_4_byte_addr_ns <= NM_32_BIT_EN;
                                            end if;
                                                  wb_hpm_done        <= SR_5_Tx_Empty;
                                            hpm_under_process  <= not(SR_5_Tx_Empty);
                  when NM_32_BIT_EN_DONE => if(Rst_to_spi = '1')then
                                                      nm_sm_4_byte_addr_ns <= NM_32_BIT_IDLE;
                                                  else
                                                    --  if (SR_5_Tx_Empty = '1')then
                                                    --      --four_byte_en_done          <= '1';
                                              --      wb_hpm_done <= '1';
                                                    --  else
                                                    --      -- four_byte_en_under_process <= '1';
                                              --      hpm_under_process <= '1';
                                                    --  end if;
                                                    --  four_byte_en_done     <= four_byte_en_done_reg;     
                                                      -- wb_hpm_done <= '1';
                                                nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                                  end if;
                                                  wb_hpm_done <= wb_hpm_done_reg;
               
                    end case;
               end process NM_4_BYTE_ADDR_EN_PROCESS;
               --------------------------------------
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        case wb_hpm_done is
                            -- when "00"|"01" => -- write enable is under process
                            when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- when "01"   => -- Enable 4 byte addressing is under process
                            --                Data_Dir            <= '0';                  
                            --                Data_Mode_1         <= '0';                  
                            --                Data_Mode_0         <= '0';                  
                            --                Data_Phase          <= '0';                  
                            --                --------------------                         
                            --                Quad_Phase          <= '0';-- permanent '0'  
                            --                --------------------                         
                            --                Addr_Mode_1         <= '0';                  
                            --                Addr_Mode_0         <= '0';                  
                            --                Addr_Bit            <= '0';                  
                            --                Addr_Phase          <= '0';                  
                            --                --------------------                         
                            --                CMD_Mode_1          <= '0';                  
                            --                CMD_Mode_0          <= '0';                  
                            -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                            when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '1';                  
                                           Data_Phase          <= '1';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '1';                  
                                           Addr_Bit            <= '1';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage off
                            when others => 
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage on
                        end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         
         end generate NM_EN_32_ADDR_MD_GEN;
         --------------------------------------
         -- -- WB 0011 000 100 0
         -- -- NM 0011 000 100 0<-cmd error
         -- -- NM 0011 010 100 0<-cmd error -- For 0xbbh DIOFR
         --       0011 011 100 0
         -- Data_Dir            <= '0';<-- for BB       -- '0';<-- for BC
         -- Data_Mode_1         <= '0';                 -- '0';
         -- Data_Mode_0         <= '1';                 -- '1';
         -- Data_Phase          <= '1';                 -- '1';
         -- --------------------                        -- 
         -- Quad_Phase          <= '0';-- permanent '0' -- '0';
         -- --------------------                        -- 
         -- Addr_Mode_1         <= '0';                 -- '0';
         -- Addr_Mode_0         <= '1';                 -- '1';
         -- Addr_Bit            <= '0';                 -- '1';
         -- Addr_Phase          <= '1';                 -- '1';
         -- --------------------                        -- 
         -- CMD_Mode_1          <= '0';                 -- '0'
         -- CMD_Mode_0          <= '0';                 -- '0';

          ---------------------------------------------------------------------
          -- RECEIVE_DATA_STROBE_PROCESS : Strobe data from shift register to receive
          --                               data register
          --------------------------------
          -- For a SCK ratio of 2 the Done needs to be delayed by an extra cycle
          -- due to the serial input being captured on the falling edge of the PLB
          -- clock. this is purely required for dealing with the real SPI slave memories.
            --RECEIVE_DATA_NM_GEN: if C_SPI_MEMORY = 2 and C_SPI_MODE /=0 generate
            --begin
            -----
            RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
            -----
            begin
            -----
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                   if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                           receive_Data_int  <= (others => '0');
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-3) downto 0) &
                                                                  IO1_I &  -- MISO_I - MSB first
                                                                  IO0_I ;  -- MOSI_I
                   end if;
                end if;
            end process RECEIVE_DATA_STROBE_PROCESS;
            --end generate RECEIVE_DATA_NM_GEN;
            -----------------------------------------------------------------------------
          CMD_ADDR_NM_24_BIT_GEN: if  C_SPI_MEM_ADDR_BITS = 24 generate
          begin
            -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 4 transactions are of
            --                  CMD, A0, A1, A2. Total 4 bytes need to be removed from the
            --                  calculation of total no. of pure data bytes.
            --                  the actual data from the SPI memory will be stored in the
            --                  receive FIFO only when the first 4 bytes are transferred.
            --                  below counter is for that purpose only.
            CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
            -----
            begin
            -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                 if(Rst_to_spi = '1') or (store_last_b4_wrap = '1') then
                     cmd_addr_cntr <= "000";--(others => '1');
                     cmd_addr_sent <= '0';
                 elsif(pr_state_idle = '1')then
                     cmd_addr_cntr <= "000";
                     cmd_addr_sent <= store_last_b4_wrap;
                 elsif(SPIXfer_done_int_pulse_d2 = '1')then
                     if(cmd_addr_cntr = "100")then
                         cmd_addr_sent <= '1';
                     else
                         cmd_addr_cntr <= cmd_addr_cntr + "001";
                         cmd_addr_sent <= '0';
                     end if;
                 end if;
             end if;
            end process CMD_ADDR_CNTR_P;
            ----------------------------
          end generate CMD_ADDR_NM_24_BIT_GEN;
          ------------------------------------
          CMD_ADDR_NM_32_BIT_GEN: if  C_SPI_MEM_ADDR_BITS = 32 generate
          begin
            -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 5 transactions are of
            --                  CMD, A0, A1, A2, A3. Total 5 bytes need to be removed from the
            --                  calculation of total no. of pure data bytes.
            --                  the actual data from the SPI memory will be stored in the
            --                  receive FIFO only when the first 5 bytes are transferred.
            --                  below counter is for that purpose only. This is 4 byte addessing mode of NM memory.
            CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
            -----
            begin
            -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                 if(Rst_to_spi = '1') or (store_last_b4_wrap = '1') then
                     cmd_addr_cntr <= "000";--(others => '1');
                     cmd_addr_sent <= '0';
                 elsif(pr_state_idle = '1')then
                     cmd_addr_cntr <= "000";
                     cmd_addr_sent <= store_last_b4_wrap;
                 elsif(SPIXfer_done_int_pulse_d2 = '1')then
                     if(cmd_addr_cntr = "110")then
                         cmd_addr_sent <= '1';
                     else
                         cmd_addr_cntr <= cmd_addr_cntr + "001";
                         cmd_addr_sent <= '0';
                     end if;
                 end if;
             end if;
            end process CMD_ADDR_CNTR_P;
            ----------------------------
          end generate CMD_ADDR_NM_32_BIT_GEN;
          ------------------------------------
          
          TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') or (store_last_b4_wrap = '1') then
                  hw_wd_cntr <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
                  hw_wd_cntr <= hw_wd_cntr + "01";
              end if;
          end if;
          end process TWO_BIT_CNTR_P;
          ----------------------------------------------
          STORE_RX_DATA_32_BIT_ADDR: if C_SPI_MEM_ADDR_BITS = 32 generate
          begin
          -----
          STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') then
                  Data_To_Rx_FIFO_int <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d3 = '1') and (cmd_addr_sent = '1') then
                  if(one_byte_xfer_to_spi_clk = '1') then
                     case spi_addr_i(1 downto 0) is
                          when "00" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                             receive_Data_int;
                          when "01" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(7 downto 0);
                          when "10" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(15 downto 0);
                          when "11" =>
                                      Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(23 downto 0);
                          when others => null;
                     end case;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                     if(spi_addr_i(1) = '0') then
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                     else
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                     end if;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                     if(hw_wd_cntr = "00") then -- fill in D0
                         Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                         Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                     elsif(hw_wd_cntr = "01")then -- fill in D1
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                         Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                     elsif(hw_wd_cntr = "10")then -- fill in D2
                         Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                         Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                     else
                         Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                         Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                     end if;
                  else   -- adjustment for complete word
                     --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                     Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                  end if;
              end if;
          end if;
          end process STORE_RX_DATA_SPI_CLK_P;
          end generate STORE_RX_DATA_32_BIT_ADDR;

          STORE_RX_DATA_24_BIT_ADDR: if C_SPI_MEM_ADDR_BITS = 24 generate
          begin
          -----
          STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
          begin
          -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(load_axi_data_to_spi_clk = '1') then
                  Data_To_Rx_FIFO_int <= (others => '0');
              elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
                  if(one_byte_xfer_to_spi_clk = '1') then
                     case spi_addr_i(1 downto 0) is
                          when "00" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                             receive_Data_int;
                          when "01" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(7 downto 0);
                          when "10" =>
                                      Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                             receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(15 downto 0);
                          when "11" =>
                                      Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                             Data_To_Rx_FIFO_int(23 downto 0);
                          when others => null;
                     end case;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                     if(spi_addr_i(1) = '0') then
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                     else
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                         Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                     end if;
                  elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                     if(hw_wd_cntr = "00") then -- fill in D0
                         Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                         Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                     elsif(hw_wd_cntr = "01")then -- fill in D1
                         Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                         Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                     elsif(hw_wd_cntr = "10")then -- fill in D2
                         Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                         Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                         Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                     else
                         Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                         Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                     end if;
                  else   -- adjustment for complete word
                     --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                     Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
                  end if;
              end if;
          end if;
          end process STORE_RX_DATA_SPI_CLK_P;
          end generate STORE_RX_DATA_24_BIT_ADDR;

        ----------------------------
        Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
        ---------------------------------------
        end generate SP_MEM_DUAL_MD_GEN;

end generate DUAL_MODE_CONTROL_GEN;

QUAD_MODE_CONTROL_GEN: if C_SPI_MODE = 2 generate
-----
begin
-----
-- WB 0011 0101 00 0<-cmd error
-- NM 001100101 00 0<-cmd error
     WB_MEM_QUAD_MD_GEN:if C_SPI_MEMORY = 1 generate
     signal cmd_addr_cntr   : std_logic_vector(2 downto 0);
     signal hw_wd_cntr : std_logic_vector(1 downto 0);
     -----
     begin
     -----
        wb_wr_hpm_CMD <= "10100011"; -- 0xA3 h HPM mode
        --
        ----------------------------------------------------
        WB_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
        -----
        begin
        -----
            if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                if(Rst_to_spi = RESET_ACTIVE) then
                    wb_cntrl_ps        <= WB_IDLE;
                    hpm_under_process_d1 <= '0';
                else
                    wb_cntrl_ps        <= wb_cntrl_ns;
                    hpm_under_process_d1 <= hpm_under_process;
                end if;
            end if;
        end process WB_PS_TO_NS_PROCESS;
        ----------------------------------
        --
        WB_DUAL_CNTRL_PROCESS: process(
                                       wb_cntrl_ps           ,
                                       SPIXfer_done_int_pulse,
                                       SPIXfer_done_int      ,
                                       Rst_to_spi            ,
                                       SR_5_Tx_Empty
                                       ) is
        -----
        begin
        -----
             load_wr_en_cmd <= '0';
             load_wr_sr_cmd <= '0';
             load_wr_sr_d0  <= '0';
             load_wr_sr_d1  <= '0';
             load_wr_hpm    <= '0';
             wb_hpm_done    <= '0';
             hpm_under_process <= '0';
             case wb_cntrl_ps is
                 when WB_IDLE     => load_wr_hpm <= '1';
                                     hpm_under_process <= '1';
                                     wb_cntrl_ns <= WB_WR_HPM;
                 when WB_WR_HPM   => if (SR_5_Tx_Empty = '1')then
                                         wb_hpm_done <= '1';
                                         wb_cntrl_ns <= WB_DONE;
                                     else
                                         hpm_under_process <= '1';
                                         wb_cntrl_ns <= WB_WR_HPM;
                                     end if;
                 when WB_DONE     => if (Rst_to_spi = '1') then
                                         wb_cntrl_ns <= WB_IDLE;
                                     else
                                         wb_hpm_done <= '1';
                                         wb_cntrl_ns <= WB_DONE;
                                     end if;
             end case;
        end process WB_DUAL_CNTRL_PROCESS;

     ---- Quad mode command = 0x6B - QOFR Read
     -- SPI_cmd <= "01101011";
                -- 0101 000 100 0
     ---- Quad mode command = 0xEB - QIOFR Read
     SPI_cmd <= "11101011";
                -- 0101 100 100 0  -- QUAD_IO_FAST_RD

     Data_Dir            <= '0';
     Data_Mode_1         <= '1';
     Data_Mode_0         <= '0';
     Data_Phase          <= '1';
     --------------------
     Quad_Phase          <= '0';-- permanent '0'
     --------------------
     Addr_Mode_1         <= '1';-- '0' for QOFR and '1' for QIOFR
     Addr_Mode_0         <= '0';
     Addr_Bit            <= '0';
     Addr_Phase          <= '1';
     --------------------
     CMD_Mode_1          <= '0';
     CMD_Mode_0          <= '0';

     ---------------------------------------------------------------------
     --RECEIVE_DATA_WB_GEN: if C_SPI_MEMORY = 1 and C_SPI_MODE /=0 generate
     --begin
     -----
     RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
     -----
     begin
     -----
         if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
            if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                    receive_Data_int  <= (others => '0');
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1')then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-5) downto 0) &
                                                                  IO3_I &  -- MSB first
                                                                  IO2_I &
                                                                  IO1_I &
                                                                  IO0_I ;
            end if;
         end if;
     end process RECEIVE_DATA_STROBE_PROCESS;
     --end generate RECEIVE_DATA_WB_GEN;
        ---------------------------------------------------------------------
     -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 4 transactions are of
     --                  CMD, A0, A1, A2. Total 4 bytes need to be removed from the
     --                  calculation of total no. of pure data bytes.
     --                  the actual data from the SPI memory will be stored in the
     --                  receive FIFO only when the first 4 bytes are transferred.
     --                  below counter is for that purpose only.
     CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
     -----
     begin
     -----
          if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
              if(Rst_to_spi = '1') or (load_axi_data_to_spi_clk = '1') then
                  cmd_addr_cntr <= "000";--(others => '1');
                  cmd_addr_sent <= '0';
              elsif(pr_state_idle = '1')then
                  cmd_addr_cntr <= "000";
                  cmd_addr_sent <= store_last_b4_wrap;
              elsif(SPIXfer_done_int_pulse_d2 = '1')then
                  if(cmd_addr_cntr = "110")then
                      cmd_addr_sent <= '1';
                  else
                      cmd_addr_cntr <= cmd_addr_cntr + "001";
                      cmd_addr_sent <= '0';
                  end if;
              end if;
          end if;
     end process CMD_ADDR_CNTR_P;
     ----------------------------
          TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
     begin
     -----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
         if(load_axi_data_to_spi_clk = '1') or (start_after_wrap = '1') then
             hw_wd_cntr <= (others => '0');
         elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
             hw_wd_cntr <= hw_wd_cntr + "01";
         end if;
     end if;
     end process TWO_BIT_CNTR_P;

     STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
     begin
     -----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
         if(load_axi_data_to_spi_clk = '1') then
             Data_To_Rx_FIFO_int <= (others => '0');
         elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
             if(one_byte_xfer_to_spi_clk = '1') then
                case spi_addr_i(1 downto 0) is
                     when "00" =>
                                 Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                        receive_Data_int;
                     when "01" =>
                                 Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                        receive_Data_int                 &
                                                        Data_To_Rx_FIFO_int(7 downto 0);
                     when "10" =>
                                 Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                        receive_Data_int                 &
                                                        Data_To_Rx_FIFO_int(15 downto 0);
                     when "11" =>
                                 Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                        Data_To_Rx_FIFO_int(23 downto 0);
                     when others => null;
                end case;
             elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                if(spi_addr_i(1) = '0') then
                    Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                    Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                else
                    Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                    Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                end if;
             elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                if(hw_wd_cntr = "00") then -- fill in D0
                    Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                    Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                elsif(hw_wd_cntr = "01")then -- fill in D1
                    Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                    Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                    Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                elsif(hw_wd_cntr = "10")then -- fill in D2
                    Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                    Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                    Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                else
                    Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                    Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                end if;
             else   -- adjustment for complete word
                --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
             end if;
         end if;
        end if;
        end process STORE_RX_DATA_SPI_CLK_P;
        ----------------------------
        Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
        ---------------------------------------

     ----------------------------

     end generate WB_MEM_QUAD_MD_GEN;
     -- NM 0011 0 0101 00 0<-cmd error

     NM_MEM_QUAD_MD_GEN:if C_SPI_MEMORY = 2 generate
     signal cmd_addr_cntr   : std_logic_vector(3 downto 0);
     signal hw_wd_cntr : std_logic_vector(1 downto 0);
     begin
     -----
       --wb_hpm_done    <= '1';
----   Quad mode command = 0x6B - QOFR Read - 0xEBh
       --SPI_cmd <= --  "01101011";
                  -- 0101 1 000100 0
       QUAD_SPI_CMD_NM_24_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
       begin
           SPI_cmd <= "11101011"; -- QIOFR
                  -- 0101 1 100100 0
           wb_hpm_done <= '1';
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK, wb_hpm_done, wr_en_done_reg) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        case wb_hpm_done is
                            -- when "00"|"01" => -- write enable is under process
                            when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- when "01"   => -- Enable 4 byte addressing is under process
                            --                Data_Dir            <= '0';                  
                            --                Data_Mode_1         <= '0';                  
                            --                Data_Mode_0         <= '0';                  
                            --                Data_Phase          <= '0';                  
                            --                --------------------                         
                            --                Quad_Phase          <= '0';-- permanent '0'  
                            --                --------------------                         
                            --                Addr_Mode_1         <= '0';                  
                            --                Addr_Mode_0         <= '0';                  
                            --                Addr_Bit            <= '0';                  
                            --                Addr_Phase          <= '0';                  
                            --                --------------------                         
                            --                CMD_Mode_1          <= '0';                  
                            --                CMD_Mode_0          <= '0';                  
                            -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                            when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '1';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '1';                  
                                           --------------------                         
                                           Quad_Phase          <= '1';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '1';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage off
                            when others => 
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage on
                        end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         --------------------------------

       end generate QUAD_SPI_CMD_NM_24_GEN;
       
       QUAD_SPI_CMD_NM_32_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
       begin
           SPI_cmd <= "11101100"; -- QIOFR_4Byte 0xECh
                  -- 0101 1 100100 0
       end generate QUAD_SPI_CMD_NM_32_GEN;

       NM_EN_32_ADDR_MD_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
       begin
       -----
          nm_wr_en_CMD         <= "00000110"; -- 0x06 h Write Enable
          nm_4byte_addr_en_CMD <= "10110111"; -- 0xB7 h Enable 4 Byte Addressing Mode
          ----------------------------------------------------
          NM_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
          -----
          begin
          -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                  if(Rst_to_spi = RESET_ACTIVE) then
                      nm_wr_en_cntrl_ps      <= NM_WR_EN_IDLE;
                      wr_en_under_process_d1 <= '0';
                wr_en_done_reg         <= '0';
                  else
                      nm_wr_en_cntrl_ps      <= nm_wr_en_cntrl_ns;
                      wr_en_under_process_d1 <= wr_en_under_process;
                wr_en_done_reg         <= wr_en_done;
       
                  end if;
              end if;
          end process NM_PS_TO_NS_PROCESS;
          ----------------------------------
          --
          NM_WR_EN_CNTRL_PROCESS: process(
                                         nm_wr_en_cntrl_ps     ,
                                         --SPIXfer_done_int_pulse,
                                         --SPIXfer_done_int      ,
                                         Rst_to_spi            ,
                                         SR_5_Tx_Empty         ,
                                   wr_en_done_reg
                                         ) is
          -----
          begin
          -----
               --load_wr_en_cmd <= '0';
               --load_wr_sr_cmd <= '0';
               --load_wr_sr_d0  <= '0';
               --load_wr_sr_d1  <= '0';
               load_wr_en    <= '0';
               wr_en_done    <= '0';
               wr_en_under_process <= '0';
               case nm_wr_en_cntrl_ps is
                   when NM_WR_EN_IDLE => --load_wr_en_cmd <= '1';
                                       load_wr_en          <= '1';
                                       wr_en_under_process <= '1';
                                       nm_wr_en_cntrl_ns   <= NM_WR_EN;
                   when NM_WR_EN      => if (SR_5_Tx_Empty = '1')then
                                             --wr_en_done <= '1';
                                             nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                         else
                                             --wr_en_under_process <= '1';
                                             nm_wr_en_cntrl_ns <= NM_WR_EN;
                                         end if;
                                         wr_en_done          <= SR_5_Tx_Empty;
                                         wr_en_under_process <= not SR_5_Tx_Empty;
       
                   when NM_WR_EN_DONE => if (Rst_to_spi = '1') then
                                             nm_wr_en_cntrl_ns <= NM_WR_EN_IDLE;
                                         else
                                             nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                         end if;
                                         wr_en_done <= wr_en_done_reg;
               end case;
          end process NM_WR_EN_CNTRL_PROCESS;
       
            ----------------------------------------------------
            NM_4_BYTE_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
            -----
            begin
            -----
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                    if(Rst_to_spi = RESET_ACTIVE) then
                        nm_sm_4_byte_addr_ps           <= NM_32_BIT_IDLE;
                        --four_byte_addr_under_process_d1 <= '0';
                  hpm_under_process_d1   <= '0';
                  wr_en_done_d1          <= '0';
                  wr_en_done_d2          <= '0';
                  wb_hpm_done_reg        <= '0';
                    else
                        nm_sm_4_byte_addr_ps   <= nm_sm_4_byte_addr_ns;
                        hpm_under_process_d1   <= hpm_under_process;
                        --four_byte_en_done_reg           <= four_byte_en_done;   
                  wr_en_done_d1          <= wr_en_done_reg; -- wr_en_done;
                  wr_en_done_d2          <= wr_en_done_d1;
                  wb_hpm_done_reg        <= wb_hpm_done;
                    end if;
                end if;
            end process NM_4_BYTE_PS_TO_NS_PROCESS;
            ----------------------------------
            --
            NM_4_BYTE_ADDR_EN_PROCESS: process(
                                               nm_sm_4_byte_addr_ps  ,
                                               Rst_to_spi            ,
                                               SR_5_Tx_Empty         ,
                                               wr_en_done_d2         ,
                                         wb_hpm_done_reg
                                              ) is
            -----
            begin
            -----
                 -- load_4_byte_addr_en     <= '0';
           load_wr_hpm <= '0';
                 wb_hpm_done <= '0';
           hpm_under_process <= '0';
                 four_byte_en_done          <= '0';
                 four_byte_en_under_process <= '0';
                 case nm_sm_4_byte_addr_ps is
                     when NM_32_BIT_IDLE     => if (wr_en_done_d2 = '1') then
                                              --load_wr_hpm <= '1';
                                              --hpm_under_process <= '1';
                                                    nm_sm_4_byte_addr_ns      <= NM_32_BIT_EN;
                                                else
                                                    nm_sm_4_byte_addr_ns      <= NM_32_BIT_IDLE;
                                                end if;
                                          load_wr_hpm       <= wr_en_done_d2; 
                                          hpm_under_process <= wr_en_done_d2;
            
                     when NM_32_BIT_EN      => if (SR_5_Tx_Empty = '1') then
                                             -- wb_hpm_done        <= '1';
                                             nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                         else
                                             -- hpm_under_process  <= '1';
                                                   nm_sm_4_byte_addr_ns <= NM_32_BIT_EN;
                                         end if;
                                               wb_hpm_done        <= SR_5_Tx_Empty;
                                         hpm_under_process  <= not(SR_5_Tx_Empty);
               when NM_32_BIT_EN_DONE => if(Rst_to_spi = '1')then
                                                   nm_sm_4_byte_addr_ns <= NM_32_BIT_IDLE;
                                               else
                                                 --  if (SR_5_Tx_Empty = '1')then
                                                 --      --four_byte_en_done          <= '1';
                                           --      wb_hpm_done <= '1';
                                                 --  else
                                                 --      -- four_byte_en_under_process <= '1';
                                           --      hpm_under_process <= '1';
                                                 --  end if;
                                                 --  four_byte_en_done     <= four_byte_en_done_reg;     
                                                   -- wb_hpm_done <= '1';
                                             nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                               end if;
                                               wb_hpm_done <= wb_hpm_done_reg;
            
                 end case;
            end process NM_4_BYTE_ADDR_EN_PROCESS;
            --------------------------------------
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK, wb_hpm_done, wr_en_done_reg) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        case wb_hpm_done is
                            -- when "00"|"01" => -- write enable is under process
                            when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- when "01"   => -- Enable 4 byte addressing is under process
                            --                Data_Dir            <= '0';                  
                            --                Data_Mode_1         <= '0';                  
                            --                Data_Mode_0         <= '0';                  
                            --                Data_Phase          <= '0';                  
                            --                --------------------                         
                            --                Quad_Phase          <= '0';-- permanent '0'  
                            --                --------------------                         
                            --                Addr_Mode_1         <= '0';                  
                            --                Addr_Mode_0         <= '0';                  
                            --                Addr_Bit            <= '0';                  
                            --                Addr_Phase          <= '0';                  
                            --                --------------------                         
                            --                CMD_Mode_1          <= '0';                  
                            --                CMD_Mode_0          <= '0';                  
                            -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                            when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '1';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '1';                  
                                           --------------------                         
                                           Quad_Phase          <= '1';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '1';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '1';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage off
                            when others => 
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage on
                        end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         --------------------------------
       end generate NM_EN_32_ADDR_MD_GEN;
       -------------------------------------
       -- Data_Dir            <= '0';
       -- Data_Mode_1         <= '1';
       -- Data_Mode_0         <= '0';
       -- Data_Phase          <= '1';
       -- --------------------
       -- Quad_Phase          <= '1';-- for NM this is 0
       -- --------------------
       -- Addr_Mode_1         <= '1';
       -- Addr_Mode_0         <= '0';
       -- Addr_Bit            <= '0';
       -- Addr_Phase          <= '1';
       -- --------------------
       -- CMD_Mode_1          <= '0';
       -- CMD_Mode_0          <= '0';
       
       ---------------------------------------------------------------------
       -- RECEIVE_DATA_STROBE_PROCESS : Strobe data from shift register to receive
       --                               data register
       --------------------------------
       -- For a SCK ratio of 2 the Done needs to be delayed by an extra cycle
       -- due to the serial input being captured on the falling edge of the PLB
       -- clock. this is purely required for dealing with the real SPI slave memories.
         --RECEIVE_DATA_NM_GEN: if C_SPI_MEMORY = 2 and C_SPI_MODE /=0 generate
         --begin
         -----
         RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
         -----
         begin
         -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                        receive_Data_int  <= (others => '0');
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-5) downto 0) &
                                                                  IO3_I &  -- MSB first
                                                                  IO2_I &
                                                                  IO1_I &
                                                                  IO0_I ;
                end if;
             end if;
         end process RECEIVE_DATA_STROBE_PROCESS;
         --end generate RECEIVE_DATA_NM_GEN;
       -----------------------------------------------------------------------------
       CMD_ADDR_NM_24_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
       begin
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 5 transactions are of
         --                  CMD, A0, A1, A2. Total 4 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 4 bytes are transferred.
         --                  below counter is for that purpose only. This is for 24 bit addressing of NM memories only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         -----
         begin
         -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1')               or
                    (load_axi_data_to_spi_clk = '1') or
                    (store_last_b4_wrap = '1') then
                      cmd_addr_cntr <= "0000";--(others => '1');
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1')then
                      cmd_addr_cntr <= "0000";
                      cmd_addr_sent <= store_last_b4_wrap;
                  elsif(SPIXfer_done_int_pulse_d2 = '1')then
                      if(cmd_addr_cntr = "1000")then
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "0001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
       end generate CMD_ADDR_NM_24_BIT_GEN;
       ------------------------------------
       CMD_ADDR_NM_32_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
       begin
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 6 transactions are of
         --                  CMD, A0, A1, A2, A3. Total 5 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 5 bytes are transferred.
         --                  below counter is for that purpose only. This is for 32 bit addressing of NM memories only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         -----
         begin
         -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1')               or
                    (load_axi_data_to_spi_clk = '1') or
                    (store_last_b4_wrap = '1') then
                      cmd_addr_cntr <= "0000";--(others => '1');
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1')then
                      cmd_addr_cntr <= "0000";
                      cmd_addr_sent <= store_last_b4_wrap;
                  elsif(SPIXfer_done_int_pulse_d2 = '1')then
                      if(cmd_addr_cntr = "1001")then -- note the differene in counter value
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "0001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
       end generate CMD_ADDR_NM_32_BIT_GEN;
       ------------------------------------
       TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(load_axi_data_to_spi_clk = '1') or (start_after_wrap = '1') then
               hw_wd_cntr <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
               hw_wd_cntr <= hw_wd_cntr + "01";
           end if;
       end if;
       end process TWO_BIT_CNTR_P;
       ---------------------------       
       STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(load_axi_data_to_spi_clk = '1') then
               Data_To_Rx_FIFO_int <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
               if(one_byte_xfer_to_spi_clk = '1') then
                  case spi_addr_i(1 downto 0) is
                       when "00" =>
                                   Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                          receive_Data_int;
                       when "01" =>
                                   Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                          receive_Data_int                 &
                                                          Data_To_Rx_FIFO_int(7 downto 0);
                       when "10" =>
                                   Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                          receive_Data_int                 &
                                                          Data_To_Rx_FIFO_int(15 downto 0);
                       when "11" =>
                                   Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                          Data_To_Rx_FIFO_int(23 downto 0);
                       when others => null;
                  end case;
               elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                  if(spi_addr_i(1) = '0') then
                      Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                      Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                  else
                      Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                      Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                  end if;
               elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                  if(hw_wd_cntr = "00") then -- fill in D0
                      Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                      Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                  elsif(hw_wd_cntr = "01")then -- fill in D1
                      Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                      Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                      Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                  elsif(hw_wd_cntr = "10")then -- fill in D2
                      Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                      Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                      Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                  else
                      Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                      Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                  end if;
               else   -- adjustment for complete word
                  --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                  Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
               end if;
           end if;
          end if;
          end process STORE_RX_DATA_SPI_CLK_P;
          ----------------------------
          Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
          ---------------------------------------

     --------------------------------
     end generate NM_MEM_QUAD_MD_GEN;
 
    --------------------------------
	     SP_MEM_QUAD_MD_GEN:if C_SPI_MEMORY = 3 generate
     signal cmd_addr_cntr   : std_logic_vector(3 downto 0);
     signal hw_wd_cntr : std_logic_vector(1 downto 0);
     begin
     -----
       --wb_hpm_done    <= '1';
----   Quad mode command = 0x6B - QOFR Read - 0xEBh
       --SPI_cmd <= --  "01101011";
                  -- 0101 1 000100 0
       QUAD_SPI_CMD_NM_24_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
       begin
           SPI_cmd <= "11101011"; -- QIOFR
                  -- 0101 1 100100 0
           wb_hpm_done <= '1';
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        case wb_hpm_done is
                            -- when "00"|"01" => -- write enable is under process
                            when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- when "01"   => -- Enable 4 byte addressing is under process
                            --                Data_Dir            <= '0';                  
                            --                Data_Mode_1         <= '0';                  
                            --                Data_Mode_0         <= '0';                  
                            --                Data_Phase          <= '0';                  
                            --                --------------------                         
                            --                Quad_Phase          <= '0';-- permanent '0'  
                            --                --------------------                         
                            --                Addr_Mode_1         <= '0';                  
                            --                Addr_Mode_0         <= '0';                  
                            --                Addr_Bit            <= '0';                  
                            --                Addr_Phase          <= '0';                  
                            --                --------------------                         
                            --                CMD_Mode_1          <= '0';                  
                            --                CMD_Mode_0          <= '0';                  
                            -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                            when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '1';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '1';                  
                                           --------------------                         
                                           Quad_Phase          <= '1';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '1';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage off
                            when others => 
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage on
                        end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         --------------------------------

       end generate QUAD_SPI_CMD_NM_24_GEN;
       
       QUAD_SPI_CMD_NM_32_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
       begin
           SPI_cmd <= "11101100"; -- QIOFR_4Byte 0xECh
                  -- 0101 1 100100 0
       end generate QUAD_SPI_CMD_NM_32_GEN;

       NM_EN_32_ADDR_MD_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
       begin
       -----
          nm_wr_en_CMD         <= "00000110"; -- 0x06 h Write Enable
          nm_4byte_addr_en_CMD <= "10110111"; -- 0xB7 h Enable 4 Byte Addressing Mode
          ----------------------------------------------------
          NM_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
          -----
          begin
          -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                  if(Rst_to_spi = RESET_ACTIVE) then
                      nm_wr_en_cntrl_ps      <= NM_WR_EN_IDLE;
                      wr_en_under_process_d1 <= '0';
                wr_en_done_reg         <= '0';
                  else
                      nm_wr_en_cntrl_ps      <= nm_wr_en_cntrl_ns;
                      wr_en_under_process_d1 <= wr_en_under_process;
                wr_en_done_reg         <= wr_en_done;
       
                  end if;
              end if;
          end process NM_PS_TO_NS_PROCESS;
          ----------------------------------
          --
          NM_WR_EN_CNTRL_PROCESS: process(
                                         nm_wr_en_cntrl_ps     ,
                                         --SPIXfer_done_int_pulse,
                                         --SPIXfer_done_int      ,
                                         Rst_to_spi            ,
                                         SR_5_Tx_Empty         ,
                                   wr_en_done_reg
                                         ) is
          -----
          begin
          -----
               --load_wr_en_cmd <= '0';
               --load_wr_sr_cmd <= '0';
               --load_wr_sr_d0  <= '0';
               --load_wr_sr_d1  <= '0';
               load_wr_en    <= '0';
               wr_en_done    <= '0';
               wr_en_under_process <= '0';
               case nm_wr_en_cntrl_ps is
                   when NM_WR_EN_IDLE => --load_wr_en_cmd <= '1';
                                       load_wr_en          <= '1';
                                       wr_en_under_process <= '1';
                                       nm_wr_en_cntrl_ns   <= NM_WR_EN;
                   when NM_WR_EN      => if (SR_5_Tx_Empty = '1')then
                                             --wr_en_done <= '1';
                                             nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                         else
                                             --wr_en_under_process <= '1';
                                             nm_wr_en_cntrl_ns <= NM_WR_EN;
                                         end if;
                                         wr_en_done          <= SR_5_Tx_Empty;
                                         wr_en_under_process <= not SR_5_Tx_Empty;
       
                   when NM_WR_EN_DONE => if (Rst_to_spi = '1') then
                                             nm_wr_en_cntrl_ns <= NM_WR_EN_IDLE;
                                         else
                                             nm_wr_en_cntrl_ns <= NM_WR_EN_DONE;
                                         end if;
                                         wr_en_done <= wr_en_done_reg;
               end case;
          end process NM_WR_EN_CNTRL_PROCESS;
       
            ----------------------------------------------------
            NM_4_BYTE_PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
            -----
            begin
            -----
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                    if(Rst_to_spi = RESET_ACTIVE) then
                        nm_sm_4_byte_addr_ps           <= NM_32_BIT_IDLE;
                        --four_byte_addr_under_process_d1 <= '0';
                  hpm_under_process_d1   <= '0';
                  wr_en_done_d1          <= '0';
                  wr_en_done_d2          <= '0';
                  wb_hpm_done_reg        <= '0';
                    else
                        nm_sm_4_byte_addr_ps   <= nm_sm_4_byte_addr_ns;
                        hpm_under_process_d1   <= hpm_under_process;
                        --four_byte_en_done_reg           <= four_byte_en_done;   
                  wr_en_done_d1          <= wr_en_done_reg; -- wr_en_done;
                  wr_en_done_d2          <= wr_en_done_d1;
                  wb_hpm_done_reg        <= wb_hpm_done;
                    end if;
                end if;
            end process NM_4_BYTE_PS_TO_NS_PROCESS;
            ----------------------------------
            --
            NM_4_BYTE_ADDR_EN_PROCESS: process(
                                               nm_sm_4_byte_addr_ps  ,
                                               Rst_to_spi            ,
                                               SR_5_Tx_Empty         ,
                                               wr_en_done_d2         ,
                                         wb_hpm_done_reg
                                              ) is
            -----
            begin
            -----
                 -- load_4_byte_addr_en     <= '0';
           load_wr_hpm <= '0';
                 wb_hpm_done <= '0';
           hpm_under_process <= '0';
                 four_byte_en_done          <= '0';
                 four_byte_en_under_process <= '0';
                 case nm_sm_4_byte_addr_ps is
                     when NM_32_BIT_IDLE     => if (wr_en_done_d2 = '1') then
                                              --load_wr_hpm <= '1';
                                              --hpm_under_process <= '1';
                                                    nm_sm_4_byte_addr_ns      <= NM_32_BIT_EN;
                                                else
                                                    nm_sm_4_byte_addr_ns      <= NM_32_BIT_IDLE;
                                                end if;
                                          load_wr_hpm       <= wr_en_done_d2; 
                                          hpm_under_process <= wr_en_done_d2;
            
                     when NM_32_BIT_EN      => if (SR_5_Tx_Empty = '1') then
                                             -- wb_hpm_done        <= '1';
                                             nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                         else
                                             -- hpm_under_process  <= '1';
                                                   nm_sm_4_byte_addr_ns <= NM_32_BIT_EN;
                                         end if;
                                               wb_hpm_done        <= SR_5_Tx_Empty;
                                         hpm_under_process  <= not(SR_5_Tx_Empty);
               when NM_32_BIT_EN_DONE => if(Rst_to_spi = '1')then
                                                   nm_sm_4_byte_addr_ns <= NM_32_BIT_IDLE;
                                               else
                                                 --  if (SR_5_Tx_Empty = '1')then
                                                 --      --four_byte_en_done          <= '1';
                                           --      wb_hpm_done <= '1';
                                                 --  else
                                                 --      -- four_byte_en_under_process <= '1';
                                           --      hpm_under_process <= '1';
                                                 --  end if;
                                                 --  four_byte_en_done     <= four_byte_en_done_reg;     
                                                   -- wb_hpm_done <= '1';
                                             nm_sm_4_byte_addr_ns <= NM_32_BIT_EN_DONE;
                                               end if;
                                               wb_hpm_done <= wb_hpm_done_reg;
            
                 end case;
            end process NM_4_BYTE_ADDR_EN_PROCESS;
            --------------------------------------
         DRIVE_CONTROL_SIG_P: process(EXT_SPI_CLK) is -- wb_hpm_done, wr_en_done_reg) is
         variable temp: std_logic_vector(1 downto 0);
         begin
                temp := wb_hpm_done & wr_en_done_reg;
                if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                        case wb_hpm_done is
                            -- when "00"|"01" => -- write enable is under process
                            when '0'       => -- write enable and/or Enable 4 byte addressing is under process
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- when "01"   => -- Enable 4 byte addressing is under process
                            --                Data_Dir            <= '0';                  
                            --                Data_Mode_1         <= '0';                  
                            --                Data_Mode_0         <= '0';                  
                            --                Data_Phase          <= '0';                  
                            --                --------------------                         
                            --                Quad_Phase          <= '0';-- permanent '0'  
                            --                --------------------                         
                            --                Addr_Mode_1         <= '0';                  
                            --                Addr_Mode_0         <= '0';                  
                            --                Addr_Bit            <= '0';                  
                            --                Addr_Phase          <= '0';                  
                            --                --------------------                         
                            --                CMD_Mode_1          <= '0';                  
                            --                CMD_Mode_0          <= '0';                  
                            -- when "10"   => -- write enable is done and enable 4 byte addressing is also done
                            when '1'       => -- write enable and enable 4 byte addressing is also done
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '1';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '1';                  
                                           --------------------                         
                                           Quad_Phase          <= '1';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '1';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '1';                  
                                           Addr_Phase          <= '1';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage off
                            when others => 
                                           Data_Dir            <= '0';                  
                                           Data_Mode_1         <= '0';                  
                                           Data_Mode_0         <= '0';                  
                                           Data_Phase          <= '0';                  
                                           --------------------                         
                                           Quad_Phase          <= '0';-- permanent '0'  
                                           --------------------                         
                                           Addr_Mode_1         <= '0';                  
                                           Addr_Mode_0         <= '0';                  
                                           Addr_Bit            <= '0';                  
                                           Addr_Phase          <= '0';                  
                                           --------------------                         
                                           CMD_Mode_1          <= '0';                  
                                           CMD_Mode_0          <= '0';                  
                            -- coverage on
                        end case;
                end if;
         end process DRIVE_CONTROL_SIG_P;
         --------------------------------
       end generate NM_EN_32_ADDR_MD_GEN;
       -------------------------------------
       -- Data_Dir            <= '0';
       -- Data_Mode_1         <= '1';
       -- Data_Mode_0         <= '0';
       -- Data_Phase          <= '1';
       -- --------------------
       -- Quad_Phase          <= '1';-- for NM this is 0
       -- --------------------
       -- Addr_Mode_1         <= '1';
       -- Addr_Mode_0         <= '0';
       -- Addr_Bit            <= '0';
       -- Addr_Phase          <= '1';
       -- --------------------
       -- CMD_Mode_1          <= '0';
       -- CMD_Mode_0          <= '0';
       
       ---------------------------------------------------------------------
       -- RECEIVE_DATA_STROBE_PROCESS : Strobe data from shift register to receive
       --                               data register
       --------------------------------
       -- For a SCK ratio of 2 the Done needs to be delayed by an extra cycle
       -- due to the serial input being captured on the falling edge of the PLB
       -- clock. this is purely required for dealing with the real SPI slave memories.
         --RECEIVE_DATA_NM_GEN: if C_SPI_MEMORY = 2 and C_SPI_MODE /=0 generate
         --begin
         -----
         RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
         -----
         begin
         -----
             if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
                if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                        receive_Data_int  <= (others => '0');
              elsif(SPIXfer_done_int_pulse = '1') then
                      receive_Data_int  <= rx_shft_reg_mode_0011;
              elsif(SPIXfer_done_int_pulse_d1 = '1') then
					  receive_Data_int <= receive_Data_int
                                         ((C_NUM_TRANSFER_BITS-5) downto 0) &
                                                                  IO3_I &  -- MSB first
                                                                  IO2_I &
                                                                  IO1_I &
                                                                  IO0_I ;
                end if;
             end if;
         end process RECEIVE_DATA_STROBE_PROCESS;
         --end generate RECEIVE_DATA_NM_GEN;
       -----------------------------------------------------------------------------
       CMD_ADDR_NM_24_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
       begin
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 5 transactions are of
         --                  CMD, A0, A1, A2. Total 4 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 4 bytes are transferred.
         --                  below counter is for that purpose only. This is for 24 bit addressing of NM memories only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         -----
         begin
         -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1')               or
                    (load_axi_data_to_spi_clk = '1') or
                    (store_last_b4_wrap = '1') then
                      cmd_addr_cntr <= "0000";--(others => '1');
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1')then
                      cmd_addr_cntr <= "0000";
                      cmd_addr_sent <= store_last_b4_wrap;
                  elsif(SPIXfer_done_int_pulse_d2 = '1')then
                      if(cmd_addr_cntr = "0110")then
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "0001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
       end generate CMD_ADDR_NM_24_BIT_GEN;
       ------------------------------------
       CMD_ADDR_NM_32_BIT_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
       begin
         -- CMD_ADDR_CNTR_P: in each SPI transaction, the firs 6 transactions are of
         --                  CMD, A0, A1, A2, A3. Total 5 bytes need to be removed from the
         --                  calculation of total no. of pure data bytes.
         --                  the actual data from the SPI memory will be stored in the
         --                  receive FIFO only when the first 5 bytes are transferred.
         --                  below counter is for that purpose only. This is for 32 bit addressing of NM memories only.
         CMD_ADDR_CNTR_P:process(EXT_SPI_CLK)is
         -----
         begin
         -----
              if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
                  if(Rst_to_spi = '1')               or
                    (load_axi_data_to_spi_clk = '1') or
                    (store_last_b4_wrap = '1') then
                      cmd_addr_cntr <= "0000";--(others => '1');
                      cmd_addr_sent <= '0';
                  elsif(pr_state_idle = '1')then
                      cmd_addr_cntr <= "0000";
                      cmd_addr_sent <= store_last_b4_wrap;
                  elsif(SPIXfer_done_int_pulse_d2 = '1')then
                      if(cmd_addr_cntr = "0111")then -- note the differene in counter value
                          cmd_addr_sent <= '1';
                      else
                          cmd_addr_cntr <= cmd_addr_cntr + "0001";
                          cmd_addr_sent <= '0';
                      end if;
                  end if;
              end if;
         end process CMD_ADDR_CNTR_P;
       end generate CMD_ADDR_NM_32_BIT_GEN;
       ------------------------------------
       TWO_BIT_CNTR_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(load_axi_data_to_spi_clk = '1') or (start_after_wrap = '1') then
               hw_wd_cntr <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1')then
               hw_wd_cntr <= hw_wd_cntr + "01";
           end if;
       end if;
       end process TWO_BIT_CNTR_P;
       ---------------------------       
       STORE_RX_DATA_SPI_CLK_P:process(EXT_SPI_CLK)is
       begin
       -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1')then
           if(load_axi_data_to_spi_clk = '1') then
               Data_To_Rx_FIFO_int <= (others => '0');
           elsif(SPIXfer_done_int_pulse_d2 = '1') and (cmd_addr_sent = '1') then
               if(one_byte_xfer_to_spi_clk = '1') then
                  case spi_addr_i(1 downto 0) is
                       when "00" =>
                                   Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 8) &
                                                          receive_Data_int;
                       when "01" =>
                                   Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 16)&
                                                          receive_Data_int                 &
                                                          Data_To_Rx_FIFO_int(7 downto 0);
                       when "10" =>
                                   Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(31 downto 24)&
                                                          receive_Data_int                 &
                                                          Data_To_Rx_FIFO_int(15 downto 0);
                       when "11" =>
                                   Data_To_Rx_FIFO_int <= receive_Data_int                 &
                                                          Data_To_Rx_FIFO_int(23 downto 0);
                       when others => null;
                  end case;
               elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '0') then  -- adjustment for half word
                  if(spi_addr_i(1) = '0') then
                      Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);-- & receive_Data_int;
                      Data_To_Rx_FIFO_int(15 downto 0)  <= receive_Data_int & Data_To_Rx_FIFO_int(15 downto 8);-- & receive_Data_int;
                  else
                      Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);-- & receive_Data_int;
                      Data_To_Rx_FIFO_int(31 downto 16)<= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 24);-- & receive_Data_int;
                  end if;
               elsif (two_byte_xfer_to_spi_clk = '1') and (type_of_burst_to_spi_clk = '1') then  -- adjustment for half word
                  if(hw_wd_cntr = "00") then -- fill in D0
                      Data_To_Rx_FIFO_int(31 downto 8) <= Data_To_Rx_FIFO_int(31 downto 8);
                      Data_To_Rx_FIFO_int(7 downto 0)  <= receive_Data_int;
                  elsif(hw_wd_cntr = "01")then -- fill in D1
                      Data_To_Rx_FIFO_int(31 downto 16) <= Data_To_Rx_FIFO_int(31 downto 16);
                      Data_To_Rx_FIFO_int(15 downto 8)  <= receive_Data_int;
                      Data_To_Rx_FIFO_int(7 downto 0) <= Data_To_Rx_FIFO_int(7 downto 0);
                  elsif(hw_wd_cntr = "10")then -- fill in D2
                      Data_To_Rx_FIFO_int(31 downto 24) <= Data_To_Rx_FIFO_int(31 downto 24);
                      Data_To_Rx_FIFO_int(23 downto 16)  <= receive_Data_int;
                      Data_To_Rx_FIFO_int(15 downto 0) <= Data_To_Rx_FIFO_int(15 downto 0);
                  else
                      Data_To_Rx_FIFO_int(31 downto 24) <= receive_Data_int;
                      Data_To_Rx_FIFO_int(23 downto 0) <= Data_To_Rx_FIFO_int(23 downto 0);
                  end if;
               else   -- adjustment for complete word
                  --Data_To_Rx_FIFO_int <= Data_To_Rx_FIFO_int(23 downto 0) & receive_Data_int;
                  Data_To_Rx_FIFO_int <= receive_Data_int & Data_To_Rx_FIFO_int(31 downto 8);
               end if;
           end if;
          end if;
          end process STORE_RX_DATA_SPI_CLK_P;
          ----------------------------
          Data_To_Rx_FIFO <= Data_To_Rx_FIFO_int;
          ---------------------------------------

     --------------------------------
     end generate SP_MEM_QUAD_MD_GEN;

end generate QUAD_MODE_CONTROL_GEN;

WRAP_DELAY_P:process(EXT_SPI_CLK)is
begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) or (load_axi_data_to_spi_clk = '1') then
              wrap_around_d1 <= '0';
              wrap_around_d2 <= '0';
              wrap_around_d3 <= '0';
              --wrap_around_d4 <= '0';
          else
              wrap_around_d1 <= wrap_around;
              wrap_around_d2 <= wrap_around_d1;
              wrap_around_d3 <= wrap_around_d2;
              --wrap_around_d4 <= wrap_around_d3;
          end if;
      end if;
end process WRAP_DELAY_P;
wrap_ack         <= (not wrap_around_d2) and wrap_around_d1;
wrap_ack_1       <= (not wrap_around_d3) and wrap_around_d2;
start_after_wrap <= wrap_around_d2 and (not wrap_around_d1) and not SR_5_Tx_Empty;
store_last_b4_wrap    <= wrap_around_d3 and (not wrap_around_d2);
--xsfer_start_aftr_wrap <= wrap_around_d4 and (not wrap_around_d3);
DELAY_START_AFTR_WRAP:process(EXT_SPI_CLK)is
begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) then
                start_after_wrap_d1 <= '0';
          else
                start_after_wrap_d1 <= start_after_wrap;
          end if;
      end if;
end process DELAY_START_AFTR_WRAP;
----------------------------------
TRANSFER_START_24_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
begin
-----
TRANSFER_START_P:process(EXT_SPI_CLK)is
begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) then
              transfer_start <= '0';
          elsif(wrap_around = '1') then -- and (actual_SPIXfer_done_int = '1')then
              transfer_start <= '0';
          elsif(hpm_under_process_d1 = '1' and wb_hpm_done = '1')-- or 
               --(wr_en_under_process_d1 = '1' and wr_en_done = '1')
               then
              transfer_start <= '0';
          elsif   (load_axi_data_to_spi_clk = '1') 
               or (start_after_wrap_d1 = '1')      
               or (load_wr_hpm = '1')              
               --or (load_wr_en = '1') 
               then
              transfer_start <= '1';
          elsif(SR_5_Tx_Empty_int = '1') then
              transfer_start <= '0';
          end if;
      end if;
end process TRANSFER_START_P;
end generate TRANSFER_START_24_BIT_ADDR_GEN;

TRANSFER_START_32_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
begin
-----
TRANSFER_START_P:process(EXT_SPI_CLK)is
begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) then
              transfer_start <= '0';
          elsif(wrap_around = '1') then -- and (actual_SPIXfer_done_int = '1')then
              transfer_start <= '0';
          elsif(hpm_under_process_d1 = '1' and wb_hpm_done = '1') or 
               (wr_en_under_process_d1 = '1' and wr_en_done = '1')then
              transfer_start <= '0';
          elsif(load_axi_data_to_spi_clk = '1') or
               (start_after_wrap_d1 = '1')      or
               (load_wr_hpm = '1')              or
               (load_wr_en = '1') then
              transfer_start <= '1';
          elsif(SR_5_Tx_Empty_int = '1') then
              transfer_start <= '0';
          end if;
      end if;
end process TRANSFER_START_P;
end generate TRANSFER_START_32_BIT_ADDR_GEN;

-------------------------------------------------------------------------------
-- TRANSFER_START_1CLK_PROCESS : Delay transfer start by 1 clock cycle
--------------------------------
TRANSFER_START_1CLK_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) or (load_axi_data_to_spi_clk = '1') then
            transfer_start_d1 <= '0';
            transfer_start_d2 <= '0';
            transfer_start_d3 <= '0';
        else
            transfer_start_d1 <= transfer_start;
            transfer_start_d2 <= transfer_start_d1;
            transfer_start_d3 <= transfer_start_d2;
        end if;
    end if;
end process TRANSFER_START_1CLK_PROCESS;

transfer_start_pulse <= --transfer_start and (not transfer_start_d1);
                        --transfer_start_d2 and (not transfer_start_d3);
                        transfer_start and (not(transfer_start_d1));

    -------------------------------------------------------------------------------
    -- TRANSFER_DONE_1CLK_PROCESS : Delay SPI transfer done signal by 1 clock cycle
    -------------------------------
    TRANSFER_DONE_1CLK_PROCESS: process(EXT_SPI_CLK)is
    -----
    begin
    -----
        if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
            if(Rst_to_spi = RESET_ACTIVE) or (load_axi_data_to_spi_clk = '1') then
                SPIXfer_done_int_d1 <= '0';
            else
                SPIXfer_done_int_d1 <= SPIXfer_done_int;
            end if;
        end if;
    end process TRANSFER_DONE_1CLK_PROCESS;
    --
    -- transfer done pulse generating logic
    SPIXfer_done_int_pulse <= SPIXfer_done_int and (not(SPIXfer_done_int_d1));

    -------------------------------------------------------------------------------
    -- TRANSFER_DONE_PULSE_DLY_PROCESS : Delay SPI transfer done pulse by 1 and 2
    --                                   clock cycles
    ------------------------------------
    -- Delay the Done pulse by a further cycle. This is used as the output Rx
    -- data strobe when C_SCK_RATIO = 2
    TRANSFER_DONE_PULSE_DLY_PROCESS: process(EXT_SPI_CLK)is
    -----
    begin
    -----
        if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
            if(Rst_to_spi = RESET_ACTIVE) or (load_axi_data_to_spi_clk = '1') then
                SPIXfer_done_int_pulse_d1 <= '0';
                SPIXfer_done_int_pulse_d2 <= '0';
                SPIXfer_done_int_pulse_d3 <= '0';
            else
                SPIXfer_done_int_pulse_d1 <= SPIXfer_done_int_pulse;
                SPIXfer_done_int_pulse_d2 <= SPIXfer_done_int_pulse_d1;
                SPIXfer_done_int_pulse_d3 <= SPIXfer_done_int_pulse_d2;
            end if;
        end if;
    end process TRANSFER_DONE_PULSE_DLY_PROCESS;
--------------------------------------------
-------------------------------------------------------------------------------
-- RX_DATA_GEN1: Only for C_SCK_RATIO = 2 mode.
----------------
-- RX_DATA_SCK_RATIO_2_GEN1 : if C_SCK_RATIO = 2 generate
-----
-- begin
-----
  -------------------------------------------------------------------------------
  -- TRANSFER_DONE_PROCESS : Generate SPI transfer done signal. This will stop the SPI clock.
  --------------------------
  TRANSFER_DONE_PROCESS: process(EXT_SPI_CLK)is
  -----
  begin
  -----
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) then
              SPIXfer_done_int <= '0';
          elsif(transfer_start_pulse = '1') then
              SPIXfer_done_int <= '0';
          else
              if(mode_1 = '1' and mode_0 = '0')then
                      SPIXfer_done_int <= Count(1) and
                                          not(Count(0));
              elsif(mode_1 = '0' and mode_0 = '1')then
                      SPIXfer_done_int <= not(Count(0)) and
                                              Count(2)  and
                                              Count(1);
              else
                      SPIXfer_done_int <= --Count(COUNT_WIDTH);
                                            Count(COUNT_WIDTH-1) and
                                            Count(COUNT_WIDTH-2) and
                                            Count(COUNT_WIDTH-3) and
                                            not Count(COUNT_WIDTH-4);
              end if;
          end if;
      end if;
  end process TRANSFER_DONE_PROCESS;

-- -- RECEIVE_DATA_STROBE_PROCESS : Strobe data from shift register to receive
-- --                               data register
-- --------------------------------
-- -- For a SCK ratio of 2 the Done needs to be delayed by an extra cycle
-- -- due to the serial input being captured on the falling edge of the PLB
-- -- clock. this is purely required for dealing with the real SPI slave memories.
--   RECEIVE_DATA_NM_GEN: if C_SPI_MEMORY = 2 and C_SPI_MODE /=0 generate
--   begin
--   -----
--   RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
--   -----
--   begin
--   -----
--       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
--          if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
--                  receive_Data_int  <= (others => '0');
--          elsif(SPIXfer_done_int_pulse_d1 = '1') then -- and (cmd_addr_sent = '1')then
--                  receive_Data_int  <= rx_shft_reg_mode_0011;
--          end if;
--       end if;
--   end process RECEIVE_DATA_STROBE_PROCESS;
--   end generate RECEIVE_DATA_NM_GEN;
--   -----------------------------------------------------------------------------

--  -----------------------------------------------------------------------------
--  RECEIVE_DATA_WB_GEN: if C_SPI_MEMORY = 1 and C_SPI_MODE /=0 generate
--  begin
--  -----
--  RECEIVE_DATA_STROBE_PROCESS: process(EXT_SPI_CLK)
--  -----
--  begin
--  -----
--      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
--         if(load_axi_data_to_spi_clk = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
--                 receive_Data_int  <= (others => '0');
--         elsif(SPIXfer_done_int_pulse_d1 = '1') and (cmd_addr_sent = '1')then
--                 receive_Data_int  <= rx_shft_reg_mode_0011;
--         end if;
--      end if;
--  end process RECEIVE_DATA_STROBE_PROCESS;
--  end generate RECEIVE_DATA_WB_GEN;

-----------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- RATIO_OF_2_GENERATE : Logic to be used when C_SCK_RATIO is equal to 2
------------------------
RATIO_OF_2_GENERATE: if(C_SCK_RATIO = 2) generate
--------------------
---------------attribute IOB                                   : string;
---------------attribute IOB of QSPI_SCK_T        : label is "true";

begin
-----
-------------------------------------------------------------------------------
-- SCK_CYCLE_COUNT_PROCESS : Counts number of trigger pulses provided. Used for
--                           controlling the number of bits to be transfered
--                           based on generic C_NUM_TRANSFER_BITS
----------------------------
  RATIO_2_SCK_CYCLE_COUNT_PROCESS: process(EXT_SPI_CLK)is
  begin

    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) or (transfer_start = '0') or (store_last_b4_wrap = '1') then -- (wrap_ack_1 = '1')then
            Count <= (others => '0');
        elsif(SPIXfer_done_int = '1')then
            Count <= (others => '0');
        elsif((Count(COUNT_WIDTH) = '0') and
              ((CPOL_to_spi_clk and CPHA_to_spi_clk) = '0')) then
            Count <=  Count + 1;
        elsif(transfer_start_d2 = '1') and (Count(COUNT_WIDTH) = '0') then
            Count <=  Count + 1;
        end if;
    end if;
  end process RATIO_2_SCK_CYCLE_COUNT_PROCESS;
  ------------------------------------

SCK_SET_RESET_32_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate
begin
    -------------------------------------------------------------------------------
    -- SCK_SET_GEN_PROCESS : Generate SET control for SCK_O_reg
    ------------------------
    SCK_SET_GEN_PROCESS: process(CPOL_to_spi_clk,
                                 CPHA_to_spi_clk,
                                 SPIXfer_done_int,
                                 transfer_start_pulse,--,
                                 load_axi_data_to_spi_clk,
                                 wrap_ack_1,
                                 load_wr_hpm,
                                 load_wr_en
                                 ) is
    -----
    begin
    -----
        if(SPIXfer_done_int = '1')or(load_axi_data_to_spi_clk = '1') or (load_wr_hpm = '1') or (load_wr_en = '1')then
            Sync_Set <= (CPOL_to_spi_clk xor CPHA_to_spi_clk);
        else
            Sync_Set <= '0';
        end if;
    end process SCK_SET_GEN_PROCESS;

    -------------------------------------------------------------------------------
    -- SCK_RESET_GEN_PROCESS : Generate SET control for SCK_O_reg
    --------------------------
    SCK_RESET_GEN_PROCESS: process(CPOL_to_spi_clk,
                                   CPHA_to_spi_clk,
                                   transfer_start_pulse,
                                   SPIXfer_done_int,
                                   load_axi_data_to_spi_clk,
                                   load_wr_hpm,
                                   load_wr_en
                                   )is
    -----
    begin
    -----
        if(SPIXfer_done_int = '1')or(load_axi_data_to_spi_clk = '1')or(load_wr_hpm = '1') or (load_wr_en = '1') then
            Sync_Reset <= not(CPOL_to_spi_clk xor CPHA_to_spi_clk);
        else
            Sync_Reset <= '0';
        end if;
    end process SCK_RESET_GEN_PROCESS;

end generate SCK_SET_RESET_32_BIT_ADDR_GEN;
-------------------------------------------
SCK_SET_RESET_24_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate
begin
    -------------------------------------------------------------------------------
    -- SCK_SET_GEN_PROCESS : Generate SET control for SCK_O_reg
    ------------------------
    SCK_SET_GEN_PROCESS: process(CPOL_to_spi_clk,
                                 CPHA_to_spi_clk,
                                 SPIXfer_done_int,
                                 transfer_start_pulse,--,
                                 load_axi_data_to_spi_clk,
                                 wrap_ack_1,
                                 load_wr_hpm--,
                                 --load_wr_en
                                 ) is
    -----
    begin
    -----
        if(SPIXfer_done_int = '1')or(load_axi_data_to_spi_clk = '1') or (load_wr_hpm = '1') 
        --or (load_wr_en = '1')
        then
            Sync_Set <= (CPOL_to_spi_clk xor CPHA_to_spi_clk);
        else
            Sync_Set <= '0';
        end if;
    end process SCK_SET_GEN_PROCESS;

    -------------------------------------------------------------------------------
    -- SCK_RESET_GEN_PROCESS : Generate SET control for SCK_O_reg
    --------------------------
    SCK_RESET_GEN_PROCESS: process(CPOL_to_spi_clk,
                                   CPHA_to_spi_clk,
                                   transfer_start_pulse,
                                   SPIXfer_done_int,
                                   load_axi_data_to_spi_clk,
                                   load_wr_hpm--,
                                   --load_wr_en
                                   )is
    -----
    begin
    -----
        if(SPIXfer_done_int = '1')or(load_axi_data_to_spi_clk = '1')or(load_wr_hpm = '1')
          --or (load_wr_en = '1') 
          then
            Sync_Reset <= not(CPOL_to_spi_clk xor CPHA_to_spi_clk);
        else
            Sync_Reset <= '0';
        end if;
    end process SCK_RESET_GEN_PROCESS;

end generate SCK_SET_RESET_24_BIT_ADDR_GEN;
-------------------------------------------

  -------------------------------------------------------------------------------
  -- SCK_SET_RESET_PROCESS : Sync set/reset toggle flip flop controlled by
  --                         transfer_start signal
  --------------------------
  RATIO_2_SCK_SET_RESET_PROCESS: process(EXT_SPI_CLK)
  begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if((Rst_to_spi = RESET_ACTIVE) or (Sync_Reset = '1') or
             (new_tr = '0') or (wrap_ack_1 = '1')) then
              sck_o_int <= '0';
          elsif(Sync_Set = '1') then
              sck_o_int <= '1';
          elsif (transfer_start = '1') then
              sck_o_int <= (not sck_o_int);
          end if;
      end if;
  end process RATIO_2_SCK_SET_RESET_PROCESS;
  ----------------------------------

      -- DELAY_CLK: Delay the internal clock for a cycle to generate internal enable
    --         -- signal for data register.
    -------------
    RATIO_2_DELAY_CLK: process(EXT_SPI_CLK)is
    -----
    begin
    -----
       if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if (Rst_to_spi = RESET_ACTIVE)then
             sck_d1 <= '0';
             sck_d2 <= '0';
          else
             sck_d1 <= sck_o_int;
             sck_d2 <= sck_d1;
          end if;
       end if;
    end process RATIO_2_DELAY_CLK;
    ------------------------------------
    -- Rising egde pulse
    sck_rising_edge <= sck_d2 and (not sck_d1);

  --   CAPT_RX_FE_MODE_00_11: The below logic is to capture data for SPI mode of
  --------------------------- 00 and 11.
  -- Generate a falling edge pulse from the serial clock. Use this to
  -- capture the incoming serial data into a shift register.
  RATIO_2_CAPT_RX_FE_MODE_00_11 : process(EXT_SPI_CLK)is
  begin
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then -- SPIXfer_done_int_pulse_d2
          if (Rst_to_spi = RESET_ACTIVE) then --  or (wrap_ack_1 = '1')then
                  rx_shft_reg_mode_0011 <= (others => '0');
          elsif((sck_d2='0') and --(sck_rising_edge = '1') and
                (Data_Dir='0')  -- data direction = 0 is read mode
               )then
               -------
               if(mode_1 = '0' and mode_0 = '0')then    -- for Standard transfer
                      rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                         (1 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I ; --MISO_I;
               elsif(mode_1 = '0' and mode_0 = '1')then -- for Dual transfer
                      rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                         (2 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO1_I &  -- MISO_I - MSB first
                                                                  IO0_I ;  -- MOSI_I
               elsif(mode_1 = '1' and mode_0 = '0')then -- for Quad transfer
                      rx_shft_reg_mode_0011 <= rx_shft_reg_mode_0011
                                         (4 to (C_NUM_TRANSFER_BITS-1)) &
                                                                  IO3_I &  -- MSB first
                                                                  IO2_I &
                                                                  IO1_I &
                                                                  IO0_I ;
               end if;
               -------
          else
             rx_shft_reg_mode_0011<= rx_shft_reg_mode_0011;
          end if;
      end if;
  end process RATIO_2_CAPT_RX_FE_MODE_00_11;
  ----------------------------------
  QSPI_NM_MEM_DATA_CAP_GEN: if (C_SPI_MODE = 0 and (C_SPI_MEMORY = 0 or
                                                                 C_SPI_MEMORY = 2))
                                              or
                                              (
                                               ( C_SPI_MODE = 1
                                                 or
                                                 C_SPI_MODE = 2
                                               )
                                               and
                                               C_SPI_MEMORY = 2
                                             )generate
  --------------------------------------
  begin
  -----
  -------------------------------------------------------------------------------
  -- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
  --                             capture and shift operation for serial data in
  ------------------------------ master SPI mode only
  RATIO_2_CAPTURE_AND_SHIFT_PROCESS: process(EXT_SPI_CLK)is
  begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          elsif(transfer_start = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then --
              --if(Load_tx_data_to_shift_reg_int = '1') then
                      Shift_Reg   <= Transmit_Data;
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= Quad_Phase;--pr_state_cmd_ph and Quad_Phase;-- this is to make the DQ3 bit 1 in quad command transfer mode.
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              elsif(
                    (Count(0) = '0')
                    )then -- Shift Data on even
                  if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                  elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                  elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                  end if;
              elsif(
                    (Count(0) = '1')       --and
                    ) then -- Capture Data on odd
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                           Shift_Reg <= Shift_Reg
                                        (1 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I ;-- MISO_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                        (2 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I &
                                                                IO0_I ;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                        (4 to C_NUM_TRANSFER_BITS -1) &
                                                                IO3_I &
                                                                IO2_I &
                                                                IO1_I &
                                                                IO0_I ;
                      end if;
              end if;
          end if;
      end if;
  end process RATIO_2_CAPTURE_AND_SHIFT_PROCESS;
  ----------------------------------------------
  end generate QSPI_NM_MEM_DATA_CAP_GEN;
  ----------------------------------
  QSPI_SP_MEM_DATA_CAP_GEN: if (C_SPI_MODE = 0 and (C_SPI_MEMORY = 0 or
                                                                 C_SPI_MEMORY = 3))
                                              or
                                              (
                                               ( C_SPI_MODE = 1
                                                 or
                                                 C_SPI_MODE = 2
                                               )
                                               and
                                               C_SPI_MEMORY = 3
                                             )generate
  --------------------------------------
  begin
  -----
  -------------------------------------------------------------------------------
  -- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
  --                             capture and shift operation for serial data in
  ------------------------------ master SPI mode only
  RATIO_2_CAPTURE_AND_SHIFT_PROCESS: process(EXT_SPI_CLK)is
  begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          elsif(transfer_start = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then --
              --if(Load_tx_data_to_shift_reg_int = '1') then
                      Shift_Reg   <= Transmit_Data;
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= Quad_Phase;--pr_state_cmd_ph and Quad_Phase;-- this is to make the DQ3 bit 1 in quad command transfer mode.
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              elsif(
                    (Count(0) = '0')
                    )then -- Shift Data on even
                  if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                  elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                  elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                  end if;
              elsif(
                    (Count(0) = '1')       --and
                    ) then -- Capture Data on odd
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                           Shift_Reg <= Shift_Reg
                                        (1 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I ;-- MISO_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                        (2 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I &
                                                                IO0_I ;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                        (4 to C_NUM_TRANSFER_BITS -1) &
                                                                IO3_I &
                                                                IO2_I &
                                                                IO1_I &
                                                                IO0_I ;
                      end if;
              end if;
          end if;
      end if;
  end process RATIO_2_CAPTURE_AND_SHIFT_PROCESS;
  ----------------------------------------------
  end generate QSPI_SP_MEM_DATA_CAP_GEN;
  ----------------------------------

  QSPI_WINBOND_MEM_DATA_CAP_GEN: if (
                                     (C_SPI_MODE = 0 and (C_SPI_MEMORY = 0 or
                                                             C_SPI_MEMORY = 1))
                                     or
                                     (
                                       ( C_SPI_MODE = 1
                                        or
                                        C_SPI_MODE = 2
                                       )
                                          and
                                      C_SPI_MEMORY = 1
                                     )) generate
  -----------------------------------------
  begin
  -----
  -------------------------------------------------------------------------------
  -- CAPTURE_AND_SHIFT_PROCESS : This logic essentially controls the entire
  --                             capture and shift operation for serial data in
  ------------------------------ master SPI mode only
  RATIO_2_CAPTURE_AND_SHIFT_PROCESS: process(EXT_SPI_CLK)is
  begin
      if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
          if(Rst_to_spi = RESET_ACTIVE) then
              Shift_Reg(0 to C_NUM_TRANSFER_BITS -1) <= (others => '0');
              Serial_Dout_0 <= '0';-- default values of the IO0_O
              Serial_Dout_1 <= '0';
              Serial_Dout_2 <= '0';
              Serial_Dout_3 <= '0';
          elsif(transfer_start = '1') then
              --if(Load_tx_data_to_shift_reg_int = '1') then
              if(transfer_start_pulse = '1' or SPIXfer_done_int_d1 = '1') then --
                      Shift_Reg   <= Transmit_Data;
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Transmit_Data(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;-- this is to make the DQ3 bit 1 in quad command transfer mode.
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Transmit_Data(0); -- msb to IO1_O
                        Serial_Dout_0 <= Transmit_Data(1);
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Transmit_Data(0); -- msb to IO3_O
                        Serial_Dout_2 <= Transmit_Data(1);
                        Serial_Dout_1 <= Transmit_Data(2);
                        Serial_Dout_0 <= Transmit_Data(3);
                      end if;
              elsif(
                    (Count(0) = '0')       --and
                    )then -- Shift Data on even
                  if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                        Serial_Dout_0 <= Shift_Reg(0);
                        Serial_Dout_3 <= pr_state_cmd_ph and Quad_Phase;
                  elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                        Serial_Dout_1 <= Shift_Reg(0); -- msb to IO1_O
                        Serial_Dout_0 <= Shift_Reg(1);
                  elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                        Serial_Dout_3 <= Shift_Reg(0); -- msb to IO3_O
                        Serial_Dout_2 <= Shift_Reg(1);
                        Serial_Dout_1 <= Shift_Reg(2);
                        Serial_Dout_0 <= Shift_Reg(3);
                  end if;
              elsif(
                    (Count(0) = '1')       --and
                    ) then -- Capture Data on odd
                      if(mode_1 = '0' and mode_0 = '0') then    -- standard mode
                           Shift_Reg <= Shift_Reg
                                        (1 to C_NUM_TRANSFER_BITS -1) &
                                                                 IO1_I;-- MISO_I;
                      elsif(mode_1 = '0' and mode_0 = '1') then -- dual mode
                          Shift_Reg   <= Shift_Reg
                                        (2 to C_NUM_TRANSFER_BITS -1) &
                                                                IO1_I &
                                                                IO0_I ;
                      elsif(mode_1 = '1' and mode_0 = '0') then -- quad mode
                          Shift_Reg   <= Shift_Reg
                                        (4 to C_NUM_TRANSFER_BITS -1) &
                                                                IO3_I &
                                                                IO2_I &
                                                                IO1_I &
                                                                IO0_I ;
                      end if;
              end if;
          end if;
      end if;
  end process RATIO_2_CAPTURE_AND_SHIFT_PROCESS;
  ----------------------------------------------
  end generate QSPI_WINBOND_MEM_DATA_CAP_GEN;
  ------------------------------------------------------
--------------------------------
XIP_STD_DUAL_MODE_WB_MEM_GEN: if (
                                  (C_SPI_MODE = 0 or C_SPI_MODE = 1) and
                                  (
                                   (C_SPI_MEMORY = 1 or C_SPI_MEMORY = 0)
                                   )
                                 )generate
--------------------------------
begin
-----
--------------------------------------------------
PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) then
            qspi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            qspi_cntrl_ps <= qspi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
pr_state_data_receive <= '1' when qspi_cntrl_ps = DATA_RECEIVE else
                         '0';
pr_state_non_idle     <= '1' when qspi_cntrl_ps /= IDLE else
                         '0';
pr_state_idle         <= '1' when qspi_cntrl_ps = IDLE else
                         '0';
pr_state_cmd_ph       <= '1' when qspi_cntrl_ps = CMD_SEND else
                         '0';


QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            new_tr              ,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase          ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            ---------------------
                            qspi_cntrl_ps       ,
                            no_slave_selected   ,
                            ---------------------
                            wrap_around         ,
                            transfer_start      ,
                            wrap_ack_1          ,
                            wb_hpm_done         ,
                            hpm_under_process_d1
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     -------------
     stop_clock    <= '0';
     -------------
     rst_wrap_around <= '0';
     -------------
     case qspi_cntrl_ps is
        when IDLE         => if((SR_5_Tx_Empty = '0') and -- this will be used specially in case of WRAP transactions
                                 (transfer_start = '1')and
                                 (new_tr = '1')
                                )then
                                 IO0_T_control <= CMD_Mode_0;
                                 IO3_T_control <= not Quad_Phase;--
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO1_T_control <= (CMD_Mode_1) or (not CMD_Mode_0);

                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(hpm_under_process_d1 = '1')then
                                        qspi_cntrl_ns <= HPM_DUMMY;
                                    elsif(Addr_Phase='1')then
                                        qspi_cntrl_ns <= ADDR_SEND;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when HPM_DUMMY    => IO0_T_control <= CMD_Mode_0;
                             IO1_T_control <= (CMD_Mode_1) or (not CMD_Mode_0);

                             if(SR_5_Tx_Empty='1') then
                                 qspi_cntrl_ns <= IDLE;
                             else
                                 qspi_cntrl_ns <= HPM_DUMMY;
                             end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                             --stop_clock    <= not SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1') and
                                (Data_Phase='0')
                               ) or (wrap_ack_1 = '1') then
                                 if (no_slave_selected = '1') or (wrap_ack_1 = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and (Data_Phase='1')
                                    )then
                                     IO0_T_control <= '1';
                                     IO1_T_control <= '1';
                                     qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
                             ------------------------------------------------
        when TEMP_ADDR_SEND =>
                               mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                     qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;
        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             if(SR_5_Tx_Empty='1') or (wrap_ack_1 = '1')then
                                 rst_wrap_around <= '1';
                                 if(no_slave_selected = '1') or
                                   (wrap_around = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                    stop_clock    <= wrap_ack_1;
                                 else
                                    stop_clock    <= SR_5_Tx_Empty;
                                    qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;

        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------

pr_state_addr_ph <= '1' when (qspi_cntrl_ps = ADDR_SEND) else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------

end generate XIP_STD_DUAL_MODE_WB_MEM_GEN;
------------------------------------------
--------------------------------------------------
XIP_STD_DUAL_MODE_NM_MEM_GEN: if ((C_SPI_MODE = 1 or C_SPI_MODE = 0) and
                                  (C_SPI_MEMORY = 2 or C_SPI_MEMORY = 0)
                                  )generate
-------------------
begin
-----
--------------------------------------------------
PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) then
            qspi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            qspi_cntrl_ps <= qspi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
pr_state_data_receive <= '1' when qspi_cntrl_ps = DATA_RECEIVE else
                         '0';
pr_state_non_idle     <= '1' when qspi_cntrl_ps /= IDLE else
                         '0';
pr_state_idle         <= '1' when qspi_cntrl_ps = IDLE else
                         '0';
pr_state_cmd_ph       <= '1' when qspi_cntrl_ps = CMD_SEND else
                         '0';

QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            --CMD_decoded         ,
                            new_tr,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            --CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            ---------------------
                            SR_5_Tx_Empty       ,SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps       ,
                            ---------------------
                            wrap_around         ,
                            transfer_start      ,
							Quad_Phase          ,
                            wrap_ack_1
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     --------------
     stop_clock    <= '0';
     --------------
     rst_wrap_around <= '0';
     --------------
     case qspi_cntrl_ps is
        when IDLE         => if((SR_5_Tx_Empty = '0') and -- this will be used specially in case of WRAP transactions
                                (transfer_start = '1')and
                                (new_tr = '1')
                                )then
                                 IO0_T_control <= CMD_Mode_0;
                                 IO3_T_control <= not Quad_Phase;--
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_1;

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        qspi_cntrl_ns <= ADDR_SEND;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')) or (wrap_ack_1 = '1')
                               )then
                                 if (no_slave_selected = '1') or (wrap_ack_1 = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              IO0_T_control <= Data_Mode_1;
                                              IO1_T_control <= not(Data_Mode_0);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and (Data_Phase='1')
                                      ) then
                                          --if((Data_Dir='1'))then
                                          --    qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          --else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          --end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                   ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= Data_Mode_1;
                             IO1_T_control <= not(Data_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(no_slave_selected = '1')then
                                qspi_cntrl_ns <= IDLE;
                             else
                                qspi_cntrl_ns <= TEMP_DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND =>
                              mode_1 <= Data_Mode_1;
                              mode_0 <= Data_Mode_0;
                              IO0_T_control <= Data_Mode_1;
                              IO1_T_control <= not(Data_Mode_0);

                              stop_clock    <= stop_clock_reg;
                              if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(SR_5_Tx_Empty='1') or (wrap_ack_1 = '1')then
                                 rst_wrap_around <= wrap_ack_1;
                                 if(no_slave_selected = '1') or (wrap_ack_1 = '1')then
                                    stop_clock <= wrap_ack_1;
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                     mode_1 <= Data_Mode_1;
                                     mode_0 <= Data_Mode_0;
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;

        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate XIP_STD_DUAL_MODE_NM_MEM_GEN;
--------------------------------
--------------------------------------------------
XIP_STD_DUAL_MODE_SP_MEM_GEN: if ((C_SPI_MODE = 1 or C_SPI_MODE = 0) and
                                  (C_SPI_MEMORY = 3 or C_SPI_MEMORY = 0)
                                  )generate
-------------------
begin
-----
--------------------------------------------------
PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) then
            qspi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            qspi_cntrl_ps <= qspi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
pr_state_data_receive <= '1' when qspi_cntrl_ps = DATA_RECEIVE else
                         '0';
pr_state_non_idle     <= '1' when qspi_cntrl_ps /= IDLE else
                         '0';
pr_state_idle         <= '1' when qspi_cntrl_ps = IDLE else
                         '0';
pr_state_cmd_ph       <= '1' when qspi_cntrl_ps = CMD_SEND else
                         '0';

QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            --CMD_decoded         ,
                            new_tr,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            --CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            ---------------------
                            SR_5_Tx_Empty       ,SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps       ,
                            ---------------------
                            wrap_around         ,
                            transfer_start      ,
                            wrap_ack_1
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     --------------
     stop_clock    <= '0';
     --------------
     rst_wrap_around <= '0';
     --------------
     case qspi_cntrl_ps is
        when IDLE         => if((SR_5_Tx_Empty = '0') and -- this will be used specially in case of WRAP transactions
                                (transfer_start = '1')and
                                (new_tr = '1')
                                )then
                                 IO0_T_control <= CMD_Mode_0;
                                 IO3_T_control <= not Quad_Phase;--
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_1;

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        qspi_cntrl_ns <= ADDR_SEND;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')) or (wrap_ack_1 = '1')
                               )then
                                 if (no_slave_selected = '1') or (wrap_ack_1 = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              IO0_T_control <= Data_Mode_1;
                                              IO1_T_control <= not(Data_Mode_0);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and (Data_Phase='1')
                                      ) then
                                          --if((Data_Dir='1'))then
                                          --    qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          --else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          --end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                   ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);-- (Addr_Mode_1) or(not Addr_Mode_0);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= Data_Mode_1;
                             IO1_T_control <= not(Data_Mode_0);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(no_slave_selected = '1')then
                                qspi_cntrl_ns <= IDLE;
                             else
                                qspi_cntrl_ns <= TEMP_DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND =>
                              mode_1 <= Data_Mode_1;
                              mode_0 <= Data_Mode_0;
                              IO0_T_control <= Data_Mode_1;
                              IO1_T_control <= not(Data_Mode_0);

                              stop_clock    <= stop_clock_reg;
                              if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;

                             if(SR_5_Tx_Empty='1') or (wrap_ack_1 = '1')then
                                 rst_wrap_around <= wrap_ack_1;
                                 if(no_slave_selected = '1') or (wrap_ack_1 = '1')then
                                    stop_clock <= wrap_ack_1;
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                     mode_1 <= Data_Mode_1;
                                     mode_0 <= Data_Mode_0;
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;

        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate XIP_STD_DUAL_MODE_SP_MEM_GEN;

--------------------------------------------------
XIP_QUAD_MODE_WB_MEM_GEN: if (
                               C_SPI_MODE = 2 and
                               C_SPI_MEMORY = 1
                              )
                              generate
-------------------
begin
-----
--------------------------------------------------
PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) then
            qspi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            qspi_cntrl_ps <= qspi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
pr_state_data_receive <= '1' when qspi_cntrl_ps = DATA_RECEIVE else
                         '0';
pr_state_non_idle     <= '1' when qspi_cntrl_ps /= IDLE else
                         '0';
pr_state_idle         <= '1' when qspi_cntrl_ps = IDLE else
                         '0';
pr_state_cmd_ph       <= '1' when qspi_cntrl_ps = CMD_SEND else
                         '0';

QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            new_tr,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase         ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            ---------------------
                            qspi_cntrl_ps       ,
                            no_slave_selected   ,
                            ---------------------
                            wrap_around         ,
                            transfer_start      ,
                            wrap_ack_1          ,
                            wb_hpm_done         ,
                            hpm_under_process_d1
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     IO2_T_control <= '1';
     IO3_T_control <= '1';
     --------------
     stop_clock    <= '0';
     --------------
     rst_wrap_around <= '0';
     --------------
     case qspi_cntrl_ps is
        when IDLE         => if(--(CMD_decoded = '1') and
                                 (SR_5_Tx_Empty = '0') and -- this will be used specially in case of WRAP transactions
                                 (transfer_start = '1')and
                                 (new_tr = '1')
                                 --(CMD_Error = '0')         -- proceed only when there is no command error
                                )then
                                 IO0_T_control <= CMD_Mode_0;
                                 IO3_T_control <= not Quad_Phase;--
                                 qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE; -- CMD_DECODE;
                             end if;
                             stop_clock    <= '1';
                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO3_T_control <= not Quad_Phase;--

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(hpm_under_process_d1 = '1')then
                                        qspi_cntrl_ns <= HPM_DUMMY;
                                    elsif(Addr_Phase='1')then
                                        qspi_cntrl_ns <= ADDR_SEND;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when HPM_DUMMY    => IO0_T_control <= CMD_Mode_0;
                             IO1_T_control <= (CMD_Mode_1) or (not CMD_Mode_0);

                             if(SR_5_Tx_Empty='1') then
                                 qspi_cntrl_ns <= IDLE;
                             else
                                 qspi_cntrl_ns <= HPM_DUMMY;
                             end if;
                             ------------------------------------------------
         when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                              mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                             IO2_T_control <= (not Addr_Mode_1);
                             IO3_T_control <= (not Addr_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1') and
                                 (Data_Phase='0')
                                )then
                                 if (no_slave_selected = '1')then
                                     qspi_cntrl_ns <= IDLE;
                                 else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                  if(
                                     (addr_cnt = "011") and -- 24 bit address
                                     (Addr_Bit='0')     and(Data_Phase='1')
                                     )then
                                         if((Data_Dir='1'))then
                                             mode_1 <= Data_Mode_1;
                                             mode_0 <= Data_Mode_0;
                                             IO0_T_control <= '0';              -- data output
                                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                                             IO2_T_control <= not (Data_Mode_1);-- active only
                                             IO3_T_control <= not (Data_Mode_1);-- active only
                                             qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                         else
                                             IO0_T_control <= '1';
                                             IO1_T_control <= '1';
                                             IO2_T_control <= '1';
                                             IO3_T_control <= '1';
                                             qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                         end if;
                                  -- -- coverage off
                                  -- -- below piece of code is for 32-bit address check, and left for future use
                                  -- elsif(
                                  --       (addr_cnt = "100") and -- 32 bit
                                  --       (Addr_Bit = '1')   and (Data_Phase='1')
                                  --       )then
                                  --         if((Data_Dir='1'))then
                                  --             qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                  --         else
                                  --             qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                  --         end if;
                                  -- -- coverage on
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                              end if;
                              ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                               IO2_T_control <= (not Addr_Mode_1);
                               IO3_T_control <= (not Addr_Mode_1);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;
        -----------------------------------------------------------------------
        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';              -- data output active only in Dual mode
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);-- active only in quad mode
                             IO3_T_control <= not (Data_Mode_1);-- active only in quad mode

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_SEND;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND => mode_1 <= Data_Mode_1;
                               mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';              -- data output active only in Dual mode
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);-- active only in quad mode
                             IO3_T_control <= not (Data_Mode_1);-- active only in quad mode

                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')or (wrap_ack_1 = '1')then
                                 rst_wrap_around <= wrap_ack_1;
                                 if(no_slave_selected = '1')or (wrap_ack_1 = '1')then
                                    stop_clock <= wrap_ack_1;
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    stop_clock    <= SR_5_Tx_Empty;
                                    qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE => mode_1 <= Data_Mode_1;
                                  mode_0 <= Data_Mode_0;
                                  stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_RECEIVE;
                               end if;
                             ------------------------------------------------
        -- coverage off
        when others => qspi_cntrl_ns <= IDLE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
------------------------------------------
end generate XIP_QUAD_MODE_WB_MEM_GEN;
------------------------------------------

--------------------------------------------------
XIP_QUAD_MODE_NM_MEM_GEN: if C_SPI_MODE = 2 and C_SPI_MEMORY = 2 generate
-------------------
begin
-----
--------------------------------------------------
PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) then
            qspi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            qspi_cntrl_ps <= qspi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
pr_state_data_receive <= '1' when qspi_cntrl_ps = DATA_RECEIVE else
                         '0';
pr_state_non_idle     <= '1' when qspi_cntrl_ps /= IDLE else
                         '0';
pr_state_idle         <= '1' when qspi_cntrl_ps = IDLE else
                         '0';
pr_state_cmd_ph       <= '1' when qspi_cntrl_ps = CMD_SEND else
                         '0';

QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            --CMD_decoded         ,
                            new_tr,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            --CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase         ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps       ,
                            ---------------------
                            wrap_around         ,
                            transfer_start_d1   ,
                            transfer_start      ,
                            wrap_ack_1
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     IO2_T_control <= '1';
     IO3_T_control <= '1';
     -------------
     stop_clock    <= '0';
     -------------
     rst_wrap_around <= '0';
     -------------
     case qspi_cntrl_ps is
        when IDLE          => if(--(CMD_decoded = '1') and
                                 (SR_5_Tx_Empty = '0') and -- this will be used specially in case of WRAP transactions
                                 (transfer_start = '1')and
                                 (new_tr = '1')
                                 --(CMD_Error = '0') -- proceed only when there is no command error
                                )then
                                IO0_T_control <= CMD_Mode_0;
                                IO3_T_control <= not Quad_Phase;

                                qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';

                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO3_T_control <= not Quad_Phase;-- this is due to sending '1' on DQ3 line during command phase for Quad instructions only.

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        qspi_cntrl_ns <= ADDR_SEND;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                             IO2_T_control <= (not Addr_Mode_1);
                             IO3_T_control <= (not Addr_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')
                               )then
                                 if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and
                                    (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;

                                              IO0_T_control <= '0';
                                              IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                                              IO2_T_control <= not (Data_Mode_1);
                                              IO3_T_control <= not (Data_Mode_1);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and
                                       (Data_Phase='1')
                                      ) then
                                          --if((Data_Dir='1'))then
                                          --    qspi_cntrl_ns <= DATA_SEND; -- o/p
                                          --else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          --end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                     ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                               IO2_T_control <= (not Addr_Mode_1);
                               IO3_T_control <= (not Addr_Mode_1);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_SEND;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND=> mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1') or (wrap_ack_1 = '1')then
                                 rst_wrap_around <= wrap_ack_1;
                                 --if(no_slave_selected = '1') or (wrap_around = '1')then
                                    stop_clock <= wrap_ack_1 or SR_5_Tx_Empty;
                                    qspi_cntrl_ns <= IDLE;
                                 --else
                                 --   stop_clock    <= SR_5_Tx_Empty;
                                 --   qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 --end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE =>  mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;
                             stop_clock    <= stop_clock_reg;
                             --if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                             --else
                             --      stop_clock    <= '0';
                             --      qspi_cntrl_ns <= DATA_RECEIVE;
                             --end if;
                             ------------------------------------------------
        -- coverage off
        when others => qspi_cntrl_ns <= IDLE; -- CMD_DECODE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate XIP_QUAD_MODE_NM_MEM_GEN;
---------------------------------------
XIP_QUAD_MODE_SP_MEM_GEN: if C_SPI_MODE = 2 and C_SPI_MEMORY = 3 generate
-------------------
begin
-----
--------------------------------------------------
PS_TO_NS_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
    if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(Rst_to_spi = RESET_ACTIVE) then
            qspi_cntrl_ps <= IDLE;
            stop_clock_reg <= '0';
        else
            qspi_cntrl_ps <= qspi_cntrl_ns;
            stop_clock_reg <= stop_clock;
        end if;
    end if;
end process PS_TO_NS_PROCESS;
-----------------------------
pr_state_data_receive <= '1' when qspi_cntrl_ps = DATA_RECEIVE else
                         '0';
pr_state_non_idle     <= '1' when qspi_cntrl_ps /= IDLE else
                         '0';
pr_state_idle         <= '1' when qspi_cntrl_ps = IDLE else
                         '0';
pr_state_cmd_ph       <= '1' when qspi_cntrl_ps = CMD_SEND else
                         '0';

QSPI_CNTRL_PROCESS: process(
                            ---------------------
                            --CMD_decoded         ,
                            new_tr,
                            CMD_Mode_1          ,
                            CMD_Mode_0          ,
                            --CMD_Error           ,
                            ---------------------
                            Addr_Phase          ,
                            Addr_Bit            ,
                            Addr_Mode_1         ,
                            Addr_Mode_0         ,
                            ---------------------
                            Data_Phase          ,
                            Data_Dir            ,
                            Data_Mode_1         ,
                            Data_Mode_0         ,
                            ---------------------
                            addr_cnt            ,
                            Quad_Phase         ,
                            ---------------------
                            SR_5_Tx_Empty       ,
                            --SPIXfer_done_int_pulse_d2,
                            SPIXfer_done_int_pulse,
                            stop_clock_reg,
                            no_slave_selected   ,
                            ---------------------
                            qspi_cntrl_ps       ,
                            ---------------------
                            wrap_around         ,
                            transfer_start_d1   ,
                            transfer_start      ,
                            wrap_ack_1
                    )is
-----
begin
-----
     mode_1 <= '0';
     mode_0 <= '0';
     --------------
     IO0_T_control <= '1';
     IO1_T_control <= '1';
     IO2_T_control <= '1';
     IO3_T_control <= '1';
     -------------
     stop_clock    <= '0';
     -------------
     rst_wrap_around <= '0';
     -------------
     case qspi_cntrl_ps is
        when IDLE          => if(--(CMD_decoded = '1') and
                                 (SR_5_Tx_Empty = '0') and -- this will be used specially in case of WRAP transactions
                                 (transfer_start = '1')and
                                 (new_tr = '1')
                                 --(CMD_Error = '0') -- proceed only when there is no command error
                                )then
                                IO0_T_control <= CMD_Mode_0;
                                IO3_T_control <= not Quad_Phase;

                                qspi_cntrl_ns <= CMD_SEND;
                             else
                                 qspi_cntrl_ns <= IDLE;
                             end if;
                             stop_clock    <= '1';

                             ------------------------------------------------
        when CMD_SEND     => mode_1 <= CMD_Mode_1;
                             mode_0 <= CMD_Mode_0;

                             IO0_T_control <= CMD_Mode_0;
                             IO3_T_control <= not Quad_Phase;-- this is due to sending '1' on DQ3 line during command phase for Quad instructions only.

                                 --if(SPIXfer_done_int_pulse_d2 = '1')then
                                 if(SPIXfer_done_int_pulse = '1')then
                                    if(Addr_Phase='1')then
                                        qspi_cntrl_ns <= ADDR_SEND;
                                    else
                                        qspi_cntrl_ns <= IDLE;
                                    end if;
                                 else
                                    qspi_cntrl_ns <= CMD_SEND;
                                 end if;
                             ------------------------------------------------
        when ADDR_SEND    => mode_1 <= Addr_Mode_1;
                             mode_0 <= Addr_Mode_0;

                             IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                             IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                             IO2_T_control <= (not Addr_Mode_1);
                             IO3_T_control <= (not Addr_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;

                             if((SR_5_Tx_Empty='1')           and
                                (Data_Phase='0')
                               )then
                                 if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                 else
                                        qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                 end if;
                             else
                                 if(
                                    (addr_cnt = "011") and -- 24 bit address
                                    (Addr_Bit='0')     and
                                    (Data_Phase='1')
                                    )then
                                          if((Data_Dir='1'))then
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;

                                              IO0_T_control <= '0';
                                              IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                                              IO2_T_control <= not (Data_Mode_1);
                                              IO3_T_control <= not (Data_Mode_1);
                                              qspi_cntrl_ns <= DATA_SEND;   -- o/p
                                          else
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          end if;
                                 elsif(
                                       (addr_cnt = "100") and -- 32 bit
                                       (Addr_Bit = '1')   and
                                       (Data_Phase='1')
                                      ) then
                                          --if((Data_Dir='1'))then
                                          --    qspi_cntrl_ns <= DATA_SEND; -- o/p
                                          --else
                                              IO0_T_control <= '1';
                                              IO1_T_control <= '1';
                                              IO2_T_control <= '1';
                                              IO3_T_control <= '1';
                                              mode_1 <= Data_Mode_1;
                                              mode_0 <= Data_Mode_0;
                                              qspi_cntrl_ns <= DATA_RECEIVE;-- i/p
                                          --end if;
                                 else
                                     qspi_cntrl_ns <= ADDR_SEND;
                                 end if;
                             end if;
        --                     ------------------------------------------------
        when TEMP_ADDR_SEND => mode_1 <= Addr_Mode_1;
                               mode_0 <= Addr_Mode_0;

                               IO0_T_control <= Addr_Mode_0 and Addr_Mode_1;
                               IO1_T_control <= not(Addr_Mode_0 xor Addr_Mode_1);
                               IO2_T_control <= (not Addr_Mode_1);
                               IO3_T_control <= (not Addr_Mode_1);

                               stop_clock    <= stop_clock_reg;
                               if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_ADDR_SEND;
                                  end if;
                               else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= ADDR_SEND;
                               end if;

        when DATA_SEND    => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1')then
                                 if(no_slave_selected = '1')then
                                    qspi_cntrl_ns <= IDLE;
                                 else
                                    qspi_cntrl_ns <= TEMP_DATA_SEND;
                                 end if;
                             else
                                 qspi_cntrl_ns <= DATA_SEND;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_SEND=> mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             IO0_T_control <= '0';
                             IO1_T_control <= not(Data_Mode_1 xor Data_Mode_0);
                             IO2_T_control <= not (Data_Mode_1);
                             IO3_T_control <= not (Data_Mode_1);

                             stop_clock    <= stop_clock_reg;
                             if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_SEND;
                                  end if;
                             else
                                   stop_clock    <= '0';
                                   qspi_cntrl_ns <= DATA_SEND;
                             end if;

        when DATA_RECEIVE => mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;

                             --stop_clock    <= SR_5_Tx_Empty;
                             if(SR_5_Tx_Empty='1') or (wrap_ack_1 = '1')then
                                 rst_wrap_around <= wrap_ack_1;
                                 --if(no_slave_selected = '1') or (wrap_around = '1')then
                                    stop_clock <= wrap_ack_1 or SR_5_Tx_Empty;
                                    qspi_cntrl_ns <= IDLE;
                                 --else
                                 --   stop_clock    <= SR_5_Tx_Empty;
                                 --   qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                 --end if;
                             else
                                 qspi_cntrl_ns <= DATA_RECEIVE;
                             end if;
                             ------------------------------------------------
        when TEMP_DATA_RECEIVE =>  mode_1 <= Data_Mode_1;
                             mode_0 <= Data_Mode_0;
                             stop_clock    <= stop_clock_reg;
                             --if(SR_5_Tx_Empty='1')then
                                  if (no_slave_selected = '1')then
                                        qspi_cntrl_ns <= IDLE;
                                  elsif(SPIXfer_done_int_pulse='1')then
                                     stop_clock    <= SR_5_Tx_Empty;
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  else
                                     qspi_cntrl_ns <= TEMP_DATA_RECEIVE;
                                  end if;
                             --else
                             --      stop_clock    <= '0';
                             --      qspi_cntrl_ns <= DATA_RECEIVE;
                             --end if;
                             ------------------------------------------------
        -- coverage off
        when others => qspi_cntrl_ns <= IDLE; -- CMD_DECODE;
                             ------------------------------------------------
        -- coverage on
     end case;
-------------------------------
end process QSPI_CNTRL_PROCESS;
-------------------------------
pr_state_addr_ph <= '1' when qspi_cntrl_ps = ADDR_SEND else
                    '0';

QSPI_ADDR_CNTR_PROCESS: process(EXT_SPI_CLK)is
-----
begin
-----
     if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
        if(pr_state_addr_ph = '0') then
                addr_cnt <= (others => '0');
        elsif(pr_state_addr_ph = '1')then
                --addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse_d2;
                addr_cnt <= addr_cnt +  SPIXfer_done_int_pulse;
        end if;
     end if;
end process QSPI_ADDR_CNTR_PROCESS;
-----------------------------------
end generate XIP_QUAD_MODE_SP_MEM_GEN;
---------------------------------------

IO0_O                           <= Serial_Dout_0;
IO1_O                           <= Serial_Dout_1;
IO2_O                           <= Serial_Dout_2;
IO3_O                           <= Serial_Dout_3;
--SCK_O                           <= SCK_O_reg;
--SS_O                            <= SS_to_spi_clk;
--* -------------------------------------------------------------------------------
--* -- MASTER_TRIST_EN_PROCESS : If not master make tristate enabled
--* ----------------------------
SS_tri_state_en_control <= '0' when
                           (
                            -- (SR_5_Tx_Empty_d1 = '0') and -- Length counter is not exited
                            (transfer_start = '1') and 
                            (wrap_ack = '0')   and -- no wrap around
                            --(MODF_strobe_int ='0')   -- no mode fault -- 9/7/2013
			    (SPISEL_sync = '1')  -- 9/7/2013
                           )
                           else
                           '1';

--QSPI_SS_T: tri-state register for SS,ideal state-deactive
QSPI_SS_T: component FD
   generic map
        (
        INIT => '1'
        )
   port map
        (
        Q  => SS_T,
        C  => EXT_SPI_CLK,
        D  => SS_tri_state_en_control
        );
    --QSPI_SCK_T : Tri-state register for SCK_T, ideal state-deactive
SCK_tri_state_en_control <= '0' when
                             (
                              -- (SR_5_Tx_Empty = '0')       and -- Length counter is not exited
                              (transfer_start = '1')      and -- 4/14/2013
                              (wrap_ack = '0')            and -- no wrap around-- (pr_state_non_idle = '1')    and -- CR#619275 - this is commented to operate the mode 3 with SW flow
                              --(MODF_strobe_int ='0')         -- no mode fault -- 9/7/2013
			      (SPISEL_sync = '1') -- 9/7/2013
                             ) else
                             '1';
							 
    QSPI_SCK_T: component FD
       generic map
           (
           INIT => '1'
           )
       port map
           (
           Q  => SCK_T,
           C  => EXT_SPI_CLK,
           D  => SCK_tri_state_en_control
           );
    IO0_tri_state_en_control <= '0' when
                         (
                          (IO0_T_control = '0')   and
                          --(MODF_strobe_int = '0')-- no mode fault-- 9/7/2013
			  (SPISEL_sync = '1') -- 9/7/2013
                         ) else
                         '1';
    --QSPI_IO0_T: tri-state register for MOSI, ideal state-deactive
    QSPI_IO0_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO0_T,     -- MOSI_T,
            C  => EXT_SPI_CLK,
            D  => IO0_tri_state_en_control -- master_tri_state_en_control
            );
    IO1_tri_state_en_control <= '0' when
                         (
                          (IO1_T_control = '0')   and
                          --(MODF_strobe_int = '0')-- no mode fault-- 9/7/2013
			  (SPISEL_sync = '1') -- 9/7/2013
                         ) else
                         '1';

    --QSPI_IO0_T: tri-state register for MISO, ideal state-deactive
    QSPI_IO1_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO1_T,      -- MISO_T,
            C  => EXT_SPI_CLK,
            D  => IO1_tri_state_en_control
            );
-------------------------------------------------------------------------------
QSPI_NO_MODE_2_T_CONTROL: if C_SPI_MODE = 1 or C_SPI_MODE = 0 generate
----------------------
begin
-----
    --------------------------------------
    IO2_tri_state_en_control <= '1';
    IO3_tri_state_en_control <= '1';
    IO2_T <= '1';
    IO3_T <= '1';
    --------------------------------------
end generate QSPI_NO_MODE_2_T_CONTROL;
--------------------------------------
-------------------------------------------------------------------------------
QSPI_MODE_2_T_CONTROL: if C_SPI_MODE = 2 generate
----------------------
begin
-----
    --------------------------------------
    IO2_tri_state_en_control <= '0' when
                         (
                          (IO2_T_control = '0')   and
                          --(MODF_strobe_int = '0')-- no mode fault -- 9/7/2013
			  (SPISEL_sync = '1') -- 9/7/2013
                         ) else
                         '1';
    --QSPI_IO0_T: tri-state register for MOSI, ideal state-deactive
    QSPI_IO2_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO2_T,     -- MOSI_T,
            C  => EXT_SPI_CLK,
            D  => IO2_tri_state_en_control -- master_tri_state_en_control
            );
    --------------------------------------
    IO3_tri_state_en_control <= '0' when
                         (
                          (IO3_T_control = '0')   and
                          --(MODF_strobe_int = '0')-- no mode fault-- 9/7/2013
			  (SPISEL_sync = '1') -- 9/7/2013
                         ) else
                         '1';

    --QSPI_IO0_T: tri-state register for MISO, ideal state-deactive
    QSPI_IO3_T: component FD
       generic map
            (
            INIT => '1'
            )
       port map
            (
            Q  => IO3_T,      -- MISO_T,
            C  => EXT_SPI_CLK,
            D  => IO3_tri_state_en_control
            );
    --------------------------------------
end generate QSPI_MODE_2_T_CONTROL;
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- QSPI_SPISEL: first synchronize the incoming signal, this is required is slave
--------------- mode of the core.

    QSPI_SPISEL: component FD
       generic map
            (
            INIT => '1' -- default '1' to make the device in default master mode
            )
       port map
            (
            Q  => SPISEL_sync,
            C  => EXT_SPI_CLK,
            D  => SPISEL
            );
    -- SPISEL_DELAY_1CLK_PROCESS_P : Detect active SCK edge in slave mode
    -----------------------------
    SPISEL_DELAY_1CLK_PROCESS_P: process(EXT_SPI_CLK)
    begin
        if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
            if(Rst_to_spi = RESET_ACTIVE) then
                spisel_d1 <= '1';
            else
                spisel_d1 <= SPISEL_sync;
            end if;
        end if;
    end process SPISEL_DELAY_1CLK_PROCESS_P;
    ------------------------------------------------

    -- MODF_STROBE_PROCESS : Strobe MODF signal when master is addressed as slave
    ------------------------
    MODF_STROBE_PROCESS: process(EXT_SPI_CLK)is
    -----
    begin
    -----
        if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
           if((Rst_to_spi = RESET_ACTIVE) or (SPISEL_sync = '1')) then
               MODF_strobe       <= '0';
               MODF_strobe_int   <= '0';
               Allow_MODF_Strobe <= '1';
           elsif(
                 (SPISEL_sync = '0') and
                 (Allow_MODF_Strobe = '1')
                 ) then
               MODF_strobe       <= '1';
               MODF_strobe_int   <= '1';
               Allow_MODF_Strobe <= '0';
           else
               MODF_strobe       <= '0';
               MODF_strobe_int   <= '0';
           end if;
        end if;
    end process MODF_STROBE_PROCESS;

SS_O_24_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 24 generate 
-----
begin
-----
    -------------------------------------------------------------------------------
    -- SELECT_OUT_PROCESS : This process sets SS active-low, one-hot encoded select
    --                      bit. Changing SS is premitted during a transfer by
    --                      hardware, but is to be prevented by software. In Auto
    --                      mode SS_O reflects value of Slave_Select_Reg only
    --                      when transfer is in progress, otherwise is SS_O is held
    --                      high
    -----------------------
    SELECT_OUT_PROCESS: process(EXT_SPI_CLK)is
    begin
        if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
           if(Rst_to_spi = RESET_ACTIVE) then
               SS_O                   <= (others => '1');
           elsif(wrap_ack_1 = '1') or (store_last_b4_wrap = '1') or (SR_5_Tx_Empty ='1') then
               SS_O                   <= (others => '1');
           elsif(hpm_under_process_d1 = '1') then
               for i in (C_NUM_SS_BITS-1) downto 0 loop
                   SS_O(i) <= (SS_to_spi_clk(C_NUM_SS_BITS-1-i));
               end loop;
           elsif(store_last_b4_wrap = '0') then
               for i in (C_NUM_SS_BITS-1) downto 0 loop
                   SS_O(i) <= not(SS_to_spi_clk(C_NUM_SS_BITS-1-i));
               end loop;
           end if;
        end if;
    end process SELECT_OUT_PROCESS;
    ----------------------------
end generate SS_O_24_BIT_ADDR_GEN;
----------------------------------

SS_O_32_BIT_ADDR_GEN: if C_SPI_MEM_ADDR_BITS = 32 generate 
-----
begin
-----
    -------------------------------------------------------------------------------
    -- SELECT_OUT_PROCESS : This process sets SS active-low, one-hot encoded select
    --                      bit. Changing SS is premitted during a transfer by
    --                      hardware, but is to be prevented by software. In Auto
    --                      mode SS_O reflects value of Slave_Select_Reg only
    --                      when transfer is in progress, otherwise is SS_O is held
    --                      high
    -----------------------
    SELECT_OUT_PROCESS: process(EXT_SPI_CLK)is
    begin
        if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
           if(Rst_to_spi = RESET_ACTIVE) then
               SS_O                   <= (others => '1');
           elsif(wrap_ack_1 = '1') or (store_last_b4_wrap = '1') or (transfer_start = '0' and SR_5_Tx_Empty_d1='1') then
               SS_O                   <= (others => '1');
           elsif(hpm_under_process = '1') or (wr_en_under_process = '1') then
               for i in (C_NUM_SS_BITS-1) downto 0 loop
                   SS_O(i) <= (SS_to_spi_clk(C_NUM_SS_BITS-1-i));
               end loop;
           elsif(store_last_b4_wrap = '0') then
               for i in (C_NUM_SS_BITS-1) downto 0 loop
                   SS_O(i) <= not(SS_to_spi_clk(C_NUM_SS_BITS-1-i));
               end loop;
           end if;
        end if;
    end process SELECT_OUT_PROCESS;
    ----------------------------
end generate SS_O_32_BIT_ADDR_GEN;
----------------------------------
    no_slave_selected <= and_reduce(SS_to_spi_clk((C_NUM_SS_BITS-1) downto 0));
    -------------------------------------------------------------------------------
    SCK_O_NQ_4_NO_STARTUP_USED: if (C_USE_STARTUP = 0) generate
    ----------------
    attribute IOB                         : string;
    attribute IOB of SCK_O_NE_4_FDRE_INST : label is "true";
    signal slave_mode                     : std_logic;
    ----------------
    begin
    -----
    -------------------------------------------------------------------------------
    -- SCK_O_SELECT_PROCESS : Select the idle state (CPOL bit) when not transfering
    --                        data else select the clock for slave device
    -------------------------
    SCK_O_NQ_4_SELECT_PROCESS: process(--Mst_N_Slv         ,-- in master mode
                                       sck_o_int         ,-- value driven on sck_int
                                       CPOL_to_spi_clk              ,-- CPOL mode thr SPICR
                                       transfer_start    ,
                                       transfer_start_d1 ,
                                       Count(COUNT_WIDTH),
                                       pr_state_non_idle  -- State machine is in Non-idle state
                                      )is
    begin
            if((transfer_start = '1')    and
               --(transfer_start_d1 = '1') and
               --(Count(COUNT_WIDTH) = '0')and
               (pr_state_non_idle = '1')
               ) then
                    sck_o_in <= sck_o_int;
            else
                    sck_o_in <= CPOL_to_spi_clk;
            end if;
    end process SCK_O_NQ_4_SELECT_PROCESS;
    ---------------------------------

    slave_mode <= '0'; -- create the reset condition by inverting the mst_n_slv signal. 1 - master mode, 0 - slave mode.
    -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
    -- Clock Enable (posedge clk). during slave mode no clock should be generated from the core.
    SCK_O_NE_4_FDRE_INST : component FDRE
    generic map (
                 INIT => '0'
                 ) -- Initial value of register (’0’ or ’1’)
          port map
                (
                 Q  => SCK_O_reg,   -- Data output
                 C  => EXT_SPI_CLK,  -- Clock input
                 CE => '1',         -- Clock enable input
                 R  => Rst_to_spi,  -- Synchronous reset input
                 D  => sck_o_in     -- Data input
                );

    end generate SCK_O_NQ_4_NO_STARTUP_USED;
    -------------------------------

    SCK_O_NQ_4_STARTUP_USED: if (C_USE_STARTUP = 1) generate
    -------------
    begin
    -----
    -------------------------------------------------------------------------------
    -- SCK_O_SELECT_PROCESS : Select the idle state (CPOL bit) when not transfering
    --                        data else select the clock for slave device
    -------------------------
    SCK_O_NQ_4_SELECT_PROCESS: process(sck_o_int         ,
                                       CPOL_to_spi_clk              ,
                                       transfer_start    ,
                                       transfer_start_d1 ,
                                       Count(COUNT_WIDTH)
                                      )is
    begin
            if((transfer_start = '1')   -- and
               --(transfer_start_d1 = '1') --and
               --(Count(COUNT_WIDTH) = '0')
               ) then
                    sck_o_in <= sck_o_int;
            else
                    sck_o_in <= CPOL_to_spi_clk;
            end if;
    end process SCK_O_NQ_4_SELECT_PROCESS;
    ---------------------------------

     ---------------------------------------------------------------------------
     -- SCK_O_FINAL_PROCESS : Register the final SCK_O_reg
     ------------------------
     SCK_O_NQ_4_FINAL_PROCESS: process(EXT_SPI_CLK)
     -----
     begin
     -----
         if(EXT_SPI_CLK'event and EXT_SPI_CLK = '1') then
         --If Soft_Reset_op or slave Mode.Prevents SCK_O_reg to be generated in slave
            if((Rst_to_spi = RESET_ACTIVE)
              ) then
                 SCK_O_reg <= '0';
            elsif((pr_state_non_idle='0')-- or  -- dont allow sck to go out when
                  --(Mst_N_Slv = '0')
                  )then      -- SM is in IDLE state or core in slave mode
                 SCK_O_reg <= '0';
            else
                 SCK_O_reg <= sck_o_in;
            end if;
         end if;
     end process SCK_O_NQ_4_FINAL_PROCESS;
     -------------------------------------
    end generate SCK_O_NQ_4_STARTUP_USED;
    -------------------------------------
--end generate RATIO_NOT_EQUAL_4_GENERATE;
end generate RATIO_OF_2_GENERATE;
end architecture imp;
-------------------------------------------------------------------------------


-------------------------------------------------------------------
-- (c) Copyright 1984 - 2012 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
-------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:        axi_qspi_enhanced_mode.vhd
-- Version:         v3.0
-- Description:     Serial Peripheral Interface (SPI) Module for interfacing
--                  enhanced mode with a 32-bit AXI bus.
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_unsigned.all;
    use ieee.numeric_std.all;
    use ieee.std_logic_misc.all;

use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;




library axi_lite_ipif_v3_0_4;
use axi_lite_ipif_v3_0_4.axi_lite_ipif;
use axi_lite_ipif_v3_0_4.ipif_pkg.all;
library lib_srl_fifo_v1_0_2;
    use lib_srl_fifo_v1_0_2.srl_fifo_f;
library lib_pkg_v1_0_2;
    use lib_pkg_v1_0_2.all;
    use lib_pkg_v1_0_2.lib_pkg.log2;
    use lib_pkg_v1_0_2.lib_pkg.clog2;
    use lib_pkg_v1_0_2.lib_pkg.max2;
    use lib_pkg_v1_0_2.lib_pkg.RESET_ACTIVE;

library interrupt_control_v3_1_4;

library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;

entity axi_qspi_enhanced_mode is
     generic (
      -- General Parameters
      C_FAMILY                 : string               := "virtex7";
      C_SUB_FAMILY             : string               := "virtex7";
      -------------------------
      C_AXI4_CLK_PS            : integer              := 10000;--AXI clock period
      C_EXT_SPI_CLK_PS         : integer              := 10000;--ext clock period
      C_FIFO_DEPTH             : integer              := 16;-- allowed 0,16,256.
      C_SCK_RATIO              : integer              := 16;--default in legacy mode
      C_NUM_SS_BITS            : integer range 1 to 32:= 1;
      C_NUM_TRANSFER_BITS      : integer              := 8; -- allowed 8, 16, 32
      -------------------------
      C_SPI_MODE               : integer range 0 to 2 := 0; -- used for differentiating
      C_USE_STARTUP            : integer range 0 to 1 := 1; --
      C_SPI_MEMORY             : integer range 0 to 3 := 1; -- 0 - mixed mode,
      -------------------------
      -- AXI4 Full Interface Parameters
      --*C_S_AXI4_ADDR_WIDTH      : integer range 32 to 32 := 32;
      C_S_AXI4_ADDR_WIDTH      : integer range 24 to 24 := 24;
      C_S_AXI4_DATA_WIDTH      : integer range 32 to 32 := 32;
      C_S_AXI4_ID_WIDTH        : integer range 1 to 16  := 4;
      -------------------------
      --C_AXI4_BASEADDR          : std_logic_vector       := x"FFFFFFFF";
      --C_AXI4_HIGHADDR          : std_logic_vector       := x"00000000";
      -------------------------
      C_ARD_ADDR_RANGE_ARRAY   : SLV64_ARRAY_TYPE :=
       (
        X"0000_0000_7000_0000", -- IP user0 base address
        X"0000_0000_7000_00FF", -- IP user0 high address
        X"0000_0000_7000_0100", -- IP user1 base address
        X"0000_0000_7000_01FF"  -- IP user1 high address
       );
      C_ARD_NUM_CE_ARRAY       : INTEGER_ARRAY_TYPE :=
       (
        1,         -- User0 CE Number
        8          -- User1 CE Number
       );
       C_S_AXI_SPI_MIN_SIZE    : std_logic_vector(31 downto 0):= X"0000007c";
       C_SPI_MEM_ADDR_BITS         : integer -- newly added 
    );
    port (
     -- external async clock for SPI interface logic
     EXT_SPI_CLK    : in std_logic;
     S_AXI4_ACLK     : in std_logic;
     S_AXI4_ARESETN  : in std_logic;
     -------------------------------
     -------------------------------
     --*AXI4 Full port interface* --
     -------------------------------
     ------------------------------------
     -- AXI Write Address Channel Signals
     ------------------------------------
     S_AXI4_AWID    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_AWADDR  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1)  downto 0);--((C_S_AXI4_ADDR_WIDTH-1) downto 0);
     S_AXI4_AWLEN   : in  std_logic_vector(7 downto 0);
     S_AXI4_AWSIZE  : in  std_logic_vector(2 downto 0);
     S_AXI4_AWBURST : in  std_logic_vector(1 downto 0);
     S_AXI4_AWLOCK  : in  std_logic;                   -- not supported in design
     S_AXI4_AWCACHE : in  std_logic_vector(3 downto 0);-- not supported in design
     S_AXI4_AWPROT  : in  std_logic_vector(2 downto 0);-- not supported in design
     S_AXI4_AWVALID : in  std_logic;
     S_AXI4_AWREADY : out std_logic;
     ---------------------------------------
     -- AXI4 Full Write Data Channel Signals
     ---------------------------------------
     S_AXI4_WDATA   : in  std_logic_vector((C_S_AXI4_DATA_WIDTH-1)downto 0);
     S_AXI4_WSTRB   : in  std_logic_vector(((C_S_AXI4_DATA_WIDTH/8)-1) downto 0);
     S_AXI4_WLAST   : in  std_logic;
     S_AXI4_WVALID  : in  std_logic;
     S_AXI4_WREADY  : out std_logic;
     -------------------------------------------
     -- AXI4 Full Write Response Channel Signals
     -------------------------------------------
     S_AXI4_BID     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_BRESP   : out std_logic_vector(1 downto 0);
     S_AXI4_BVALID  : out std_logic;
     S_AXI4_BREADY  : in  std_logic;
     -----------------------------------
     -- AXI Read Address Channel Signals
     -----------------------------------
     S_AXI4_ARID    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_ARADDR  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1)  downto 0);--((C_S_AXI4_ADDR_WIDTH-1) downto 0);
     S_AXI4_ARLEN   : in  std_logic_vector(7 downto 0);
     S_AXI4_ARSIZE  : in  std_logic_vector(2 downto 0);
     S_AXI4_ARBURST : in  std_logic_vector(1 downto 0);
     S_AXI4_ARLOCK  : in  std_logic;                    -- not supported in design
     S_AXI4_ARCACHE : in  std_logic_vector(3 downto 0);-- not supported in design
     S_AXI4_ARPROT  : in  std_logic_vector(2 downto 0);-- not supported in design
     S_AXI4_ARVALID : in  std_logic;
     S_AXI4_ARREADY : out std_logic;
     --------------------------------
     -- AXI Read Data Channel Signals
     --------------------------------
     S_AXI4_RID     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_RDATA   : out std_logic_vector((C_S_AXI4_DATA_WIDTH-1) downto 0);
     S_AXI4_RRESP   : out std_logic_vector(1 downto 0);
     S_AXI4_RLAST   : out std_logic;
     S_AXI4_RVALID  : out std_logic;
     S_AXI4_RREADY  : in  std_logic;
     --------------------------------
     Bus2IP_Clk          : out std_logic;
     Bus2IP_Reset        : out std_logic;
     --Bus2IP_Addr         : out std_logic_vector
     --                      (C_S_AXI4_ADDR_WIDTH-1 downto 0);
     Bus2IP_RNW          : out std_logic;
     Bus2IP_BE           : out std_logic_vector
                           (((C_S_AXI4_DATA_WIDTH/8) - 1) downto 0);
     Bus2IP_CS           : out std_logic_vector
                           (((C_ARD_ADDR_RANGE_ARRAY'LENGTH)/2 - 1) downto 0);
     Bus2IP_RdCE         : out std_logic_vector
                           ((calc_num_ce(C_ARD_NUM_CE_ARRAY) - 1) downto 0);
     Bus2IP_WrCE         : out std_logic_vector
                           ((calc_num_ce(C_ARD_NUM_CE_ARRAY) - 1) downto 0);
     Bus2IP_Data         : out std_logic_vector
                           ((C_S_AXI4_DATA_WIDTH-1) downto 0);
     IP2Bus_Data         : in  std_logic_vector
                           ((C_S_AXI4_DATA_WIDTH-1) downto 0);
     IP2Bus_WrAck        : in  std_logic;
     IP2Bus_RdAck        : in  std_logic;
     IP2Bus_Error        : in  std_logic;
     ---------------------------------
     burst_tr            : out std_logic;
     rready              : out std_logic
    );
 end entity axi_qspi_enhanced_mode;

architecture imp of axi_qspi_enhanced_mode is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

 -- constant declaration
 constant ACTIVE_LOW_RESET : std_logic := '0';
-- local type declarations
    type STATE_TYPE is (
                         IDLE,
                         AXI_SINGLE_RD,
                         AXI_RD,
                         AXI_SINGLE_WR,
                         AXI_WR,
                         CHECK_AXI_LENGTH_ERROR,
                         AX_WRONG_BURST_TYPE,
                         WR_RESP_1,
                         WR_RESP_2,
                         RD_RESP_1,RD_LAST,
                         RD_RESP_2,
                         ERROR_RESP,
                         RD_ERROR_RESP
                       );

-- Signal Declaration
-----------------------------
    signal axi_full_sm_ps : STATE_TYPE;
    signal axi_full_sm_ns : STATE_TYPE;

 -- function declaration
-------------------------------------------------------------------------------
-- Get_Addr_Bits: Function Declarations
-------------------------------------------------------------------------------
-- code coverage -- function Get_Addr_Bits (y : std_logic_vector(31 downto 0)) return integer is
-- code coverage -- variable i : integer := 0;
-- code coverage --     begin
-- code coverage --         for i in 31 downto 0 loop
-- code coverage --             if y(i)='1' then
-- code coverage --                return (i);
-- code coverage --             end if;
-- code coverage --         end loop;
-- code coverage --         return -1;
-- code coverage -- end function Get_Addr_Bits;
 -- constant declaration
 constant C_ADDR_DECODE_BITS   : integer := 6; -- Get_Addr_Bits(C_S_AXI_SPI_MIN_SIZE);
 constant C_NUM_DECODE_BITS    : integer := C_ADDR_DECODE_BITS +1;
 constant ZEROS                : std_logic_vector(31 downto
                               (C_ADDR_DECODE_BITS+1)) := (others=>'0');
--   type decode_bit_array_type is Array(natural range 0 to (
--                           (C_ARD_ADDR_RANGE_ARRAY'LENGTH)/2)-1) of
--                           integer;

--   type short_addr_array_type is Array(natural range 0 to
--                           C_ARD_ADDR_RANGE_ARRAY'LENGTH-1) of
--                           std_logic_vector(0 to(C_ADDR_DECODE_BITS-1));
 -- signal declaration
 signal axi_size_reg             : std_logic_vector(2 downto 0);
 signal axi_size_cmb             : std_logic_vector(2 downto 0);
 signal bus2ip_rnw_i             : std_logic;
 signal bus2ip_addr_i            : std_logic_vector(31 downto 0); -- (31 downto 0); -- 8/18/2013
 signal wr_transaction           : std_logic;
 signal wr_addr_transaction      : std_logic;
 signal arready_i                : std_logic;
 signal awready_i, s_axi_wready_i                : std_logic;
 signal S_AXI4_RID_reg           : std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
 signal S_AXI4_BID_reg           : std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
 signal s_axi_mem_bresp_reg      : std_logic_vector(2 downto 0);
 signal axi_full_sm_ps_IDLE_cmb  : std_logic;
 signal s_axi_mem_bvalid_reg     : std_logic;
 signal bus2ip_BE_reg            : std_logic_vector(((C_S_AXI4_DATA_WIDTH/8) - 1) downto 0);
 signal axi_length_cmb           : std_logic_vector(7 downto 0);
 signal axi_length_reg           : std_logic_vector(7 downto 0);
 signal burst_transfer_cmb      : std_logic;
 signal burst_transfer_reg      : std_logic;
 signal axi_burst_cmb            : std_logic_vector(1 downto 0);
 signal axi_burst_reg            : std_logic_vector(1 downto 0);
 signal length_cntr              : std_logic_vector(7 downto 0);
 signal last_data_cmb            : std_logic;
 signal last_bt_one_data_cmb            : std_logic;
 signal last_data_acked          : std_logic;
 signal pr_state_idle            : std_logic;
 signal length_error             : std_logic;
 signal rnw_reg, rnw_cmb         : std_logic;
 signal arready_cmb              : std_logic;
 signal awready_cmb              : std_logic;
 signal wready_cmb               : std_logic;
 signal store_axi_signal_cmb     : std_logic;
 signal combine_ack, start, temp_i, response              : std_logic;
 signal s_axi4_rdata_i   : std_logic_vector((C_S_AXI4_DATA_WIDTH-1) downto 0);
 signal s_axi4_rresp_i   : std_logic_vector(1 downto 0);
 signal s_axi_rvalid_i   : std_logic;
 signal S_AXI4_BRESP_i : std_logic_vector(1 downto 0);
 signal s_axi_bvalid_i : std_logic;
 signal pr_state_length_chk : std_logic;
 signal axi_full_sm_ns_IDLE_cmb : std_logic;
 signal last_data_reg: std_logic;
 signal rst_en : std_logic;
 signal s_axi_rvalid_cmb, last_data, burst_tr_i,rready_i, store_data : std_logic;
 signal Bus2IP_Reset_i : std_logic;
 -----
 begin
 -----
-------------------------------------------------------------------------------
-- Address registered
-------------------------------------------------------------------------------
-- REGISTERING_RESET_P: Invert the reset coming from AXI4
-----------------------
REGISTERING_RESET_P : process (S_AXI4_ACLK) is
-----
begin
-----
     if (S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        Bus2IP_Reset_i <=  not S_AXI4_ARESETN;
     end if;
end process REGISTERING_RESET_P;

Bus2IP_Reset   <= Bus2IP_Reset_i;
Bus2IP_Clk     <= S_AXI4_ACLK;
--Bus2IP_Resetn  <= S_AXI4_ARESETN;
--bus2ip_rnw_i     <= rnw_reg;-- '1' when S_AXI4_ARVALID='1' else '0';
BUS2IP_RNW     <= bus2ip_rnw_i;
Bus2IP_Data    <= S_AXI4_WDATA;
--Bus2IP_Addr    <= bus2ip_addr_i;
wr_transaction      <= S_AXI4_AWVALID and (S_AXI4_WVALID);

bus2ip_addr_i  <= ZEROS & S_AXI4_ARADDR(C_ADDR_DECODE_BITS downto 0) when (S_AXI4_ARVALID='1')
                  else
                  ZEROS & S_AXI4_AWADDR(C_ADDR_DECODE_BITS downto 0);
		  --S_AXI4_ARADDR(C_ADDR_DECODE_BITS+1 downto 0) when (S_AXI4_ARVALID='1')
                  --else                                                    
		  --S_AXI4_AWADDR(C_ADDR_DECODE_BITS+1 downto 0);                         


-- read and write transactions should be separate
-- preferencec of read over write
-- only narrow transfer of 8-bit are supported
-- for 16-bit and 32-bit transactions error should be generated - dont provide these signals to internal logic
--wr_transaction      <= S_AXI4_AWVALID and (S_AXI4_WVALID);
--wr_addr_transaction <= S_AXI4_AWVALID and (not S_AXI4_WVALID);
-------------------------------------------------------------------------------
AXI_ARREADY_P: process (S_AXI4_ACLK) is
begin
    if (S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
       if (Bus2IP_Reset_i = RESET_ACTIVE) then
          arready_i <='0';
       else
          arready_i  <= arready_cmb;
       end if;
    end if;
end process AXI_ARREADY_P;
--------------------------
S_AXI4_ARREADY <= arready_i; -- arready_i;--IP2Bus_RdAck; --arready_i;
--------------------------
AXI_AWREADY_P: process (S_AXI4_ACLK) is
begin
    if (S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
        if (Bus2IP_Reset_i = RESET_ACTIVE) then
          awready_i <='0';
        else
          awready_i  <= awready_cmb;
        end if;
    end if;
end process AXI_AWREADY_P;
--------------------------
S_AXI4_AWREADY <= awready_i;
--------------------------
S_AXI4_BRESP_P : process (S_AXI4_ACLK) is
  begin
    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
      if (axi_full_sm_ps = IDLE) then
         S_AXI4_BRESP_i <= (others => '0');
      elsif (axi_full_sm_ps = AXI_WR) or (axi_full_sm_ps = AXI_SINGLE_WR) then
         S_AXI4_BRESP_i <= (IP2Bus_Error) & '0';
      end if;
    end if;
end process S_AXI4_BRESP_P;
---------------------------
S_AXI4_BRESP <= S_AXI4_BRESP_i;
-------------------------------
--S_AXI_BVALID_I_P: below process provides logic for valid write response signal
-------------------
S_AXI_BVALID_I_P : process (S_AXI4_ACLK) is
  begin
    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
      if S_AXI4_ARESETN = '0' then
         s_axi_bvalid_i <= '0';
      elsif(axi_full_sm_ps = WR_RESP_1)then
         s_axi_bvalid_i <= '1';
      elsif(S_AXI4_BREADY = '1')then
         s_axi_bvalid_i <= '0';
      end if;
    end if;
end process S_AXI_BVALID_I_P;
-----------------------------
S_AXI4_BVALID <= s_axi_bvalid_i;
--------------------------------
----S_AXI_WREADY_I_P: below process provides logic for valid write response signal
---------------------
S_AXI_WREADY_I_P : process (S_AXI4_ACLK) is
  begin
    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
      if S_AXI4_ARESETN = '0' then
         s_axi_wready_i <= '0';
      else
         s_axi_wready_i <= wready_cmb;
      end if;
    end if;
end process S_AXI_WREADY_I_P;
-------------------------------
S_AXI4_WREADY <= s_axi_wready_i;
--------------------------------
-------------------------------------------------------------------------------
-- REG_BID_P,REG_RID_P: Below process makes the RID and BID '0' at POR and
--                    : generate proper values based upon read/write
--                      transaction
-----------------------
REG_RID_P: process (S_AXI4_ACLK) is
begin
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
       if (S_AXI4_ARESETN = '0') then
         S_AXI4_RID_reg       <= (others=> '0');
       elsif(store_axi_signal_cmb = '1')then
         S_AXI4_RID_reg       <= S_AXI4_ARID ;
       end if;
    end if;
end process REG_RID_P;
----------------------
S_AXI4_RID <= S_AXI4_RID_reg;
-----------------------------

REG_BID_P: process (S_AXI4_ACLK) is
begin
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
       if (S_AXI4_ARESETN=ACTIVE_LOW_RESET) then
         S_AXI4_BID_reg       <= (others=> '0');
       elsif(store_axi_signal_cmb = '1')then
         S_AXI4_BID_reg       <= S_AXI4_AWID;-- and pr_state_length_chk;
       end if;
    end if;
end process REG_BID_P;
-----------------------
S_AXI4_BID <= S_AXI4_BID_reg;
------------------------------
------------------------
-- BUS2IP_BE_P:Register Bus2IP_BE for write strobe during write mode else '1'.
------------------------
BUS2IP_BE_P: process (S_AXI4_ACLK) is
------------
begin
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
        if ((Bus2IP_Reset_i = RESET_ACTIVE)) then
            bus2ip_BE_reg   <= (others => '0');
        else
          if (rnw_cmb = '0'--    and
              --(wready_cmb = '1')
              ) then
              bus2ip_BE_reg <= S_AXI4_WSTRB;
          else -- if(rnw_cmb = '1') then
              bus2ip_BE_reg <= (others => '1');
          end if;
        end if;
    end if;
end process BUS2IP_BE_P;
------------------------
Bus2IP_BE      <= bus2ip_BE_reg;

axi_length_cmb <= S_AXI4_ARLEN when (rnw_cmb = '1')
                  else
                  S_AXI4_AWLEN;
burst_transfer_cmb <= (or_reduce(axi_length_cmb));

BURST_LENGTH_REG_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK='1')then
        if (S_AXI4_ARESETN=ACTIVE_LOW_RESET) then
            axi_length_reg <= (others => '0');
            burst_transfer_reg <= '0';
        elsif((store_axi_signal_cmb = '1'))then
            axi_length_reg <= axi_length_cmb;
            burst_transfer_reg <= burst_transfer_cmb;
        end if;
    end if;
end process BURST_LENGTH_REG_P;
-----------------------
burst_tr_i <= burst_transfer_reg;
burst_tr <= burst_tr_i;
-------------------------------------------------------------------------------
axi_size_cmb <= S_AXI4_ARSIZE(2 downto 0) when (rnw_cmb = '1')
                else
                S_AXI4_AWSIZE(2 downto 0);
SIZE_REG_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK='1')then
        if (S_AXI4_ARESETN=ACTIVE_LOW_RESET) then
            axi_size_reg <= (others => '0');
        elsif((store_axi_signal_cmb = '1'))then
            axi_size_reg <= axi_size_cmb;
        end if;
    end if;
end process SIZE_REG_P;
-----------------------
axi_burst_cmb <= S_AXI4_ARBURST when (rnw_cmb = '1')
                 else
                 S_AXI4_AWBURST;
BURST_REG_P:process(S_AXI4_ACLK)is
-----
begin
-----
    if(S_AXI4_ACLK'event and S_AXI4_ACLK='1')then
        if (S_AXI4_ARESETN = ACTIVE_LOW_RESET) then
            axi_burst_reg <= (others => '0');
        elsif(store_axi_signal_cmb = '1')then
            axi_burst_reg <= axi_burst_cmb;
        end if;
    end if;
end process BURST_REG_P;
-----------------------
combine_ack <= IP2Bus_WrAck or IP2Bus_RdAck;
--------------------------------------------
LENGTH_CNTR_P:process(S_AXI4_ACLK)is
begin
    if(S_AXI4_ACLK'event and S_AXI4_ACLK='1')then
        if (S_AXI4_ARESETN = ACTIVE_LOW_RESET) then
            length_cntr <= (others => '0');
        elsif((store_axi_signal_cmb = '1'))then
            length_cntr <= axi_length_cmb;
        elsif (wready_cmb = '1' and S_AXI4_WVALID = '1') or
              (S_AXI4_RREADY = '1' and s_axi_rvalid_i = '1') then   -- burst length error
            length_cntr <= length_cntr - '1';
        end if;
    end if;
end process LENGTH_CNTR_P;
--------------------------
--last_data_cmb    <= or_reduce(length_cntr(7 downto 1)) and length_cntr(1);
rready <= rready_i;

last_bt_one_data_cmb    <= not(or_reduce(length_cntr(7 downto 1))) and length_cntr(0) and S_AXI4_RREADY;
last_data_cmb <= not(or_reduce(length_cntr(7 downto 0)));
--temp_i           <= (combine_ack and last_data_reg)or rst_en;
LAST_DATA_ACKED_P: process (S_AXI4_ACLK) is
-----------------
begin
-----
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
        if(axi_full_sm_ps_IDLE_cmb = '1')     then
            last_data_acked <= '0';
        elsif(burst_tr_i = '0')then
            if(S_AXI4_RREADY = '1' and last_data_acked = '1')then
               last_data_acked <= '0';
            else
               last_data_acked <= last_data_cmb and s_axi_rvalid_cmb;
            end if;
        else
            if(S_AXI4_RREADY = '1' and last_data_acked = '1') then
                    last_data_acked <= '0';
            elsif(S_AXI4_RREADY = '0' and last_data_acked = '1')then
                last_data_acked <= '1';
            else
                last_data_acked <= last_data and s_axi_rvalid_i and S_AXI4_RREADY;
            end if;
        end if;
    end if;
end process LAST_DATA_ACKED_P;
------------------------------
S_AXI4_RLAST <= last_data_acked;
--------------------------------

-- S_AXI4_RDATA_RESP_P : BElow process generates the RRESP and RDATA on AXI
-----------------------
S_AXI4_RDATA_RESP_P : process (S_AXI4_ACLK) is
  begin
    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
      if (S_AXI4_ARESETN = '0') then
         S_AXI4_RRESP_i <= (others => '0');
         S_AXI4_RDATA_i <= (others => '0');
      elsif(S_AXI4_RREADY = '1' )or(store_data = '1') then --if --((axi_full_sm_ps = AXI_SINGLE_RD) or (axi_full_sm_ps = AXI_BURST_RD)) then
        S_AXI4_RRESP_i <= (IP2Bus_Error) & '0';
        S_AXI4_RDATA_i <=  IP2Bus_Data;
      end if;
    end if;
end process S_AXI4_RDATA_RESP_P;

S_AXI4_RRESP <= S_AXI4_RRESP_i;
S_AXI4_RDATA <= S_AXI4_RDATA_i;
-----------------------------
-- S_AXI_RVALID_I_P : below process generates the RVALID response on read channel
----------------------
S_AXI_RVALID_I_P : process (S_AXI4_ACLK) is
  begin
    if S_AXI4_ACLK'event and S_AXI4_ACLK = '1' then
      if (axi_full_sm_ps = IDLE) then
         s_axi_rvalid_i <= '0';
      elsif(S_AXI4_RREADY = '0') and (s_axi_rvalid_i = '1') then
          s_axi_rvalid_i <= s_axi_rvalid_i;
      else
          s_axi_rvalid_i <= s_axi_rvalid_cmb;
      end if;
    end if;
end process S_AXI_RVALID_I_P;
-----------------------------
S_AXI4_RVALID <= s_axi_rvalid_i;
-- -----------------------------

  --   Addr_int    <= S_AXI_ARADDR when(rnw_cmb_dup = '1')
  --                  else
  --                  S_AXI_AWADDR;
axi_full_sm_ns_IDLE_cmb <= '1' when (axi_full_sm_ns = IDLE) else '0';
axi_full_sm_ps_IDLE_cmb <= '1' when (axi_full_sm_ps = IDLE) else '0';
pr_state_idle           <= '1' when axi_full_sm_ps = IDLE else '0';
pr_state_length_chk     <= '1' when axi_full_sm_ps = CHECK_AXI_LENGTH_ERROR
                           else
                           '0';
REGISTER_LOWER_ADDR_BITS_P:process(S_AXI4_ACLK) is
begin
-----
     if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
        if (axi_full_sm_ps_IDLE_cmb = '1') then
            length_error <= '0';
        elsif(burst_transfer_cmb = '1')then -- means its a burst
             --if (bus2ip_addr_i (7 downto 3) = "01101")then
	     if (bus2ip_addr_i (6 downto 3) = "1101")then
                 length_error <= '0';
             else
                 length_error <= '1';
             end if;
        end if;
     end if;
end process REGISTER_LOWER_ADDR_BITS_P;
---------------------------------------
-- length_error <= '0';
---------------------------
REG_P: process (S_AXI4_ACLK) is
begin
-----
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
        if (Bus2IP_Reset_i = RESET_ACTIVE) then
            axi_full_sm_ps   <= IDLE;
            last_data_reg  <= '0';
        else
            axi_full_sm_ps   <= axi_full_sm_ns;
            last_data_reg  <= last_data_cmb;
        end if;
    end if;
end process REG_P;
-------------------------------------------------------
STORE_SIGNALS_P: process (S_AXI4_ACLK) is
begin
-----
    if (S_AXI4_ACLK'event and S_AXI4_ACLK='1') then
        if (Bus2IP_Reset_i = RESET_ACTIVE) then
            rnw_reg        <= '0';
        else-- if(store_axi_signal_cmb = '1')then
            rnw_reg        <= rnw_cmb;
        end if;
    end if;
end process STORE_SIGNALS_P;
-------------------------------------------------------
 AXI_FULL_STATE_MACHINE_P:process(
                                  axi_full_sm_ps        ,
                                  S_AXI4_ARVALID        ,
                                  S_AXI4_AWVALID        ,
                                  S_AXI4_WVALID         ,
                                  S_AXI4_BREADY         ,
                                  S_AXI4_RREADY         ,
                                  wr_transaction        ,
                                  wr_addr_transaction   ,
                                  length_error          ,
                                  IP2Bus_WrAck          ,
                                  last_data_cmb         ,
                                  IP2Bus_RdAck          ,
                                  IP2Bus_Error          ,
                                  burst_transfer_cmb    ,
                                  last_bt_one_data_cmb  ,
                                  rnw_reg               ,
                                  length_cntr
                                  )is

 -----
 begin
 -----
     arready_cmb <= '0';
     awready_cmb <= '0';
     wready_cmb  <= '0';
     start       <= '0';
     rst_en <= '0';
     temp_i <= '0';
     store_axi_signal_cmb <= '0';
     s_axi_rvalid_cmb <= '0';
     rready_i <= '0';
rnw_cmb <= '0';
last_data <= '0';
store_data <= '0';
     case axi_full_sm_ps is
     when IDLE                => if(S_AXI4_ARVALID = '1') then
                                   start <= '1';
                                   store_axi_signal_cmb <= '1';
                                   arready_cmb <= '1';
                                   if(burst_transfer_cmb = '1') then
                                       axi_full_sm_ns <= AXI_RD;
                                   else
                                       axi_full_sm_ns <= AXI_SINGLE_RD;
                                   end if;
                                 elsif(wr_transaction = '1')then
                                   start <= '1';
                                   store_axi_signal_cmb <= '1';
                                   if(burst_transfer_cmb = '1') then
                                       awready_cmb <= '1';
                                       wready_cmb  <= '1';
                                       axi_full_sm_ns <= AXI_WR;
                                   else
                                       axi_full_sm_ns <= AXI_SINGLE_WR;
                                   end if;
                                 else
                                     axi_full_sm_ns <= IDLE;
                                 end if;
                                 rnw_cmb <= S_AXI4_ARVALID and (not S_AXI4_AWVALID);
     ------------------------------
     when CHECK_AXI_LENGTH_ERROR => if (length_error = '0') then
                                        if(rnw_reg = '1')then
                                            arready_cmb <= '1';
                                            axi_full_sm_ns <= AXI_RD;
                                        else
                                            awready_cmb <= '1';
                                            axi_full_sm_ns <= AXI_WR;
                                        end if;
                                        start <= '1';
                                    else

                                        axi_full_sm_ns <= ERROR_RESP;
                                    end if;
     ---------------------------------------------------------
     when AXI_SINGLE_RD         => --arready_cmb       <= IP2Bus_RdAck;
                                   s_axi_rvalid_cmb  <= IP2Bus_RdAck or IP2Bus_Error;
                                   temp_i            <= IP2Bus_RdAck or IP2Bus_Error;
                                   rready_i <= '1';
                                   if(IP2Bus_RdAck = '1')or (IP2Bus_Error = '1') then
                                       store_data <= not S_AXI4_RREADY;
                                       axi_full_sm_ns <= RD_LAST;
                                   else
                                       axi_full_sm_ns <= AXI_SINGLE_RD;
                                   end if;
                                   rnw_cmb <= rnw_reg;
     when AXI_RD                =>
                                   rready_i <= S_AXI4_RREADY and not last_data_cmb;
                                   last_data <= last_bt_one_data_cmb;
                                   if(last_data_cmb = '1') then
                                         if(S_AXI4_RREADY = '1')then
                                           temp_i <= '1';--IP2Bus_RdAck;--IP2Bus_WrAck;
                                           rst_en <= '1';--IP2Bus_RdAck;--IP2Bus_WrAck;
                                           axi_full_sm_ns <= IDLE;
                                         else
                                           s_axi_rvalid_cmb <= not S_AXI4_RREADY;
                                           last_data <= not S_AXI4_RREADY;
                                           temp_i <= '1';
                                           axi_full_sm_ns <= RD_LAST;
                                         end if;
                                   else
                                          s_axi_rvalid_cmb  <= IP2Bus_RdAck or IP2Bus_Error; -- not last_data_cmb;
                                          axi_full_sm_ns <= AXI_RD;
                                   end if;
                                   rnw_cmb <= rnw_reg;
     ----------------------------------------------------------
     when AXI_SINGLE_WR         => awready_cmb <= IP2Bus_WrAck or IP2Bus_Error;
                                   wready_cmb  <= IP2Bus_WrAck or IP2Bus_Error;
                                   temp_i      <= IP2Bus_WrAck or IP2Bus_Error;

                                   if(IP2Bus_WrAck = '1')or (IP2Bus_Error = '1')then

                                       axi_full_sm_ns <= WR_RESP_1;
                                   else
                                       axi_full_sm_ns <= AXI_SINGLE_WR;
                                   end if;
                                   rnw_cmb <= rnw_reg;
     when AXI_WR                => --if(IP2Bus_WrAck = '1')then
                                      wready_cmb <= '1';--IP2Bus_WrAck;
                                      if(last_data_cmb = '1') then
                                          wready_cmb <= '0';
                                          temp_i <= '1';--IP2Bus_WrAck;
                                          rst_en <= '1';--IP2Bus_WrAck;
                                          axi_full_sm_ns <= WR_RESP_1;
                                      else
                                          axi_full_sm_ns <= AXI_WR;
                                      end if;
                                   rnw_cmb <= rnw_reg;
     -----------------------------------------------------------
     when WR_RESP_1             =>  --if(S_AXI4_BREADY = '1') then
                                    --        axi_full_sm_ns <= IDLE;
                                  --else
                                           axi_full_sm_ns <= WR_RESP_2;
                                 -- end if;
     -----------------------------------------------------------
     when WR_RESP_2             =>  if(S_AXI4_BREADY = '1') then
                                     axi_full_sm_ns <= IDLE;
                                 else
                                     axi_full_sm_ns <= WR_RESP_2;
                                 end if;
     -----------------------------------------------------------
     when RD_LAST           => if(S_AXI4_RREADY = '1') then -- and (TX_FIFO_Empty = '1') then
                                    last_data <= not S_AXI4_RREADY;
                                    axi_full_sm_ns <= IDLE;
                                 else
                                    last_data <= not S_AXI4_RREADY;
                                    s_axi_rvalid_cmb <= not S_AXI4_RREADY;
                                    axi_full_sm_ns <= RD_LAST;
                                    temp_i <= '1';
                                 end if;

     -----------------------------------------------------------
     when RD_RESP_2           => if(S_AXI4_RREADY = '1') then
                                    axi_full_sm_ns <= IDLE;
                                else
                                    axi_full_sm_ns <= RD_RESP_2;
                                end if;
     -----------------------------------------------------------

     when ERROR_RESP          => if(length_cntr = "00000000") and
                                      (S_AXI4_BREADY = '1') then
                                       axi_full_sm_ns <= IDLE;
                                    else
                                       axi_full_sm_ns <= ERROR_RESP;
                                    end if;
                                    response <= '1';

     when others =>              axi_full_sm_ns <= IDLE;
     end case;
 end process AXI_FULL_STATE_MACHINE_P;

 -------------------------------------------------------------------------------
  -- AXI Transaction Controller signals registered
-------------------------------------------------------------------------------

I_DECODER : entity axi_quad_spi_v3_2_9.qspi_address_decoder
    generic map
    (
     C_BUS_AWIDTH          => C_NUM_DECODE_BITS, -- C_S_AXI4_ADDR_WIDTH,
     C_S_AXI4_MIN_SIZE     => C_S_AXI_SPI_MIN_SIZE,
     C_ARD_ADDR_RANGE_ARRAY=> C_ARD_ADDR_RANGE_ARRAY,
     C_ARD_NUM_CE_ARRAY    => C_ARD_NUM_CE_ARRAY,
     C_FAMILY              => "nofamily"
    )
    port map
    (
     Bus_clk               =>  S_AXI4_ACLK,
     Bus_rst               =>  S_AXI4_ARESETN,
     Address_In_Erly       =>  bus2ip_addr_i(C_ADDR_DECODE_BITS downto 0), -- (C_ADDR_DECODE_BITS downto 0),
     Address_Valid_Erly    =>  start,
     Bus_RNW               =>  S_AXI4_ARVALID,
     Bus_RNW_Erly          =>  S_AXI4_ARVALID,
     CS_CE_ld_enable       =>  start,
     Clear_CS_CE_Reg       =>  temp_i,
     RW_CE_ld_enable       =>  start,
     CS_for_gaps           =>  open,
      -- Decode output signals
     CS_Out                =>  Bus2IP_CS,
     RdCE_Out              =>  Bus2IP_RdCE,
     WrCE_Out              =>  Bus2IP_WrCE
      );

 end architecture imp;
 ------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- axi_quad_spi_top.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_quad_spi.vhd
-- Version:         v3.0
-- Description:     This is the top-level design file for the AXI Quad SPI core logic.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_cmb"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>

-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.conv_std_logic_vector;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_signed.all;
    use ieee.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
    use ieee.std_logic_unsigned.all;

library unisim;
    use unisim.vcomponents.FD;
    use unisim.vcomponents.FDRE;
    use UNISIM.vcomponents.all;

library axi_lite_ipif_v3_0_4;
use axi_lite_ipif_v3_0_4.axi_lite_ipif;
use axi_lite_ipif_v3_0_4.ipif_pkg.all;


library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
-------------------------------------------------------------------------------

entity axi_quad_spi_top is
   generic(
       -- Async_Clk  parameter is added only for Vivado, it is not used in the design, this is
       -- NON HDL parameter
       Async_Clk                : integer              := 0;
       -- General Parameters
       C_FAMILY                 : string               := "virtex7";
       C_SELECT_XPM             : integer              := 1;
       C_SUB_FAMILY             : string               := "virtex7";
       C_INSTANCE               : string               := "axi_quad_spi_inst";
       -------------------------
       C_SPI_MEM_ADDR_BITS      : integer              := 24; -- allowed values are 24 or 32 only and used in XIP mode
       C_TYPE_OF_AXI4_INTERFACE : integer range 0 to 1 := 0;--default AXI4 Lite Legacy mode
       C_XIP_MODE               : integer range 0 to 1 := 0;--default NON XIP Mode
       C_UC_FAMILY              : integer range 0 to 1 := 0;--default NON XIP Mode
       --C_AXI4_CLK_PS            : integer              := 10000;--AXI clock period
       --C_EXT_SPI_CLK_PS         : integer              := 10000;--ext clock period
       C_FIFO_DEPTH             : integer              := 256;-- allowed 0,16,256.
       C_SCK_RATIO              : integer              := 16;--default in legacy mode
       C_NUM_SS_BITS            : integer range 1 to 32:= 1;
       C_NUM_TRANSFER_BITS      : integer              := 8; -- allowed 8, 16, 32
       -------------------------
       C_SPI_MODE               : integer range 0 to 2 := 0; -- used for differentiating
                                                             -- Standard, Dual or Quad mode
                                                             -- in Ports as well as internal
                                                             -- functionality
       C_USE_STARTUP            : integer range 0 to 1 := 1; --
       C_SPI_MEMORY             : integer range 0 to 3 := 1; -- 0 - mixed mode,
                                                             -- 1 - winbond,
                                                             -- 2 - numonyx
															 -- 3 - spansion
                                                             -- used to differentiate
                                                             -- internal look up table
                                                             -- for commands.
       -------------------------
       -- AXI4 Lite Interface Parameters  *as max address is 7c, only 7 address bits are used
       C_S_AXI_ADDR_WIDTH       : integer range 7  to 7  := 7;
       C_S_AXI_DATA_WIDTH       : integer range 32 to 32 := 32;
       -------------------------
       --*C_BASEADDR               : std_logic_vector       := x"FFFFFFFF";
       --*C_HIGHADDR               : std_logic_vector       := x"00000000";
       -------------------------
       -- AXI4 Full Interface Parameters *as max 24 bits of address are supported on SPI interface, only 24 address bits are used
       C_S_AXI4_ADDR_WIDTH      : integer                     ;--range 24 to 24 := 24;
       C_S_AXI4_DATA_WIDTH      : integer range 32 to 32 := 32;
       C_S_AXI4_ID_WIDTH        : integer range 1 to 16  := 4 ;
       C_SHARED_STARTUP    : integer range 0 to 1 := 0;
       -------------------------
       -- To FIX CR# 685366, below lines are added again in RTL (Vivado Requirement), but these parameters are not used in the core RTL
       C_S_AXI4_BASEADDR          : std_logic_vector       := x"FFFFFFFF";
       C_S_AXI4_HIGHADDR          : std_logic_vector       := x"00000000";
       -------------------------
       C_LSB_STUP            : integer range 0 to 1 := 0;
       C_DUAL_MODE            : integer range 0 to 1 := 0;
       C_STARTUP_EXT          : integer range 0 to 1 := 0
  );
   port(
       -- external async clock for SPI interface logic
       ext_spi_clk    : in std_logic;
       -- axi4 lite interface clk and reset signals
       s_axi_aclk     : in std_logic;
       s_axi_aresetn  : in std_logic;
       -- axi4 full interface clk and reset signals
       s_axi4_aclk    : in std_logic;
       s_axi4_aresetn : in std_logic;
       -------------------------------
       -------------------------------
       --*axi4 lite port interface* --
       -------------------------------
       -------------------------------
       -- axi write address channel signals
       ---------------
       s_axi_awaddr   : in std_logic_vector (6 downto 0);--((C_S_AXI_ADDR_WIDTH-1) downto 0);
       s_axi_awvalid  : in std_logic;
       s_axi_awready  : out std_logic;
       ---------------
       -- axi write data channel signals
       ---------------
       s_axi_wdata    : in std_logic_vector(31 downto 0); -- ((C_S_AXI_DATA_WIDTH-1) downto 0);
       s_axi_wstrb    : in std_logic_vector(3 downto 0); -- (((C_S_AXI_DATA_WIDTH/8)-1) downto 0);
       s_axi_wvalid   : in std_logic;
       s_axi_wready   : out std_logic;
       ---------------
       -- axi write response channel signals
       ---------------
       s_axi_bresp    : out std_logic_vector(1 downto 0);
       s_axi_bvalid   : out std_logic;
       s_axi_bready   : in  std_logic;
       ---------------
       -- axi read address channel signals
       ---------------
       s_axi_araddr   : in  std_logic_vector(6 downto 0); -- ((C_S_AXI_ADDR_WIDTH-1) downto 0);
       s_axi_arvalid  : in  std_logic;
       s_axi_arready  : out std_logic;
       ---------------
       -- axi read address channel signals
       ---------------
       s_axi_rdata    : out std_logic_vector(31 downto 0); -- ((C_S_AXI_DATA_WIDTH-1) downto 0);
       s_axi_rresp    : out std_logic_vector(1 downto 0);
       s_axi_rvalid   : out std_logic;
       s_axi_rready   : in  std_logic;
       -------------------------------
       -------------------------------
       --*axi4 full port interface* --
       -------------------------------
       ------------------------------------
       -- axi write address Channel Signals
       ------------------------------------
       s_axi4_awid    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_awaddr  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1) downto 0); --((C_S_AXI4_ADDR_WIDTH-1) downto 0);
       s_axi4_awlen   : in  std_logic_vector(7 downto 0);
       s_axi4_awsize  : in  std_logic_vector(2 downto 0);
       s_axi4_awburst : in  std_logic_vector(1 downto 0);
       s_axi4_awlock  : in  std_logic;                   -- not supported in design
       s_axi4_awcache : in  std_logic_vector(3 downto 0);-- not supported in design
       s_axi4_awprot  : in  std_logic_vector(2 downto 0);-- not supported in design
       s_axi4_awvalid : in  std_logic;
       s_axi4_awready : out std_logic;
       ---------------------------------------
       -- axi4 full write Data Channel Signals
       ---------------------------------------
       s_axi4_wdata   : in  std_logic_vector(31 downto 0); -- ((C_S_AXI4_DATA_WIDTH-1)downto 0);
       s_axi4_wstrb   : in  std_logic_vector(3 downto 0); -- (((C_S_AXI4_DATA_WIDTH/8)-1) downto 0);
       s_axi4_wlast   : in  std_logic;
       s_axi4_wvalid  : in  std_logic;
       s_axi4_wready  : out std_logic;
       -------------------------------------------
       -- axi4 full write Response Channel Signals
       -------------------------------------------
       s_axi4_bid     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_bresp   : out std_logic_vector(1 downto 0);
       s_axi4_bvalid  : out std_logic;
       s_axi4_bready  : in  std_logic;
       -----------------------------------
       -- axi read address Channel Signals
       -----------------------------------
       s_axi4_arid    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_araddr  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1) downto 0);--((C_S_AXI4_ADDR_WIDTH-1) downto 0);
       s_axi4_arlen   : in  std_logic_vector(7 downto 0);
       s_axi4_arsize  : in  std_logic_vector(2 downto 0);
       s_axi4_arburst : in  std_logic_vector(1 downto 0);
       s_axi4_arlock  : in  std_logic;                -- not supported in design
       s_axi4_arcache : in  std_logic_vector(3 downto 0);-- not supported in design
       s_axi4_arprot  : in  std_logic_vector(2 downto 0);-- not supported in design
       s_axi4_arvalid : in  std_logic;
       s_axi4_arready : out std_logic;
       --------------------------------
       -- axi read data Channel Signals
       --------------------------------
       s_axi4_rid     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_rdata   : out std_logic_vector(31 downto 0);--((C_S_AXI4_DATA_WIDTH-1) downto 0);
       s_axi4_rresp   : out std_logic_vector(1 downto 0);
       s_axi4_rlast   : out std_logic;
       s_axi4_rvalid  : out std_logic;
       s_axi4_rready  : in  std_logic;
       --------------------------------
       -------------------------------
       --*SPI port interface      * --
       -------------------------------
       io0_i          : in std_logic;  -- MOSI signal in standard SPI
       io0_o          : out std_logic;
       io0_t          : out std_logic;
       -------------------------------
       io1_i          : in std_logic;  -- MISO signal in standard SPI
       io1_o          : out std_logic;
       io1_t          : out std_logic;
       -----------------
       -- quad mode pins
       -----------------
       io2_i          : in std_logic;
       io2_o          : out std_logic;
       io2_t          : out std_logic;
       ---------------
       io3_i          : in std_logic;
       io3_o          : out std_logic;
       io3_t          : out std_logic;
       ---------------------------------
       -- common pins
       ----------------
       spisel         : in std_logic;
       -----
       sck_i          : in std_logic;
       sck_o          : out std_logic;
       sck_t          : out std_logic;
       -----
       ss_i           : in std_logic_vector((C_NUM_SS_BITS-1) downto C_LSB_STUP);
       ss_o           : out std_logic_vector((C_NUM_SS_BITS-1) downto C_LSB_STUP);
       ss_t           : out std_logic;
	   
	   ------------------------
	   -- STARTUP INTERFACE
	   ------------------------
	   cfgclk  : out std_logic;       -- FGCLK        , -- 1-bit output: Configuration main clock output
       cfgmclk : out std_logic; -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
       eos     : out std_logic;  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
       preq    : out std_logic; -- REQ          , -- 1-bit output: PROGRAM request to fabric output
       clk     : in std_logic;   -- input
       gsr     : in std_logic;   -- input
       gts     : in std_logic;   -- input
       keyclearb : in std_logic;   -- input
       usrcclkts : in std_logic;   -- input
       usrdoneo : in std_logic;   -- input
       usrdonets : in std_logic;   -- input
       pack : in std_logic;   -- input
       ----------------------
       -- INTERRUPT INTERFACE
       ----------------------
       ip2intc_irpt   : out std_logic
       ---------------------------------
   );
       -------------------------------
     -- Fan-out attributes for XST
     attribute MAX_FANOUT                             : string;
     attribute MAX_FANOUT of S_AXI_ACLK               : signal is "10000";
     attribute MAX_FANOUT of S_AXI4_ACLK              : signal is "10000";
     attribute MAX_FANOUT of EXT_SPI_CLK              : signal is "10000";
     attribute MAX_FANOUT of S_AXI_ARESETN            : signal is "10000";
     attribute MAX_FANOUT of S_AXI4_ARESETN           : signal is "10000";

     attribute INITIALVAL  : string;
     attribute INITIALVAL of SPISEL                   : signal is "VCC";
	 
       -------------------------------
end entity axi_quad_spi_top;
--------------------------------------------------------------------------------

architecture imp of axi_quad_spi_top is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

---------------------------------------------------------------------------------
---- constant added for webtalk information
---------------------------------------------------------------------------------
 -- constant C_CORE_GENERATION_INFO : string := C_INSTANCE & ",axi_quad_spi,{"
 --     & "C_FAMILY = "                    & C_FAMILY
 --     & ",C_SUB_FAMILY = "               & C_SUB_FAMILY
 --     & ",C_INSTANCE = "                 & C_INSTANCE
 --     & ",C_S_AXI_ADDR_WIDTH = "         & integer'image(C_S_AXI_ADDR_WIDTH)
 --     & ",C_S_AXI_DATA_WIDTH = "         & integer'image(C_S_AXI_DATA_WIDTH)
 --     & ",C_S_AXI4_ADDR_WIDTH = "        & integer'image(C_S_AXI4_ADDR_WIDTH)
 --     & ",C_S_AXI4_DATA_WIDTH = "        & integer'image(C_S_AXI4_DATA_WIDTH)
 --     & ",C_S_AXI4_ID_WIDTH = "          & integer'image(C_S_AXI4_ID_WIDTH)
 --     & ",C_FIFO_DEPTH = "               & integer'image(C_FIFO_DEPTH)
 --     & ",C_SCK_RATIO = "                & integer'image(C_SCK_RATIO)
 --     & ",C_NUM_SS_BITS = "              & integer'image(C_NUM_SS_BITS)
 --     & ",C_NUM_TRANSFER_BITS = "        & integer'image(C_NUM_TRANSFER_BITS)
 --     & ",C_USE_STARTUP = "              & integer'image(C_USE_STARTUP)
 --     & ",C_SPI_MODE = "                 & integer'image(C_SPI_MODE)
 --     & ",C_SPI_MEMORY = "               & integer'image(C_SPI_MEMORY)
 --     & ",C_TYPE_OF_AXI4_INTERFACE = "   & integer'image(C_TYPE_OF_AXI4_INTERFACE)
 --     & ",C_XIP_MODE = "                 & integer'image(C_XIP_MODE)
 --     & "}";
 -- 
 -- attribute CORE_GENERATION_INFO : string;
 -- attribute CORE_GENERATION_INFO of imp : architecture is C_CORE_GENERATION_INFO;
-------------------------------------------------------------

 -------------------------------------------------------------
 -- Function Declaration
 -------------------------------------------------------------
 -- get_fifo_presence - This function returns the 0 or 1 based upon the FIFO Depth.
 --
 function get_fifo_presence(C_FIFO_DEPTH: integer) return integer is
 -----
 begin
 -----
        if(C_FIFO_DEPTH = 0)then
                return 0;
        else
                return 1;
        end if;
 end function get_fifo_presence;


 function get_fifo_depth(C_FIFO_EXIST: integer; C_FIFO_DEPTH : integer) return integer is
 -----
 begin
 -----
        if(C_FIFO_EXIST = 1)then
                return C_FIFO_DEPTH;
        else
                return 64; -- to ensure that log2 functions does not become invalid
        end if;
 end function get_fifo_depth;

 ------------------------------
 function get_fifo_occupancy_count(C_FIFO_DEPTH: integer) return integer is
 -----
    variable j  : integer := 0;
    variable k  : integer := 0;
 -----
 begin
 -----
    if (C_FIFO_DEPTH = 0) then
        return 4;
    else
        for i in 0 to 11 loop
                if(2**i >= C_FIFO_DEPTH) then
                        if(k = 0) then
                                j := i;
                        end if;
                        k := 1;
                end if;
        end loop;
        return j;
    end if;
    -------
 end function get_fifo_occupancy_count;
 ------------------------------

 -- Constant declarations
 ------------------------------
 --------------------- ******************* ------------------------------------
 --                      Core Parameters
 --------------------- ******************* ------------------------------------
  --
 constant C_FIFO_EXIST         : integer  := get_fifo_presence(C_FIFO_DEPTH);
 constant C_FIFO_DEPTH_UPDATED : integer  := get_fifo_depth(C_FIFO_EXIST, C_FIFO_DEPTH);

 -- width of control register
 constant C_SPICR_REG_WIDTH    : integer  := 10;-- refer DS

 -- width of status register
 constant C_SPISR_REG_WIDTH    : integer  := 11;-- refer DS

 -- count the counter width for calculating FIFO occupancy
 constant C_OCCUPANCY_NUM_BITS : integer  := get_fifo_occupancy_count(C_FIFO_DEPTH_UPDATED);

 -- width of spi shift register
 constant C_SPI_NUM_BITS_REG   : integer  := 8;-- this is fixed

 constant C_NUM_SPI_REGS       : integer  := 8;-- this is fixed

 constant C_IPISR_IPIER_BITS   : integer  := 14;-- total 14 interrupts - 0 to 13


 --------------------- ******************* ------------------------------------
 --                    AXI lite parameters
 --------------------- ******************* ------------------------------------
 constant C_S_AXI_SPI_MIN_SIZE : std_logic_vector(31 downto 0):= X"0000007c";
 constant C_USE_WSTRB          : integer := 1;
 constant C_DPHASE_TIMEOUT     : integer := 20;

 -- interupt mode
 constant IP_INTR_MODE_ARRAY   : INTEGER_ARRAY_TYPE(0 to (C_IPISR_IPIER_BITS-1)):=
 (
  others => INTR_REG_EVENT
 -- when C_SPI_MODE = 0
 -- Seven  interrupts if C_FIFO_DEPTH_UPDATED = 0
 -- OR
 -- Eight interrupts if C_FIFO_DEPTH_UPDATED = 0 and slave mode
 ----------------------- OR ---------------------------
 -- Nine  interrupts if C_FIFO_DEPTH_UPDATED = 16 and slave mode
 -- OR
 -- Seven interrupts if C_FIFO_DEPTH_UPDATED = 16 and master mode

 -- when C_SPI_MODE = 1 or 2
 -- Thirteen interrupts if C_FIFO_DEPTH_UPDATED = 16 and master mode
 );

 constant ZEROES               : std_logic_vector(31 downto 0):= X"00000000";

 -- this constant is defined as the start of SPI register addresses.
 constant C_IP_REG_ADDR_OFFSET : std_logic_vector := X"00000060";

 -- Address range array
 constant C_ARD_ADDR_RANGE_ARRAY: SLV64_ARRAY_TYPE :=
  (
 -- interrupt address base & high range
   --ZEROES & C_BASEADDR,
   --ZEROES & (C_BASEADDR or X"0000003F"),--interrupt address higher range
   ZEROES & X"00000000",
   ZEROES & X"0000003F",--interrupt address higher range

 -- soft reset register base & high addr
   --ZEROES & (C_BASEADDR or X"00000040"),
   --ZEROES & (C_BASEADDR or X"00000043"),--soft reset register high addr
   ZEROES & X"00000040",
--   ZEROES & X"00000043",--soft reset register high addr
   ZEROES & X"0000005C",--soft reset register NEW high addr for addressing holes


 -- SPI registers Base & High Address
 -- Range is 60 to 78 -- for internal registers
   --ZEROES & (C_BASEADDR or C_IP_REG_ADDR_OFFSET),
   --ZEROES & (C_BASEADDR or C_IP_REG_ADDR_OFFSET or X"00000018")
   ZEROES &  C_IP_REG_ADDR_OFFSET,
   ZEROES & (C_IP_REG_ADDR_OFFSET or X"00000018")
 );

  -- AXI4 Address range array
 constant C_ARD_ADDR_RANGE_ARRAY_AXI4_FULL: SLV64_ARRAY_TYPE :=
  (
 -- interrupt address base & high range
   --*ZEROES & C_S_AXI4_BASEADDR,
   --*ZEROES & (C_S_AXI4_BASEADDR or X"0000003F"),--interrupt address higher range
   ZEROES & X"00000000",
   ZEROES & X"0000003F",--soft reset register high addr

 -- soft reset register base & high addr
   --*ZEROES & (C_S_AXI4_BASEADDR or X"00000040"),
   --*ZEROES & (C_S_AXI4_BASEADDR or X"00000043"),--soft reset register high addr
   ZEROES & X"00000040",
--   ZEROES & X"00000043",--soft reset register high addr
   ZEROES & X"0000005C",--soft reset register NEW high addr for addressing holes

 -- SPI registers Base & High Address
 -- Range is 60 to 78 -- for internal registers
   ZEROES & (C_IP_REG_ADDR_OFFSET),
   ZEROES & (C_IP_REG_ADDR_OFFSET or X"00000018")
 );

-- No. of CE's required per address range
 constant C_ARD_NUM_CE_ARRAY     : INTEGER_ARRAY_TYPE :=
 (
  0 => 16    ,             -- 16  CEs required for interrupt
  --1 => 1,                  -- 1   CE  required for soft reset
  1 => 8,                  -- 8   CE  required for Addressing Holes in soft reset
  2 => C_NUM_SPI_REGS
 );

 -- no. of Chip Enable Signals
 constant C_NUM_CE_SIGNALS      : integer := calc_num_ce(C_ARD_NUM_CE_ARRAY);
 -- no. of Chip Select Signals
 constant C_NUM_CS_SIGNALS      : integer := (C_ARD_ADDR_RANGE_ARRAY'LENGTH/2);
 -----------------------------
 ----------------------- ******************* ------------------------------------
 ----                    XIP Mode parameters
 ----------------------- ******************* ------------------------------------
 -- No. of XIP SPI registers
 constant C_NUM_XIP_SPI_REGS   : integer  := 2;-- this is fixed
 -- width of XIP control register
 constant C_XIP_SPICR_REG_WIDTH: integer  := 2;-- refer DS
 -- width of XIP status register
 constant C_XIP_SPISR_REG_WIDTH: integer  := 5;-- refer DS

 -- Address range array
 constant C_XIP_LITE_ARD_ADDR_RANGE_ARRAY: SLV64_ARRAY_TYPE :=
  (
 -- XIP SPI registers Base & High Address
 -- Range is 60 to 64 -- for internal registers
   --*ZEROES & (C_BASEADDR or C_IP_REG_ADDR_OFFSET),
   --*ZEROES & (C_BASEADDR or C_IP_REG_ADDR_OFFSET or X"00000004")
   ZEROES & (C_IP_REG_ADDR_OFFSET),
   ZEROES & (C_IP_REG_ADDR_OFFSET or X"00000004")
 );

 -- No. of CE's required per address range
 constant C_XIP_LITE_ARD_NUM_CE_ARRAY     : INTEGER_ARRAY_TYPE :=
 (
  0 => C_NUM_XIP_SPI_REGS    -- 2  CEs required for XIP lite interface
 );

 -- no. of Chip Enable Signals
 constant C_NUM_XIP_CE_SIGNALS      : integer :=
                                    calc_num_ce(C_XIP_LITE_ARD_NUM_CE_ARRAY);

 function assign_addr_bits (addr_bits_info : integer) return string is
          variable addr_width_24 : integer:= 24;
          variable addr_width_32 : integer:= 32;
 begin
      if addr_bits_info = 24 then -- old logic for 24 bit addressing
         return X"00FFFFFF";--addr_width_24;
      else
         return X"FFFFFFFF";--addr_width_32;
      end if;
 end function assign_addr_bits;

 constant C_XIP_ADDR_OFFSET : std_logic_vector := X"FFFFFFFF";--assign_addr_bits(C_SPI_MEM_ADDR_BITS); -- X"00FFFFFF";
 -- XIP Full Interface Address range array
 constant C_XIP_FULL_ARD_ADDR_RANGE_ARRAY: SLV64_ARRAY_TYPE :=
  (
 -- XIP SPI registers Base & High Address
 -- Range is 60 to 64 -- for internal registers
   --*ZEROES & (C_S_AXI4_BASEADDR),
   --*ZEROES & (C_S_AXI4_BASEADDR or C_24_BIT_ADDR_OFFSET)
   ZEROES & X"00000000",
   ZEROES & C_XIP_ADDR_OFFSET
 );
 -- No. of CE's required per address range
 constant C_XIP_FULL_ARD_NUM_CE_ARRAY     : INTEGER_ARRAY_TYPE :=
 (
  0 => C_NUM_XIP_SPI_REGS    -- 0 CEs required for XIP Full interface
 );
 ---------------------------------------------------------------------------------
 constant C_XIP_FIFO_DEPTH : integer := 264;
 -------------------------------------------------------------------------------
----Startup Signals
signal di_int  : std_logic_vector(3 downto 0); 	   -- output
signal di_int_sync  : std_logic_vector(3 downto 0); 	   -- output
signal dts_int : std_logic_vector(3 downto 0); 	   -- input
signal do_int  : std_logic_vector(3 downto 0); 	   -- input

 -- signal declaration
 signal bus2ip_clk           : std_logic;
 signal bus2ip_be_int        : std_logic_vector
                                     (((C_S_AXI_DATA_WIDTH/8)-1)downto 0);
 signal bus2ip_rdce_int      : std_logic_vector
                                       ((C_NUM_CE_SIGNALS-1)downto 0);
 signal bus2ip_wrce_int      : std_logic_vector
                                       ((C_NUM_CE_SIGNALS-1)downto 0);
 signal bus2ip_data_int      : std_logic_vector
                                       ((C_S_AXI_DATA_WIDTH-1)downto 0);
 signal ip2bus_data_int      : std_logic_vector
                                       ((C_S_AXI_DATA_WIDTH-1)downto 0 )
                             := (others  => '0');
 signal ip2bus_wrack_int     : std_logic := '0';
 signal ip2bus_rdack_int     : std_logic := '0';
 signal ip2bus_error_int     : std_logic := '0';

 signal bus2ip_reset_int     : std_logic;

 signal bus2ip_reset_ipif_inverted: std_logic;

 -- XIP signals
 signal bus2ip_xip_rdce_int: std_logic_vector(0 to C_NUM_XIP_CE_SIGNALS-1);
 signal bus2ip_xip_wrce_int: std_logic_vector(0 to C_NUM_XIP_CE_SIGNALS-1);

 signal io0_i_sync : std_logic;
 signal io1_i_sync : std_logic;
 signal io2_i_sync : std_logic;
 signal io3_i_sync : std_logic;
 signal io0_i_sync_int : std_logic;
 signal io1_i_sync_int : std_logic;
 signal io2_i_sync_int : std_logic;
 signal io3_i_sync_int : std_logic;

 signal io0_i_int : std_logic;
 signal io1_i_int : std_logic;
 signal io2_i_int : std_logic;
 signal io3_i_int : std_logic;
 signal io0_o_int : std_logic;
 signal io1_o_int : std_logic;
 signal io2_o_int : std_logic;
 signal io3_o_int : std_logic;
 signal io0_t_int : std_logic;
 signal io1_t_int : std_logic;
 signal io2_t_int : std_logic;
 signal io3_t_int : std_logic;

 signal burst_tr_int : std_logic;
 signal rready_int : std_logic;
 signal bus2ip_reset_ipif4_inverted : std_logic;
signal fcsbo_int  : std_logic;
signal ss_o_int  : std_logic_vector((C_NUM_SS_BITS-1) downto 0);
signal ss_t_int  : std_logic;
signal ss_i_int  : std_logic_vector((C_NUM_SS_BITS-1) downto 0);
signal fcsbts_int  : std_logic;
signal startup_di : std_logic_vector(1 downto 0);   -- output
signal startup_do : std_logic_vector(1 downto 0) := (others => '1');   -- output
signal startup_dts : std_logic_vector(1 downto 0) := (others => '0');   -- output

-----
begin
-----
 --------STUP and XIP mode
  
  STARTUP_USED_1: if (C_USE_STARTUP = 1 and C_UC_FAMILY = 1) generate
  begin
  DI_INT_IO3_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => di_int_sync(3),
          C  => EXT_SPI_CLK,
          D  => di_int(3) --MOSI_I
          );
     DI_INT_IO2_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => di_int_sync(2),
          C  => EXT_SPI_CLK,
          D  => di_int(2) -- MISO_I
          );
     DI_INT_IO1_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => di_int_sync(1),
            C  => EXT_SPI_CLK,
            D  => di_int(1)
            );
     -----------------------
     DI_INT_IO0_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => di_int_sync(0),
            C  => EXT_SPI_CLK,
            D  => di_int(0)
            );

     
   io0_i_sync_int <= di_int_sync(0);
   io1_i_sync_int <= di_int_sync(1);
   io2_i_sync_int <= di_int_sync(2);
   io3_i_sync_int <= di_int_sync(3);

  end generate STARTUP_USED_1;
 DATA_STARTUP_EN : if (C_USE_STARTUP = 1 and C_UC_FAMILY = 1 and C_XIP_MODE = 1)
generate
   -----
    begin
   -----
do_int(0) <= io0_o_int;
dts_int(0) <= io0_t_int ;
do_int(1) <= io1_o_int;
dts_int(1) <= io1_t_int ;
fcsbo_int <= ss_o_int(0);  
fcsbts_int <= ss_t_int; 
NUM_SS : if (C_NUM_SS_BITS = 1) generate
begin
ss_o <= (others => '0');
ss_t <= '0';
end generate NUM_SS;
NUM_SS_G1 : if (C_NUM_SS_BITS > 1) generate
begin

ss_i_int <= ss_i((C_NUM_SS_BITS-1) downto 1) & '1';
ss_o <= ss_o_int((C_NUM_SS_BITS-1) downto 1);-- & '0';
ss_t <= ss_t_int;


end generate NUM_SS_G1;
DATA_OUT_NQUAD: if C_SPI_MODE = 0 or C_SPI_MODE = 1 generate
begin
startup_di <= di_int_sync(3) & di_int_sync(2);
do_int(2) <= startup_do(0);
do_int(3) <= startup_do(1);
dts_int(2) <= startup_dts(0);
dts_int(3) <= startup_dts(1);
--do <= do_int(3) & do_int(1);
--dts <= dts_int(3) & dts_int(1);
end generate DATA_OUT_NQUAD;
DATA_OUT_QUAD: if C_SPI_MODE = 2 generate
begin
--di <= "00";--di_int(3) & di_int(2);
do_int(2) <= io2_o_int;--do(2);
do_int(3) <= io3_o_int;--do(1);
--do <= do_int(3) & do_int(1);
dts_int(2) <= io2_t_int;--dts_int(3) & dts_int(1);
dts_int(3) <= io3_t_int;--dts_int(3) & dts_int(1);
end generate DATA_OUT_QUAD;
end generate DATA_STARTUP_EN;

DATA_STARTUP_DIS : if ((C_USE_STARTUP = 0 or (C_USE_STARTUP = 1 and C_UC_FAMILY = 0)) and C_XIP_MODE = 1)
generate
   -----
    begin
   -----
io0_o <= io0_o_int;
io0_t <= io0_t_int;
io1_t <= io1_t_int;
io1_o <= io1_o_int;
io2_o <= io2_o_int;
io2_t <= io2_t_int;
io3_t <= io3_t_int;
io3_o <= io3_o_int;
ss_i_int <= ss_i;
ss_o <= ss_o_int;-- & '0';
ss_t <= ss_t_int;

    end generate DATA_STARTUP_DIS;


 --------STUP and XIP mode off
  
  STARTUP_USED: if (C_USE_STARTUP = 0 or C_UC_FAMILY = 0) generate
  begin
   io0_i_sync_int <= io0_i_sync;
   io1_i_sync_int <= io1_i_sync;
   io2_i_sync_int <= io2_i_sync;
   io3_i_sync_int <= io3_i_sync;

  end generate STARTUP_USED;


    IO0_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => io0_i_sync,
          C  => ext_spi_clk,
          D  => io0_i --MOSI_I
          );
     IO1_I_REG: component FD
     generic map
          (
          INIT => '0'
          )
     port map
          (
          Q  => io1_i_sync,
          C  => ext_spi_clk,
          D  => io1_i -- MISO_I
          );
     IO2_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => io2_i_sync,
            C  => ext_spi_clk,
            D  => io2_i
            );
     -----------------------
     IO3_I_REG: component FD
       generic map
            (
            INIT => '0'
            )
       port map
            (
            Q  => io3_i_sync,
            C  => ext_spi_clk,
            D  => io3_i
            );
     -----------------------

-------------------------------------------------------------------------------
---------------
-- AXI_QUAD_SPI_LEGACY_MODE: This logic is legacy AXI4 Lite interface based design
---------------
QSPI_LEGACY_MD_GEN : if C_TYPE_OF_AXI4_INTERFACE = 0 generate
---------------
begin
-----
     AXI_LITE_IPIF_I : entity axi_lite_ipif_v3_0_4.axi_lite_ipif
     generic map
     (
      ----------------------------------------------------
      C_S_AXI_ADDR_WIDTH        => C_S_AXI_ADDR_WIDTH    ,
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH    ,
      ----------------------------------------------------
      C_S_AXI_MIN_SIZE          => C_S_AXI_SPI_MIN_SIZE  ,
      C_USE_WSTRB               => C_USE_WSTRB           ,
      C_DPHASE_TIMEOUT          => C_DPHASE_TIMEOUT      ,
      ----------------------------------------------------
      C_ARD_ADDR_RANGE_ARRAY    => C_ARD_ADDR_RANGE_ARRAY,
      C_ARD_NUM_CE_ARRAY        => C_ARD_NUM_CE_ARRAY    ,
      C_FAMILY                  => C_FAMILY
      ----------------------------------------------------
     )
     port map
     (
      ---------------------------------------------------------
      S_AXI_ACLK                =>  s_axi_aclk,           -- in
      S_AXI_ARESETN             =>  s_axi_aresetn,        -- in
      ---------------------------------------------------------
      S_AXI_AWADDR              =>  s_axi_awaddr,         -- in
      S_AXI_AWVALID             =>  s_axi_awvalid,        -- in
      S_AXI_AWREADY             =>  s_axi_awready,        -- out
      S_AXI_WDATA               =>  s_axi_wdata,          -- in
      S_AXI_WSTRB               =>  s_axi_wstrb,          -- in
      S_AXI_WVALID              =>  s_axi_wvalid,         -- in
      S_AXI_WREADY              =>  s_axi_wready,         -- out
      S_AXI_BRESP               =>  s_axi_bresp,          -- out
      S_AXI_BVALID              =>  s_axi_bvalid,         -- out
      S_AXI_BREADY              =>  s_axi_bready,         -- in
      S_AXI_ARADDR              =>  s_axi_araddr,         -- in
      S_AXI_ARVALID             =>  s_axi_arvalid,        -- in
      S_AXI_ARREADY             =>  s_axi_arready,        -- out
      S_AXI_RDATA               =>  s_axi_rdata,          -- out
      S_AXI_RRESP               =>  s_axi_rresp,          -- out
      S_AXI_RVALID              =>  s_axi_rvalid,         -- out
      S_AXI_RREADY              =>  s_axi_rready,         -- in
      ----------------------------------------------------------
      -- IP Interconnect (IPIC) port signals
      Bus2IP_Clk                => bus2ip_clk,            -- out
      Bus2IP_Resetn             => bus2ip_reset_int,      -- out
      ----------------------------------------------------------
      Bus2IP_Addr               => open,                  -- out -- not used signal
      Bus2IP_RNW                => open,                  -- out
      Bus2IP_BE                 => bus2ip_be_int,         -- out
      Bus2IP_CS                 => open,                  -- out -- not used signal
      Bus2IP_RdCE               => bus2ip_rdce_int,       -- out -- little endian
      Bus2IP_WrCE               => bus2ip_wrce_int,       -- out -- little endian
      Bus2IP_Data               => bus2ip_data_int,       -- out -- little endian
      ----------------------------------------------------------
      IP2Bus_Data               => ip2bus_data_int,       -- in  -- little endian
      IP2Bus_WrAck              => ip2bus_wrack_int,      -- in
      IP2Bus_RdAck              => ip2bus_rdack_int,      -- in
      IP2Bus_Error              => ip2bus_error_int       -- in
      ----------------------------------------------------------
     );

     ----------------------
     --REG_RST_FRM_IPIF: convert active low to active hig reset to rest of
     --                     the core.
     ----------------------
     REG_RST_FRM_IPIF: process (S_AXI_ACLK) is
     begin
          if(S_AXI_ACLK'event and S_AXI_ACLK = '1') then
              bus2ip_reset_ipif_inverted <= not(bus2ip_reset_int);
          end if;
     end process REG_RST_FRM_IPIF;

     --    ----------------------------------------------------------------------
     --    -- Instansiating the SPI core
     --    ----------------------------------------------------------------------

     QSPI_CORE_INTERFACE_I : entity axi_quad_spi_v3_2_9.qspi_core_interface
     generic map
     (
      ------------------------------------------------
      -- AXI parameters
      C_LSB_STUP               => C_LSB_STUP,
      C_FAMILY                  => C_FAMILY          ,
      Async_Clk                 => Async_Clk          ,
      C_SUB_FAMILY              => C_FAMILY      ,
      C_UC_FAMILY              => C_UC_FAMILY      ,
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH,
      ------------------------------------------------
      -- local constants
      C_NUM_CE_SIGNALS          => C_NUM_CE_SIGNALS  ,
      ------------------------------------------------
      -- SPI parameters
      --C_AXI4_CLK_PS             => C_AXI4_CLK_PS     ,
      --C_EXT_SPI_CLK_PS          => C_EXT_SPI_CLK_PS      ,
      C_FIFO_DEPTH              => C_FIFO_DEPTH_UPDATED      ,
      C_SCK_RATIO               => C_SCK_RATIO       ,
      C_NUM_SS_BITS             => C_NUM_SS_BITS     ,
      C_NUM_TRANSFER_BITS       => C_NUM_TRANSFER_BITS,
      C_SPI_MODE                => C_SPI_MODE        ,
      C_USE_STARTUP             => C_USE_STARTUP     ,
      C_SPI_MEMORY              => C_SPI_MEMORY      ,
      C_SELECT_XPM              => C_SELECT_XPM      ,
      C_TYPE_OF_AXI4_INTERFACE  => C_TYPE_OF_AXI4_INTERFACE,
      ------------------------------------------------
      -- local constants
      C_FIFO_EXIST              => C_FIFO_EXIST      ,
      C_SPI_NUM_BITS_REG        => C_SPI_NUM_BITS_REG,
      C_OCCUPANCY_NUM_BITS      => C_OCCUPANCY_NUM_BITS,
      C_SHARED_STARTUP          => C_SHARED_STARTUP,
      ------------------------------------------------
      -- local constants
      C_IP_INTR_MODE_ARRAY      => IP_INTR_MODE_ARRAY,
      ------------------------------------------------
      -- local constants
      C_SPICR_REG_WIDTH         => C_SPICR_REG_WIDTH ,
      C_SPISR_REG_WIDTH         => C_SPISR_REG_WIDTH ,
      C_DUAL_MODE               => C_DUAL_MODE       ,
      C_STARTUP_EXT             => C_STARTUP_EXT
     )
     port map
     (
      EXT_SPI_CLK               =>  ext_spi_clk,               -- in
      ---------------------------------------------------
      -- IP Interconnect (IPIC) port signals
      Bus2IP_Clk                => bus2ip_clk,                 -- in
      Bus2IP_Reset              => bus2ip_reset_ipif_inverted, -- in
      ---------------------------------------------------
      Bus2IP_BE                 => bus2ip_be_int,              -- in vector
   -- Bus2IP_CS                 => bus2ip_cs_int,
      Bus2IP_RdCE               => bus2ip_rdce_int,            -- in vector
      Bus2IP_WrCE               => bus2ip_wrce_int,            -- in vector
      Bus2IP_Data               => bus2ip_data_int,            -- in vector
      ---------------------------------------------------
      IP2Bus_Data               => ip2bus_data_int,            -- out vector
      IP2Bus_WrAck              => ip2bus_wrack_int,           -- out
      IP2Bus_RdAck              => ip2bus_rdack_int,           -- out
      IP2Bus_Error              => ip2bus_error_int,           -- out
      ---------------------------------------------------
      burst_tr                  => burst_tr_int,
      rready                    => '0',
      WVALID                    => '0',
      ---------------------------------------------------
      --SPI Ports
      IO0_I                     => io0_i_sync,-- mosi
      IO0_O                     => io0_o,
      IO0_T                     => io0_t,
      -----
      IO1_I                     => io1_i_sync,-- miso
      IO1_O                     => io1_o,
      IO1_T                     => io1_t,
      -----
      IO2_I                     => io2_i_sync,
      IO2_O                     => io2_o,
      IO2_T                     => io2_t,
      -----
      IO3_I                     => io3_i_sync,
      IO3_O                     => io3_o,
      IO3_T                     => io3_t,
      -----
      SCK_I                     => sck_i,
      SCK_O                     => sck_o,
      SCK_T                     => sck_t,
      -----
      SPISEL                    => spisel,
      -----
      SS_I                      => ss_i,
      SS_O                      => ss_o,
      SS_T                      => ss_t,
      -----
      IP2INTC_Irpt              => ip2intc_irpt,
      CFGCLK                    => cfgclk,       -- FGCLK        , -- 1-bit output: Configuration main clock output
      CFGMCLK                   => cfgmclk, -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
      EOS                       => eos,  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
      PREQ                      => preq, -- REQ          , -- 1-bit output: PROGRAM request to fabric output
      DI                        => startup_di,    -- output
      DO                        => startup_do,    -- 4-bit input
      DTS                       => startup_dts,   -- 4-bit input
      GSR                       => gsr,   -- 1-bit input, SetReset
      CLK                       => clk,   -- 1-bit input, SetReset
      GTS                       => gts,   -- 1-bit input
      KEYCLEARB                 => keyclearb, --1-bit input
      USRCCLKTS                 => usrcclkts, -- SRCCLKTS     , -- 1-bit input
      USRDONEO                  => usrdoneo, -- SRDONEO      , -- 1-bit input
      USRDONETS                 => usrdonets, -- SRDONETS       -- 1-bit input
      PACK                      => pack
      -----
     );

     burst_tr_int <= '0';
end generate QSPI_LEGACY_MD_GEN;
------------------------------------------------------------------------------

QSPI_ENHANCED_MD_GEN: if  C_TYPE_OF_AXI4_INTERFACE = 1 and C_XIP_MODE = 0 generate
---------------
begin
-----
     -- AXI_QUAD_SPI_I: core instance
     QSPI_ENHANCED_MD_IPIF_I : entity axi_quad_spi_v3_2_9.axi_qspi_enhanced_mode
     generic map(
      -- General Parameters
      C_FAMILY                 => C_FAMILY                , -- : string               := "virtex7";
      C_SUB_FAMILY             => C_FAMILY            , -- : string               := "virtex7";
      -------------------------
      --C_TYPE_OF_AXI4_INTERFACE => C_TYPE_OF_AXI4_INTERFACE, -- : integer range 0 to 1 := 0;--default AXI4 Lite Legacy mode
      --C_XIP_MODE                => C_XIP_MODE           , -- : integer range 0 to 1 := 0;--default NON XIP Mode
      --C_AXI4_CLK_PS            => C_AXI4_CLK_PS           , -- : integer              := 10000;--AXI clock period
      --C_EXT_SPI_CLK_PS         => C_EXT_SPI_CLK_PS        , -- : integer              := 10000;--ext clock period
      C_FIFO_DEPTH             => C_FIFO_DEPTH_UPDATED            , -- : integer              := 16;-- allowed 0,16,256.
      C_SCK_RATIO              => C_SCK_RATIO             , -- : integer              := 16;--default in legacy mode
      C_NUM_SS_BITS            => C_NUM_SS_BITS           , -- : integer range 1 to 32:= 1;
      C_NUM_TRANSFER_BITS      => C_NUM_TRANSFER_BITS     , -- : integer              := 8; -- allowed 8, 16, 32
      -------------------------
      C_SPI_MODE               => C_SPI_MODE              , -- : integer range 0 to 2 := 0; -- used for differentiating
      C_USE_STARTUP            => C_USE_STARTUP           , -- : integer range 0 to 1 := 1; --
      C_SPI_MEMORY             => C_SPI_MEMORY            , -- : integer range 0 to 2 := 1; -- 0 - mixed mode,
      -------------------------
      -- AXI4 Full Interface Parameters
      C_S_AXI4_ADDR_WIDTH      => C_S_AXI4_ADDR_WIDTH     , -- : integer range 32 to 32 := 32;
      C_S_AXI4_DATA_WIDTH      => C_S_AXI4_DATA_WIDTH     , -- : integer range 32 to 32 := 32;
      C_S_AXI4_ID_WIDTH        => C_S_AXI4_ID_WIDTH       , -- : integer range 1 to 16  := 4;
      -------------------------
      --*C_AXI4_BASEADDR          => C_S_AXI4_BASEADDR         , -- : std_logic_vector       := x"FFFFFFFF";
      --*C_AXI4_HIGHADDR          => C_S_AXI4_HIGHADDR         , -- : std_logic_vector       := x"00000000"
      -------------------------
      C_S_AXI_SPI_MIN_SIZE     => C_S_AXI_SPI_MIN_SIZE    ,
      -------------------------
      C_ARD_ADDR_RANGE_ARRAY    => C_ARD_ADDR_RANGE_ARRAY_AXI4_FULL ,
      C_ARD_NUM_CE_ARRAY        => C_ARD_NUM_CE_ARRAY     ,
      C_SPI_MEM_ADDR_BITS           => C_SPI_MEM_ADDR_BITS        -- newly added 
    )
    port map(
     -- external async clock for SPI interface logic
     EXT_SPI_CLK     => ext_spi_clk    , -- : in std_logic;
     -----------------------------------
     S_AXI4_ACLK     => s_axi4_aclk    , -- : in std_logic;
     S_AXI4_ARESETN  => s_axi4_aresetn , -- : in std_logic;
     -------------------------------
     -------------------------------
     --*AXI4 Full port interface* --
     -------------------------------
     ------------------------------------
     -- AXI Write Address channel signals
     ------------------------------------
     S_AXI4_AWID    => s_axi4_awid   , -- : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_AWADDR  => s_axi4_awaddr , -- : in  std_logic_vector((C_S_AXI4_ADDR_WIDTH-1) downto 0);
     S_AXI4_AWLEN   => s_axi4_awlen  , -- : in  std_logic_vector(7 downto 0);
     S_AXI4_AWSIZE  => s_axi4_awsize , -- : in  std_logic_vector(2 downto 0);
     S_AXI4_AWBURST => s_axi4_awburst, -- : in  std_logic_vector(1 downto 0);
     S_AXI4_AWLOCK  => s_axi4_awlock , -- : in  std_logic;                   -- not supported in design
     S_AXI4_AWCACHE => s_axi4_awcache, -- : in  std_logic_vector(3 downto 0);-- not supported in design
     S_AXI4_AWPROT  => s_axi4_awprot , -- : in  std_logic_vector(2 downto 0);-- not supported in design
     S_AXI4_AWVALID => s_axi4_awvalid, -- : in  std_logic;
     S_AXI4_AWREADY => s_axi4_awready, -- : out std_logic;
     ---------------------------------------
     -- AXI4 Full Write data channel signals
     ---------------------------------------
     S_AXI4_WDATA   => s_axi4_wdata , -- : in  std_logic_vector((C_S_AXI4_DATA_WIDTH-1)downto 0);
     S_AXI4_WSTRB   => s_axi4_wstrb , -- : in  std_logic_vector(((C_S_AXI4_DATA_WIDTH/8)-1) downto 0);
     S_AXI4_WLAST   => s_axi4_wlast , -- : in  std_logic;
     S_AXI4_WVALID  => s_axi4_wvalid, -- : in  std_logic;
     S_AXI4_WREADY  => s_axi4_wready, -- : out std_logic;
     -------------------------------------------
     -- AXI4 Full Write response channel Signals
     -------------------------------------------
     S_AXI4_BID     => s_axi4_bid   , -- : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_BRESP   => s_axi4_bresp , -- : out std_logic_vector(1 downto 0);
     S_AXI4_BVALID  => s_axi4_bvalid, -- : out std_logic;
     S_AXI4_BREADY  => s_axi4_bready, -- : in  std_logic;
     -----------------------------------
     -- AXI Read Address channel signals
     -----------------------------------
     S_AXI4_ARID    => s_axi4_arid   , -- : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_ARADDR  => s_axi4_araddr , -- : in  std_logic_vector((C_S_AXI4_ADDR_WIDTH-1) downto 0);
     S_AXI4_ARLEN   => s_axi4_arlen  , -- : in  std_logic_vector(7 downto 0);
     S_AXI4_ARSIZE  => s_axi4_arsize , -- : in  std_logic_vector(2 downto 0);
     S_AXI4_ARBURST => s_axi4_arburst, -- : in  std_logic_vector(1 downto 0);
     S_AXI4_ARLOCK  => s_axi4_arlock , -- : in  std_logic;                    -- not supported in design
     S_AXI4_ARCACHE => s_axi4_arcache, -- : in  std_logic_vector(3 downto 0);-- not supported in design
     S_AXI4_ARPROT  => s_axi4_arprot , -- : in  std_logic_vector(2 downto 0);-- not supported in design
     S_AXI4_ARVALID => s_axi4_arvalid, -- : in  std_logic;
     S_AXI4_ARREADY => s_axi4_arready, -- : out std_logic;
     --------------------------------
     -- AXI Read Data Channel signals
     --------------------------------
     S_AXI4_RID     => s_axi4_rid   , -- : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_RDATA   => s_axi4_rdata , -- : out std_logic_vector((C_S_AXI4_DATA_WIDTH-1) downto 0);
     S_AXI4_RRESP   => s_axi4_rresp , -- : out std_logic_vector(1 downto 0);
     S_AXI4_RLAST   => s_axi4_rlast , -- : out std_logic;
     S_AXI4_RVALID  => s_axi4_rvalid, -- : out std_logic;
     S_AXI4_RREADY  => s_axi4_rready, -- : in  std_logic;
     ----------------------------------------------------------
     -- IP Interconnect (IPIC) port signals
     Bus2IP_Clk                => bus2ip_clk,                     -- out
     Bus2IP_Reset              => bus2ip_reset_ipif_inverted    , -- out
     ----------------------------------------------------------
     -- Bus2IP_Addr               => open,                  -- out -- not used signal
     Bus2IP_RNW                => open,                  -- out
     Bus2IP_BE                 => bus2ip_be_int,         -- out
     Bus2IP_CS                 => open,                  -- out -- not used signal
     Bus2IP_RdCE               => bus2ip_rdce_int,       -- out -- little endian
     Bus2IP_WrCE               => bus2ip_wrce_int,       -- out -- little endian
     Bus2IP_Data               => bus2ip_data_int,       -- out -- little endian
     ----------------------------------------------------------
     IP2Bus_Data               => ip2bus_data_int,       -- in  -- little endian
     IP2Bus_WrAck              => ip2bus_wrack_int,      -- in
     IP2Bus_RdAck              => ip2bus_rdack_int,      -- in
     IP2Bus_Error              => ip2bus_error_int,      -- in
     ----------------------------------------------------------
     burst_tr                  => burst_tr_int,          -- in
     rready                    => rready_int
    );
    --    ----------------------------------------------------------------------
    --    -- Instansiating the SPI core
    --    ----------------------------------------------------------------------

     QSPI_CORE_INTERFACE_I : entity axi_quad_spi_v3_2_9.qspi_core_interface
     generic map
     (
      ------------------------------------------------
      -- AXI parameters
      C_LSB_STUP               => C_LSB_STUP,
      C_FAMILY                  => C_FAMILY          ,
      Async_Clk                 => Async_Clk          ,
      C_SELECT_XPM              => C_SELECT_XPM          ,
      C_SUB_FAMILY              => C_FAMILY      ,
      C_UC_FAMILY              => C_UC_FAMILY      ,
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH,
      ------------------------------------------------
      -- local constants
      C_NUM_CE_SIGNALS          => C_NUM_CE_SIGNALS  ,
      ------------------------------------------------
      -- SPI parameters
      --C_AXI4_CLK_PS             => C_AXI4_CLK_PS     ,
      --C_EXT_SPI_CLK_PS          => C_EXT_SPI_CLK_PS  ,
      C_FIFO_DEPTH              => C_FIFO_DEPTH_UPDATED      ,
      C_SCK_RATIO               => C_SCK_RATIO       ,
      C_NUM_SS_BITS             => C_NUM_SS_BITS     ,
      C_NUM_TRANSFER_BITS       => C_NUM_TRANSFER_BITS,
      C_SPI_MODE                => C_SPI_MODE        ,
      C_USE_STARTUP             => C_USE_STARTUP     ,
      C_SPI_MEMORY              => C_SPI_MEMORY      ,
      C_TYPE_OF_AXI4_INTERFACE  => C_TYPE_OF_AXI4_INTERFACE,
      ------------------------------------------------
      -- local constants
      C_FIFO_EXIST              => C_FIFO_EXIST      ,
      C_SPI_NUM_BITS_REG        => C_SPI_NUM_BITS_REG,
      C_OCCUPANCY_NUM_BITS      => C_OCCUPANCY_NUM_BITS,
      C_SHARED_STARTUP          => C_SHARED_STARTUP,
      ------------------------------------------------
      -- local constants
      C_IP_INTR_MODE_ARRAY      => IP_INTR_MODE_ARRAY,
      ------------------------------------------------
      -- local constants
      C_SPICR_REG_WIDTH         => C_SPICR_REG_WIDTH ,
      C_SPISR_REG_WIDTH         => C_SPISR_REG_WIDTH,
      C_DUAL_MODE               => C_DUAL_MODE      ,
      C_STARTUP_EXT             => C_STARTUP_EXT
     )
     port map
     (
      EXT_SPI_CLK               =>  EXT_SPI_CLK,               -- in
      ---------------------------------------------------
      -- IP Interconnect (IPIC) port signals
      Bus2IP_Clk                => bus2ip_clk,                 -- in
      Bus2IP_Reset              => bus2ip_reset_ipif_inverted,               -- in
      ---------------------------------------------------
      Bus2IP_BE                 => bus2ip_be_int,              -- in vector
   -- Bus2IP_CS                 => bus2ip_cs_int,
      Bus2IP_RdCE               => bus2ip_rdce_int,            -- in vector
      Bus2IP_WrCE               => bus2ip_wrce_int,            -- in vector
      Bus2IP_Data               => bus2ip_data_int,            -- in vector
      ---------------------------------------------------
      IP2Bus_Data               => ip2bus_data_int,            -- out vector
      IP2Bus_WrAck              => ip2bus_wrack_int,           -- out
      IP2Bus_RdAck              => ip2bus_rdack_int,           -- out
      IP2Bus_Error              => ip2bus_error_int,           -- out
      ---------------------------------------------------
      burst_tr                  => burst_tr_int,
      rready                    => rready_int,
      WVALID                    => S_AXI4_WVALID,
      --SPI Ports
      IO0_I                     => io0_i_sync,-- mosi
      IO0_O                     => io0_o,
      IO0_T                     => io0_t,
      -----
      IO1_I                     => io1_i_sync,-- miso
      IO1_O                     => io1_o,
      IO1_T                     => io1_t,
      -----
      IO2_I                     => io2_i_sync,
      IO2_O                     => io2_o,
      IO2_T                     => io2_t,
      -----
      IO3_I                     => io3_i_sync,
      IO3_O                     => io3_o,
      IO3_T                     => io3_t,
      -----
      SCK_I                     => sck_i,
      SCK_O                     => sck_o,
      SCK_T                     => sck_t,
      -----
      SPISEL                    => spisel,
      -----
      SS_I                      => ss_i,
      SS_O                      => ss_o,
      SS_T                      => ss_t,
      -----
      IP2INTC_Irpt              => ip2intc_irpt,
	   CFGCLK                    => cfgclk,       -- FGCLK        , -- 1-bit output: Configuration main clock output
      CFGMCLK                   => cfgmclk, -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
      EOS                       => eos,  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
      PREQ                      => preq, -- REQ          , -- 1-bit output: PROGRAM request to fabric output
      DI                        => startup_di,    -- output
      DO                        => startup_do,    -- 4-bit input
      DTS                       => startup_dts,   -- 4-bit input
      CLK                       => clk,   -- 1-bit input, SetReset
      GSR                       => gsr,   -- 1-bit input, SetReset
      GTS                       => gts,   -- 1-bit input
      KEYCLEARB                 => keyclearb, --1-bit input
      USRCCLKTS                 => usrcclkts, -- SRCCLKTS     , -- 1-bit input
      USRDONEO                  => usrdoneo, -- SRDONEO      , -- 1-bit input
      USRDONETS                 => usrdonets, -- SRDONETS       -- 1-bit input
      PACK                      => pack


      -----
     );

end generate QSPI_ENHANCED_MD_GEN;
--------------------------------------------------------------------------------
-----------------
-- XIP_MODE: This logic is used in XIP mode where AXI4 Lite & AXI4 Full interface
--           used in the design
---------------
XIP_MODE_GEN : if C_TYPE_OF_AXI4_INTERFACE = 1 and C_XIP_MODE = 1 generate
---------------
constant XIPCR    : natural := 0;    -- at address C_BASEADDR + 60 h
constant XIPSR    : natural := 1;
--
signal bus2ip_reset_int : std_logic;
signal bus2ip_clk_int   : std_logic;

signal bus2ip_data_int          : std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
signal ip2bus_data_int          : std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
signal ip2bus_wrack_int         : std_logic;
signal ip2bus_rdack_int         : std_logic;
signal ip2bus_error_int         : std_logic;
signal bus2ip_reset_ipif_inverted: std_logic;
signal IP2Bus_XIPCR_WrAck : std_logic;
signal IP2Bus_XIPCR_RdAck : std_logic;
signal XIPCR_1_CPOL_int         : std_logic;
signal XIPCR_0_CPHA_int         : std_logic;
signal IP2Bus_XIPCR_Data_int : std_logic_vector((C_XIP_SPICR_REG_WIDTH-1) downto 0);
signal IP2Bus_XIPSR_Data_int : std_logic_vector((C_XIP_SPISR_REG_WIDTH-1) downto 0);
signal TO_XIPSR_AXI_TR_ERR_int   : std_logic;
signal TO_XIPSR_mst_modf_err_int : std_logic;
signal TO_XIPSR_axi_rx_full_int  : std_logic;
signal TO_XIPSR_axi_rx_empty_int : std_logic;

signal xipsr_cpha_cpol_err_int        :std_logic;
signal xipsr_cmd_err_int              :std_logic;
signal ip2bus_xipsr_wrack             :std_logic;
signal ip2bus_xipsr_rdack             :std_logic;


signal xipsr_axi_tr_err_int           :std_logic;
signal xipsr_axi_tr_done_int          :std_logic;
signal ip2bus_xipsr_rdack_int         :std_logic;
signal ip2bus_xipsr_wrack_int         :std_logic;
signal MISO_I_int                   :std_logic;
signal SCK_O_int                    :std_logic;
signal TO_XIPSR_trans_error_int     :std_logic;
signal TO_XIPSR_CPHA_CPOL_ERR_int   :std_logic;
signal ip2bus_wrack_core_reg_d1     :std_logic;
signal ip2bus_wrack_core_reg        :std_logic;
signal ip2bus_rdack_core_reg_d1     :std_logic;
signal ip2bus_rdack_core_reg_d2     :std_logic;
signal ip2Bus_RdAck_core_reg_d3     :std_logic;
signal Rst_to_spi_int               :std_logic;

begin
-----
    ---- AXI4 Lite interface instance and interface with the port list
    AXI_LITE_IPIF_I : entity axi_lite_ipif_v3_0_4.axi_lite_ipif
    generic map
     (
      ----------------------------------------------------
      C_S_AXI_ADDR_WIDTH        => C_S_AXI_ADDR_WIDTH    ,
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH    ,
      ----------------------------------------------------
      C_S_AXI_MIN_SIZE          => C_S_AXI_SPI_MIN_SIZE  ,
      C_USE_WSTRB               => C_USE_WSTRB           ,
      C_DPHASE_TIMEOUT          => C_DPHASE_TIMEOUT      ,
      ----------------------------------------------------
      C_ARD_ADDR_RANGE_ARRAY    => C_XIP_LITE_ARD_ADDR_RANGE_ARRAY,
      C_ARD_NUM_CE_ARRAY        => C_XIP_LITE_ARD_NUM_CE_ARRAY    ,
      C_FAMILY                  => C_FAMILY
      ----------------------------------------------------
     )
    port map
     (        -- AXI4 Lite interface
      ---------------------------------------------------------
      S_AXI_ACLK                =>  s_axi_aclk,           -- in
      S_AXI_ARESETN             =>  s_axi_aresetn,        -- in
      ---------------------------------------------------------
      S_AXI_AWADDR              =>  s_axi_awaddr,         -- in
      S_AXI_AWVALID             =>  s_axi_awvalid,        -- in
      S_AXI_AWREADY             =>  s_axi_awready,        -- out
      S_AXI_WDATA               =>  s_axi_wdata,          -- in
      S_AXI_WSTRB               =>  s_axi_wstrb,          -- in
      S_AXI_WVALID              =>  s_axi_wvalid,         -- in
      S_AXI_WREADY              =>  s_axi_wready,         -- out
      S_AXI_BRESP               =>  s_axi_bresp,          -- out
      S_AXI_BVALID              =>  s_axi_bvalid,         -- out
      S_AXI_BREADY              =>  s_axi_bready,         -- in
      S_AXI_ARADDR              =>  s_axi_araddr,         -- in
      S_AXI_ARVALID             =>  s_axi_arvalid,        -- in
      S_AXI_ARREADY             =>  s_axi_arready,        -- out
      S_AXI_RDATA               =>  s_axi_rdata,          -- out
      S_AXI_RRESP               =>  s_axi_rresp,          -- out
      S_AXI_RVALID              =>  s_axi_rvalid,         -- out
      S_AXI_RREADY              =>  s_axi_rready,         -- in
      ----------------------------------------------------------
      -- IP Interconnect (IPIC) port signals
      Bus2IP_Clk                => bus2ip_clk_int  ,            -- out
      Bus2IP_Resetn             => bus2ip_reset_int,      -- out
      ----------------------------------------------------------
      Bus2IP_Addr               => open,                  -- out -- not used signal
      Bus2IP_RNW                => open,                  -- out
      Bus2IP_BE                 => open,                  -- bus2ip_be_int,         -- out
      Bus2IP_CS                 => open,                  -- out -- not used signal
      Bus2IP_RdCE               => bus2ip_xip_rdce_int,   -- out -- little endian
      Bus2IP_WrCE               => bus2ip_xip_wrce_int,   -- out -- little endian
      Bus2IP_Data               => bus2ip_data_int,       -- out -- little endian
      ----------------------------------------------------------
      IP2Bus_Data               => ip2bus_data_int,       -- in  -- little endian
      IP2Bus_WrAck              => ip2bus_wrack_int,      -- in
      IP2Bus_RdAck              => ip2bus_rdack_int,      -- in
      IP2Bus_Error              => ip2bus_error_int       -- in
      ----------------------------------------------------------
     );
     --------------------------------------------------------------------------
     ip2bus_error_int <= '0'; -- there is no error in this mode
     ----------------------
     --REG_RST_FRM_IPIF: convert active low to active hig reset to rest of
     --                     the core.
     ----------------------
     REG_RST_FRM_IPIF: process (S_AXI_ACLK) is
     begin
          if(S_AXI_ACLK'event and S_AXI_ACLK = '1') then
              bus2ip_reset_ipif_inverted <= not(S_AXI_ARESETN);
          end if;
     end process REG_RST_FRM_IPIF;
     --------------------------------------------------------------------------
     XIP_CR_I : entity axi_quad_spi_v3_2_9.xip_cntrl_reg
     generic map
      (
       C_XIP_SPICR_REG_WIDTH => C_XIP_SPICR_REG_WIDTH,
       C_S_AXI_DATA_WIDTH    => C_S_AXI_DATA_WIDTH   ,
       C_SPI_MODE            => C_SPI_MODE
      )
     port map(
       Bus2IP_Clk            => S_AXI_ACLK,                 --  : in  std_logic;
       Soft_Reset_op         => bus2ip_reset_ipif_inverted, --  : in  std_logic;
       ------------------------
       Bus2IP_XIPCR_WrCE     => bus2ip_xip_wrce_int(XIPCR), --  : in  std_logic;
       Bus2IP_XIPCR_RdCE     => bus2ip_xip_rdce_int(XIPCR), --  : in  std_logic;
       Bus2IP_XIPCR_data     => bus2ip_data_int           , --  : in  std_logic_vector(0 to (C_S_AXI_DATA_WIDTH-1));
       ------------------------
       ip2Bus_RdAck_core     => ip2Bus_RdAck_core_reg_d2, -- IP2Bus_XIPCR_WrAck,
       ip2Bus_WrAck_core     => ip2Bus_WrAck_core_reg, -- IP2Bus_XIPCR_RdAck,
       ------------------------
       --XIPCR_7_0_CMD         => XIPCR_7_0_CMD,               -- out std_logic_vector;
       XIPCR_1_CPOL          => XIPCR_1_CPOL_int ,         -- out std_logic;
       XIPCR_0_CPHA          => XIPCR_0_CPHA_int ,         -- out std_logic;
       ------------------------
       IP2Bus_XIPCR_Data     => IP2Bus_XIPCR_Data_int,      -- out std_logic;
       ------------------------
       TO_XIPSR_CPHA_CPOL_ERR=> TO_XIPSR_CPHA_CPOL_ERR_int  -- out std_logic
     );
     --------------------------------------------------------------------------
     REG_WR_ACK_P:process(S_AXI_ACLK)is
     begin
     -----
          if(S_AXI_ACLK'event and S_AXI_ACLK = '1') then
           if(bus2ip_reset_ipif_inverted = '1')then
               ip2Bus_WrAck_core_reg_d1 <= '0';
               ip2Bus_WrAck_core_reg    <= '0';
           else
               ip2Bus_WrAck_core_reg_d1  <= bus2ip_xip_wrce_int(XIPCR) or
                                            bus2ip_xip_wrce_int(XIPSR);
               ip2Bus_WrAck_core_reg     <= (bus2ip_xip_wrce_int(XIPCR) or
                                            bus2ip_xip_wrce_int(XIPSR)) and
                                            (not ip2Bus_WrAck_core_reg_d1);
           end if;
        end if;
     end process REG_WR_ACK_P;
     -------------------------
     ip2bus_wrack_int <= ip2Bus_WrAck_core_reg;
     -------------------------

     REG_RD_ACK_P:process(S_AXI_ACLK)is
     begin
     -----
          if(S_AXI_ACLK'event and S_AXI_ACLK = '1') then
           if(bus2ip_reset_ipif_inverted = '1')then
               ip2Bus_RdAck_core_reg_d1 <= '0';
               ip2Bus_RdAck_core_reg_d2 <= '0';
               ip2Bus_RdAck_core_reg_d3 <= '0';
           else
               ip2Bus_RdAck_core_reg_d1 <= bus2ip_xip_rdce_int(XIPCR) or
                                           bus2ip_xip_rdce_int(XIPSR);
               ip2Bus_RdAck_core_reg_d2 <= (bus2ip_xip_rdce_int(XIPCR) or
                                           bus2ip_xip_rdce_int(XIPSR)) and
                                           (not ip2Bus_RdAck_core_reg_d1);
               ip2Bus_RdAck_core_reg_d3 <= ip2Bus_RdAck_core_reg_d2;
           end if;
        end if;
     end process REG_RD_ACK_P;
     -------------------------
     ip2bus_rdack_int <= ip2Bus_RdAck_core_reg_d3;
     -------------------------
     REG_IP2BUS_DATA_P:process(S_AXI_ACLK)is
     begin
     -----
          if(S_AXI_ACLK'event and S_AXI_ACLK = '1') then
           if(bus2ip_reset_ipif_inverted = '1')then
               ip2bus_data_int <= (others => '0');
           elsif(ip2Bus_RdAck_core_reg_d2 = '1') then
               ip2bus_data_int  <= ("000000000000000000000000000000" & IP2Bus_XIPCR_Data_int) or
                                   ("000000000000000000000000000"    & IP2Bus_XIPSR_Data_int);
           end if;
        end if;
     end process REG_IP2BUS_DATA_P;
     -------------------------
     --------------------------------------------------------------------------
     XIP_SR_I : entity axi_quad_spi_v3_2_9.xip_status_reg
     generic map
     (
      C_XIP_SPISR_REG_WIDTH => C_XIP_SPISR_REG_WIDTH,
      C_S_AXI_DATA_WIDTH    => C_S_AXI_DATA_WIDTH
     )
    port map(
      Bus2IP_Clk            => S_AXI_ACLK,                 --    : in  std_logic;
      Soft_Reset_op         => bus2ip_reset_ipif_inverted, --    : in  std_logic;
      ------------------------
      XIPSR_AXI_TR_ERR      => TO_XIPSR_AXI_TR_ERR_int,       --    : in  std_logic;
      XIPSR_CPHA_CPOL_ERR   => TO_XIPSR_CPHA_CPOL_ERR_int,    --    : in  std_logic;
      XIPSR_MST_MODF_ERR    => TO_XIPSR_mst_modf_err_int,  --    : in  std_logic;
      XIPSR_AXI_RX_FULL     => TO_XIPSR_axi_rx_full_int,   --    : in  std_logic;
      XIPSR_AXI_RX_EMPTY    => TO_XIPSR_axi_rx_empty_int,  --    : in  std_logic;
      ------------------------
      Bus2IP_XIPSR_WrCE     => bus2ip_xip_wrce_int(XIPSR),
      Bus2IP_XIPSR_RdCE     => bus2ip_xip_rdce_int(XIPSR),
      -------------------
      IP2Bus_XIPSR_Data     => IP2Bus_XIPSR_Data_int     ,
      ip2Bus_RdAck          => ip2Bus_RdAck_core_reg_d3
    );
    ---------------------------------------------------------------------------
    --REG_RST4_FRM_IPIF: convert active low to active hig reset to rest of
    --                     the core.
    ----------------------
    REG_RST4_FRM_IPIF: process (S_AXI4_ACLK) is
    begin
         if(S_AXI4_ACLK'event and S_AXI4_ACLK = '1') then
             bus2ip_reset_ipif4_inverted <= not(S_AXI4_ARESETN);
         end if;
    end process REG_RST4_FRM_IPIF;
    -------------------------------------------------------------------------
    RESET_SYNC_AXI_SPI_CLK_INST:entity axi_quad_spi_v3_2_9.reset_sync_module
    port map(
              EXT_SPI_CLK        => EXT_SPI_CLK                 ,-- in std_logic;
              Soft_Reset_frm_axi => bus2ip_reset_ipif4_inverted ,-- in std_logic;
              Rst_to_spi         => Rst_to_spi_int               -- out std_logic;
    );
    --------------------------------------------------------------------------
    AXI_QSPI_XIP_I : entity axi_quad_spi_v3_2_9.axi_qspi_xip_if
    generic map
     (
      C_FAMILY                 => C_FAMILY                ,
      Async_Clk                => Async_Clk          ,
      C_SUB_FAMILY             => C_FAMILY            ,
      -------------------------
      --C_TYPE_OF_AXI4_INTERFACE => C_TYPE_OF_AXI4_INTERFACE,
      --C_XIP_MODE               => C_XIP_MODE              ,
      --C_AXI4_CLK_PS            => C_AXI4_CLK_PS           ,
      --C_EXT_SPI_CLK_PS         => C_EXT_SPI_CLK_PS            ,
      --C_FIFO_DEPTH             => C_FIFO_DEPTH_UPDATED            ,
      C_SPI_MEM_ADDR_BITS          => C_SPI_MEM_ADDR_BITS         ,
      C_SCK_RATIO              => C_SCK_RATIO             ,
      C_NUM_SS_BITS            => C_NUM_SS_BITS           ,
      C_NUM_TRANSFER_BITS      => C_NUM_TRANSFER_BITS     ,
      -------------------------
      C_SPI_MODE               => C_SPI_MODE              ,
      C_USE_STARTUP            => C_USE_STARTUP           ,
      C_SPI_MEMORY             => C_SPI_MEMORY            ,
      -------------------------
      -- AXI4 Full Interface Parameters
      C_S_AXI4_ADDR_WIDTH      => C_S_AXI4_ADDR_WIDTH     ,
      C_S_AXI4_DATA_WIDTH      => C_S_AXI4_DATA_WIDTH     ,
      C_S_AXI4_ID_WIDTH        => C_S_AXI4_ID_WIDTH       ,
      -------------------------
      --*C_AXI4_BASEADDR          => C_S_AXI4_BASEADDR         ,
      --*C_AXI4_HIGHADDR          => C_S_AXI4_HIGHADDR         ,
      -------------------------
      --C_XIP_SPICR_REG_WIDTH    => C_XIP_SPICR_REG_WIDTH   ,
      --C_XIP_SPISR_REG_WIDTH    => C_XIP_SPISR_REG_WIDTH         ,
      -------------------------
      C_XIP_FULL_ARD_ADDR_RANGE_ARRAY   => C_XIP_FULL_ARD_ADDR_RANGE_ARRAY,
      C_XIP_FULL_ARD_NUM_CE_ARRAY       => C_XIP_FULL_ARD_NUM_CE_ARRAY
     )
    port map
     (
     -- external async clock for SPI interface logic
     EXT_SPI_CLK    => ext_spi_clk   , -- : in std_logic;
     Rst_to_spi     => Rst_to_spi_int,
     ----------------------------------
     S_AXI_ACLK     => s_axi_aclk    , -- : in std_logic;
     S_AXI_ARESETN  => bus2ip_reset_ipif_inverted, -- : in std_logic;
     ----------------------------------
     S_AXI4_ACLK    => s_axi4_aclk    , -- : in std_logic;
     S_AXI4_ARESET  => bus2ip_reset_ipif4_inverted, -- : in std_logic;
     -------------------------------
     --*AXI4 Full port interface* --
     -------------------------------
     ------------------------------------
     -- AXI Write Address Channel Signals
     ------------------------------------
     S_AXI4_AWID    => s_axi4_awid   , -- : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_AWADDR  => s_axi4_awaddr , -- : in  std_logic_vector((C_S_AXI4_ADDR_WIDTH-1) downto 0);
     S_AXI4_AWLEN   => s_axi4_awlen  , -- : in  std_logic_vector(7 downto 0);
     S_AXI4_AWSIZE  => s_axi4_awsize , -- : in  std_logic_vector(2 downto 0);
     S_AXI4_AWBURST => s_axi4_awburst, -- : in  std_logic_vector(1 downto 0);
     S_AXI4_AWLOCK  => s_axi4_awlock , -- : in  std_logic;                   -- not supported in design
     S_AXI4_AWCACHE => s_axi4_awcache, -- : in  std_logic_vector(3 downto 0);-- not supported in design
     S_AXI4_AWPROT  => s_axi4_awprot , -- : in  std_logic_vector(2 downto 0);-- not supported in design
     S_AXI4_AWVALID => s_axi4_awvalid, -- : in  std_logic;
     S_AXI4_AWREADY => s_axi4_awready, -- : out std_logic;
     ---------------------------------------
     -- AXI4 Full Write data channel Signals
     ---------------------------------------
     S_AXI4_WDATA   => s_axi4_wdata  , -- : in  std_logic_vector((C_S_AXI4_DATA_WIDTH-1)downto 0);
     S_AXI4_WSTRB   => s_axi4_wstrb  , -- : in  std_logic_vector(((C_S_AXI4_DATA_WIDTH/8)-1) downto 0);
     S_AXI4_WLAST   => s_axi4_wlast  , -- : in  std_logic;
     S_AXI4_WVALID  => s_axi4_wvalid , -- : in  std_logic;
     S_AXI4_WREADY  => s_axi4_wready , -- : out std_logic;
     -------------------------------------------
     -- AXI4 Full Write response channel Signals
     -------------------------------------------
     S_AXI4_BID     => s_axi4_bid    , -- : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_BRESP   => s_axi4_bresp  , -- : out std_logic_vector(1 downto 0);
     S_AXI4_BVALID  => s_axi4_bvalid , -- : out std_logic;
     S_AXI4_BREADY  => s_axi4_bready , -- : in  std_logic;
     -----------------------------------
     -- AXI Read Address channel signals
     -----------------------------------
     S_AXI4_ARID    => s_axi4_arid   , -- : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_ARADDR  => s_axi4_araddr , -- : in  std_logic_vector((C_S_AXI4_ADDR_WIDTH-1) downto 0);
     S_AXI4_ARLEN   => s_axi4_arlen  , -- : in  std_logic_vector(7 downto 0);
     S_AXI4_ARSIZE  => s_axi4_arsize , -- : in  std_logic_vector(2 downto 0);
     S_AXI4_ARBURST => s_axi4_arburst, -- : in  std_logic_vector(1 downto 0);
     S_AXI4_ARLOCK  => s_axi4_arlock , -- : in  std_logic;                    -- not supported in design
     S_AXI4_ARCACHE => s_axi4_arcache, -- : in  std_logic_vector(3 downto 0);-- not supported in design
     S_AXI4_ARPROT  => s_axi4_arprot , -- : in  std_logic_vector(2 downto 0);-- not supported in design
     S_AXI4_ARVALID => s_axi4_arvalid, -- : in  std_logic;
     S_AXI4_ARREADY => s_axi4_arready, -- : out std_logic;
     --------------------------------
     -- AXI Read Data Channel signals
     --------------------------------
     S_AXI4_RID     => s_axi4_rid   , -- : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
     S_AXI4_RDATA   => s_axi4_rdata , -- : out std_logic_vector((C_S_AXI4_DATA_WIDTH-1) downto 0);
     S_AXI4_RRESP   => s_axi4_rresp , -- : out std_logic_vector(1 downto 0);
     S_AXI4_RLAST   => s_axi4_rlast , -- : out std_logic;
     S_AXI4_RVALID  => s_axi4_rvalid, -- : out std_logic;
     S_AXI4_RREADY  => s_axi4_rready, -- : in  std_logic;
     --------------------------------
     XIPSR_CPHA_CPOL_ERR   => TO_XIPSR_CPHA_CPOL_ERR_int  , -- in std_logic
     -------------------------------
     TO_XIPSR_trans_error  => TO_XIPSR_AXI_TR_ERR_int  , -- out std_logic
     TO_XIPSR_mst_modf_err => TO_XIPSR_mst_modf_err_int,
     TO_XIPSR_axi_rx_full  => TO_XIPSR_axi_rx_full_int ,
     TO_XIPSR_axi_rx_empty => TO_XIPSR_axi_rx_empty_int,
     -------------------------------
     XIPCR_1_CPOL          => XIPCR_1_CPOL_int ,         -- out std_logic;
     XIPCR_0_CPHA          => XIPCR_0_CPHA_int ,         -- out std_logic;
     --*SPI port interface      * --
     -------------------------------
     IO0_I          => io0_i_sync_int, -- : in std_logic;  -- MOSI signal in standard SPI
     IO0_O          => io0_o_int, -- : out std_logic;
     IO0_T          => io0_t_int, -- : out std_logic;
     -------------------------------
     IO1_I          => io1_i_sync_int, -- : in std_logic;  -- MISO signal in standard SPI
     IO1_O          => io1_o_int, -- : out std_logic;
     IO1_T          => io1_t_int, -- : out std_logic;
     -----------------
     -- quad mode pins
     -----------------
     IO2_I          => io2_i_sync_int, -- : in std_logic;
     IO2_O          => io2_o_int, -- : out std_logic;
     IO2_T          => io2_t_int, -- : out std_logic;
     ---------------
     IO3_I          => io3_i_sync_int, -- : in std_logic;
     IO3_O          => io3_o_int, -- : out std_logic;
     IO3_T          => io3_t_int, -- : out std_logic;
     ---------------------------------
     -- common pins
     ----------------
     SPISEL         => spisel, -- : in std_logic;
     -----
     SCK_I          => sck_i , -- : in std_logic;
     SCK_O_reg      => SCK_O_int , -- : out std_logic;
     SCK_T          => sck_t , -- : out std_logic;
     -----
     SS_I           => ss_i_int  , -- : in std_logic_vector((C_NUM_SS_BITS-1) downto 0);
     SS_O           => ss_o_int  , -- : out std_logic_vector((C_NUM_SS_BITS-1) downto 0);
     SS_T           => ss_t_int    -- : out std_logic;
     ----------------------
     );
     -- no interrupt from this mode of core
     IP2INTC_Irpt <= '0';

  -------------------------------------------------------
  -------------------------------------------------------
  SCK_MISO_NO_STARTUP_USED: if C_USE_STARTUP = 0 generate
  -----
  begin
  -----
       SCK_O      <= SCK_O_int;   -- output from the core
       MISO_I_int <= io1_i_sync;       -- input to the core

  end generate SCK_MISO_NO_STARTUP_USED;
  -------------------------------------------------------

  SCK_MISO_STARTUP_USED: if C_USE_STARTUP = 1 generate
  -----
  begin
  -----
  QSPI_STARTUP_BLOCK_I: entity axi_quad_spi_v3_2_9.qspi_startup_block
  ---------------------
  generic map
       (
               C_SUB_FAMILY     => C_FAMILY , -- support for V6/V7/K7/A7 families only
               -----------------
               C_USE_STARTUP    => C_USE_STARTUP,
               -----------------
               C_SHARED_STARTUP => C_SHARED_STARTUP,
               C_SPI_MODE       => C_SPI_MODE
               -----------------
       )
  port map
       (
               SCK_O          => SCK_O_int, -- : in std_logic; -- input from the qspi_mode_0_module
               IO1_I_startup  => io1_i_sync,     -- : in std_logic; -- input from the top level port list
               IO1_Int        => MISO_I_int,-- : out std_logic
	           Bus2IP_Clk     => Bus2IP_Clk,
	           reset2ip_reset => bus2ip_reset_ipif4_inverted,
			   CFGCLK         => cfgclk,       -- FGCLK        , -- 1-bit output: Configuration main clock output
               CFGMCLK        => cfgmclk, -- FGMCLK       , -- 1-bit output: Configuration internal oscillator clock output
               EOS            => eos,  -- OS           , -- 1-bit output: Active high output signal indicating the End Of Startup.
               PREQ           => preq, -- REQ          , -- 1-bit output: PROGRAM request to fabric output
               DI             => di_int,    -- output
               DO             => do_int,    -- 4-bit input
               DTS            => dts_int,   -- 4-bit input
               FCSBO          => fcsbo_int, -- 1-bit input
               FCSBTS         => fcsbts_int,-- 1-bit input
               CLK            => clk,   -- 1-bit input, SetReset
               GSR            => gsr,   -- 1-bit input, SetReset
               GTS            => gts,   -- 1-bit input
               KEYCLEARB      => keyclearb, --1-bit input
               USRCCLKTS      => usrcclkts, -- SRCCLKTS     , -- 1-bit input
               USRDONEO       => usrdoneo, -- SRDONEO      , -- 1-bit input
               USRDONETS      => usrdonets, -- SRDONETS       -- 1-bit input
               PACK           => pack


       );
  --------------------

  end generate SCK_MISO_STARTUP_USED;
end generate XIP_MODE_GEN;

------------------------------------------------------------------------------
end architecture imp;
------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- axi_quad_spi.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- *******************************************************************
-- ** (c) Copyright [2010] - [2012] Xilinx, Inc. All rights reserved.*
-- **                                                                *
-- ** This file contains confidential and proprietary information    *
-- ** of Xilinx, Inc. and is protected under U.S. and                *
-- ** international copyright and other intellectual property        *
-- ** laws.                                                          *
-- **                                                                *
-- ** DISCLAIMER                                                     *
-- ** This disclaimer is not a license and does not grant any        *
-- ** rights to the materials distributed herewith. Except as        *
-- ** otherwise provided in a valid license issued to you by         *
-- ** Xilinx, and to the maximum extent permitted by applicable      *
-- ** law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND        *
-- ** WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES    *
-- ** AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING      *
-- ** BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-         *
-- ** INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and       *
-- ** (2) Xilinx shall not be liable (whether in contract or tort,   *
-- ** including negligence, or under any other theory of             *
-- ** liability) for any loss or damage of any kind or nature        *
-- ** related to, arising under or in connection with these          *
-- ** materials, including for any direct, or any indirect,          *
-- ** special, incidental, or consequential loss or damage           *
-- ** (including loss of data, profits, goodwill, or any type of     *
-- ** loss or damage suffered as a result of any action brought      *
-- ** by a third party) even if such damage or loss was              *
-- ** reasonably foreseeable or Xilinx had been advised of the       *
-- ** possibility of the same.                                       *
-- **                                                                *
-- ** CRITICAL APPLICATIONS                                          *
-- ** Xilinx products are not designed or intended to be fail-       *
-- ** safe, or for use in any application requiring fail-safe        *
-- ** performance, such as life-support or safety devices or         *
-- ** systems, Class III medical devices, nuclear facilities,        *
-- ** applications related to the deployment of airbags, or any      *
-- ** other applications that could lead to death, personal          *
-- ** injury, or severe property or environmental damage             *
-- ** (individually and collectively, "Critical                      *
-- ** Applications"). Customer assumes the sole risk and             *
-- ** liability of any use of Xilinx products in Critical            *
-- ** Applications, subject only to applicable laws and              *
-- ** regulations governing limitations on product liability.        *
-- **                                                                *
-- ** THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS       *
-- ** PART OF THIS FILE AT ALL TIMES.                                *
-- *******************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_quad_spi.vhd
-- Version:         v3.0
-- Description:     This is the top-level design file for the AXI Quad SPI core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_arith.conv_std_logic_vector;
    use ieee.std_logic_arith.all;
    use ieee.std_logic_signed.all;
    use ieee.std_logic_misc.all;
-- library unsigned is used for overloading of "=" which allows integer to
-- be compared to std_logic_vector
--    use ieee.std_logic_unsigned.all;

library unisim;
    use unisim.vcomponents.FD;
    use unisim.vcomponents.FDRE;
    use UNISIM.vcomponents.all;

library axi_lite_ipif_v3_0_4;
use axi_lite_ipif_v3_0_4.axi_lite_ipif;
use axi_lite_ipif_v3_0_4.ipif_pkg.all;


library axi_quad_spi_v3_2_9;
    use axi_quad_spi_v3_2_9.all;
-------------------------------------------------------------------------------

entity axi_quad_spi is
   generic(
       -- Async_Clk  parameter is added only for Vivado, it is not used in the design, this is
       -- NON HDL parameter
       Async_Clk                : integer              := 0;
       -- General Parameters
       C_FAMILY                 : string               := "virtex7";
       C_SELECT_XPM             : integer              := 1;
       C_SUB_FAMILY             : string               := "virtex7";
       C_INSTANCE               : string               := "axi_quad_spi_inst";
       -------------------------
       C_SPI_MEM_ADDR_BITS      : integer              := 24; -- allowed values are 24 or 32 only and used in XIP mode
       C_TYPE_OF_AXI4_INTERFACE : integer range 0 to 1 := 0;--default AXI4 Lite Legacy mode
       C_XIP_MODE               : integer range 0 to 1 := 0;--default NON XIP Mode
       C_UC_FAMILY              : integer range 0 to 1 := 0;--default NON XIP Mode
       --C_AXI4_CLK_PS            : integer              := 10000;--AXI clock period
       --C_EXT_SPI_CLK_PS         : integer              := 10000;--ext clock period
       C_FIFO_DEPTH             : integer              := 256;-- allowed 0,16,256.
       C_SCK_RATIO              : integer              := 16;--default in legacy mode
       C_DUAL_QUAD_MODE         : integer range 0 to 1 := 0;
       C_NUM_SS_BITS            : integer range 1 to 32:= 1;
       C_NUM_TRANSFER_BITS      : integer              := 8; -- allowed 8, 16, 32
       -------------------------
       C_SPI_MODE               : integer range 0 to 2 := 0; -- used for differentiating
                                                             -- Standard, Dual or Quad mode
                                                             -- in Ports as well as internal
                                                             -- functionality
       C_USE_STARTUP            : integer range 0 to 1 := 1; --
       C_USE_STARTUP_EXT        : integer range 0 to 1 := 1; --
       C_SPI_MEMORY             : integer range 0 to 3 := 1; -- 0 - mixed mode,
                                                             -- 1 - winbond,
                                                             -- 2 - numonyx
															 -- 3 - spansion
                                                             -- used to differentiate
                                                             -- internal look up table
                                                             -- for commands.
       -------------------------
       -- AXI4 Lite Interface Parameters  *as max address is 7c, only 7 address bits are used
       C_S_AXI_ADDR_WIDTH       : integer range 7  to 7  := 7;
       C_S_AXI_DATA_WIDTH       : integer range 32 to 32 := 32;
       -------------------------
       --*C_BASEADDR               : std_logic_vector       := x"FFFFFFFF";
       --*C_HIGHADDR               : std_logic_vector       := x"00000000";
       -------------------------
       -- AXI4 Full Interface Parameters *as max 24 bits of address are supported on SPI interface, only 24 address bits are used
       C_S_AXI4_ADDR_WIDTH      : integer                     ;--range 24 to 24 := 24;
       C_S_AXI4_DATA_WIDTH      : integer range 32 to 32 := 32;
       C_S_AXI4_ID_WIDTH        : integer range 1 to 16  := 4 ;
       C_SHARED_STARTUP    : integer range 0 to 1 := 0;
       -------------------------
       -- To FIX CR# 685366, below lines are added again in RTL (Vivado Requirement), but these parameters are not used in the core RTL
       C_S_AXI4_BASEADDR          : std_logic_vector       := x"FFFFFFFF";
       C_S_AXI4_HIGHADDR          : std_logic_vector       := x"00000000";
       -------------------------
       C_LSB_STUP            : integer range 0 to 1 := 0
  );
   port(
       -- external async clock for SPI interface logic
       ext_spi_clk    : in std_logic;
       -- axi4 lite interface clk and reset signals
       s_axi_aclk     : in std_logic;
       s_axi_aresetn  : in std_logic;
       -- axi4 full interface clk and reset signals
       s_axi4_aclk    : in std_logic;
       s_axi4_aresetn : in std_logic;
       -------------------------------
       -------------------------------
       --*axi4 lite port interface* --
       -------------------------------
       -------------------------------
       -- axi write address channel signals
       ---------------
       s_axi_awaddr   : in std_logic_vector (6 downto 0);--((C_S_AXI_ADDR_WIDTH-1) downto 0);
       s_axi_awvalid  : in std_logic;
       s_axi_awready  : out std_logic;
       ---------------
       -- axi write data channel signals
       ---------------
       s_axi_wdata    : in std_logic_vector(31 downto 0); -- ((C_S_AXI_DATA_WIDTH-1) downto 0);
       s_axi_wstrb    : in std_logic_vector(3 downto 0); -- (((C_S_AXI_DATA_WIDTH/8)-1) downto 0);
       s_axi_wvalid   : in std_logic;
       s_axi_wready   : out std_logic;
       ---------------
       -- axi write response channel signals
       ---------------
       s_axi_bresp    : out std_logic_vector(1 downto 0);
       s_axi_bvalid   : out std_logic;
       s_axi_bready   : in  std_logic;
       ---------------
       -- axi read address channel signals
       ---------------
       s_axi_araddr   : in  std_logic_vector(6 downto 0); -- ((C_S_AXI_ADDR_WIDTH-1) downto 0);
       s_axi_arvalid  : in  std_logic;
       s_axi_arready  : out std_logic;
       ---------------
       -- axi read address channel signals
       ---------------
       s_axi_rdata    : out std_logic_vector(31 downto 0); -- ((C_S_AXI_DATA_WIDTH-1) downto 0);
       s_axi_rresp    : out std_logic_vector(1 downto 0);
       s_axi_rvalid   : out std_logic;
       s_axi_rready   : in  std_logic;
       -------------------------------
       -------------------------------
       --*axi4 full port interface* --
       -------------------------------
       ------------------------------------
       -- axi write address Channel Signals
       ------------------------------------
       s_axi4_awid    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_awaddr  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1) downto 0); --((C_S_AXI4_ADDR_WIDTH-1) downto 0);
       s_axi4_awlen   : in  std_logic_vector(7 downto 0);
       s_axi4_awsize  : in  std_logic_vector(2 downto 0);
       s_axi4_awburst : in  std_logic_vector(1 downto 0);
       s_axi4_awlock  : in  std_logic;                   -- not supported in design
       s_axi4_awcache : in  std_logic_vector(3 downto 0);-- not supported in design
       s_axi4_awprot  : in  std_logic_vector(2 downto 0);-- not supported in design
       s_axi4_awvalid : in  std_logic;
       s_axi4_awready : out std_logic;
       ---------------------------------------
       -- axi4 full write Data Channel Signals
       ---------------------------------------
       s_axi4_wdata   : in  std_logic_vector(31 downto 0); -- ((C_S_AXI4_DATA_WIDTH-1)downto 0);
       s_axi4_wstrb   : in  std_logic_vector(3 downto 0); -- (((C_S_AXI4_DATA_WIDTH/8)-1) downto 0);
       s_axi4_wlast   : in  std_logic;
       s_axi4_wvalid  : in  std_logic;
       s_axi4_wready  : out std_logic;
       -------------------------------------------
       -- axi4 full write Response Channel Signals
       -------------------------------------------
       s_axi4_bid     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_bresp   : out std_logic_vector(1 downto 0);
       s_axi4_bvalid  : out std_logic;
       s_axi4_bready  : in  std_logic;
       -----------------------------------
       -- axi read address Channel Signals
       -----------------------------------
       s_axi4_arid    : in  std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_araddr  : in  std_logic_vector((C_SPI_MEM_ADDR_BITS-1) downto 0);--((C_S_AXI4_ADDR_WIDTH-1) downto 0);
       s_axi4_arlen   : in  std_logic_vector(7 downto 0);
       s_axi4_arsize  : in  std_logic_vector(2 downto 0);
       s_axi4_arburst : in  std_logic_vector(1 downto 0);
       s_axi4_arlock  : in  std_logic;                -- not supported in design
       s_axi4_arcache : in  std_logic_vector(3 downto 0);-- not supported in design
       s_axi4_arprot  : in  std_logic_vector(2 downto 0);-- not supported in design
       s_axi4_arvalid : in  std_logic;
       s_axi4_arready : out std_logic;
       --------------------------------
       -- axi read data Channel Signals
       --------------------------------
       s_axi4_rid     : out std_logic_vector((C_S_AXI4_ID_WIDTH-1) downto 0);
       s_axi4_rdata   : out std_logic_vector(31 downto 0);--((C_S_AXI4_DATA_WIDTH-1) downto 0);
       s_axi4_rresp   : out std_logic_vector(1 downto 0);
       s_axi4_rlast   : out std_logic;
       s_axi4_rvalid  : out std_logic;
       s_axi4_rready  : in  std_logic;
       --------------------------------
       -------------------------------
       --*SPI port interface      * --
       -------------------------------
       io0_i          : in std_logic;  -- MOSI signal in standard SPI
       io0_o          : out std_logic;
       io0_t          : out std_logic;
       -------------------------------
       io1_i          : in std_logic;  -- MISO signal in standard SPI
       io1_o          : out std_logic;
       io1_t          : out std_logic;
       -----------------
       -- quad mode pins
       -----------------
       io2_i          : in std_logic;
       io2_o          : out std_logic;
       io2_t          : out std_logic;
       ---------------
       io3_i          : in std_logic;
       io3_o          : out std_logic;
       io3_t          : out std_logic;


       io0_1_i          : in std_logic;  -- MOSI signal in standard SPI
       io0_1_o          : out std_logic;
       io0_1_t          : out std_logic;
       -------------------------------
       io1_1_i          : in std_logic;  -- MISO signal in standard SPI
       io1_1_o          : out std_logic;
       io1_1_t          : out std_logic;
       -----------------
       -- quad mode pins
       -----------------
       io2_1_i          : in std_logic;
       io2_1_o          : out std_logic;
       io2_1_t          : out std_logic;
       ---------------
       io3_1_i          : in std_logic;
       io3_1_o          : out std_logic;
       io3_1_t          : out std_logic;
       ---------------------------------
       -- common pins
       ----------------
       spisel         : in std_logic;
       -----
       sck_i          : in std_logic;
       sck_o          : out std_logic;
       sck_t          : out std_logic;
       -----
       ss_i           : in std_logic_vector((C_NUM_SS_BITS-1-C_DUAL_QUAD_MODE) downto C_LSB_STUP);
       ss_o           : out std_logic_vector((C_NUM_SS_BITS-1-C_DUAL_QUAD_MODE) downto C_LSB_STUP);
       ss_t           : out std_logic;
	   
       ss_1_i           : in std_logic;
       ss_1_o           : out std_logic;
       ss_1_t           : out std_logic;
	   ------------------------
	   -- STARTUP INTERFACE
	   ------------------------
	   cfgclk  : out std_logic;       -- FGCLK       , -- 1-bit output: Configuration main clock output
       cfgmclk : out std_logic; -- FGMCLK      , -- 1-bit output: Configuration internal oscillator clock output
       eos     : out std_logic;  -- OS          , -- 1-bit output: Active high output signal indicating the End Of Startup.
       preq    : out std_logic; -- REQ         , -- 1-bit output: PROGRAM request to fabric output
       clk     : in std_logic;   -- input
       gsr     : in std_logic;   -- input
       gts     : in std_logic;   -- input
       keyclearb : in std_logic;   -- input
       usrcclkts : in std_logic;   -- input
       usrdoneo : in std_logic;   -- input
       usrdonets : in std_logic;   -- input
       pack : in std_logic;   -- input
       ----------------------
       -- INTERRUPT INTERFACE
       ----------------------
       ip2intc_irpt   : out std_logic
       ---------------------------------
   );
       -------------------------------
end entity axi_quad_spi;
--------------------------------------------------------------------------------

architecture imp of axi_quad_spi is

----------------------------------------------------------------------------------
-- below attributes are added to reduce the synth warnings in Vivado tool
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";
----------------------------------------------------------------------------------

begin

NO_DUAL_QUAD_MODE: if (C_DUAL_QUAD_MODE = 0) generate
begin
 
QSPI_NORMAL : entity axi_quad_spi_v3_2_9.axi_quad_spi_top
    GENERIC MAP (
      Async_Clk => Async_Clk,
      C_FAMILY => C_FAMILY, 
      C_SELECT_XPM => C_SELECT_XPM,
      C_SUB_FAMILY => C_SUB_FAMILY,
      C_INSTANCE => C_INSTANCE,
      C_SPI_MEM_ADDR_BITS => C_SPI_MEM_ADDR_BITS,
      C_TYPE_OF_AXI4_INTERFACE => C_TYPE_OF_AXI4_INTERFACE,
      C_XIP_MODE => C_XIP_MODE,
      C_UC_FAMILY => C_UC_FAMILY,
      C_FIFO_DEPTH => C_FIFO_DEPTH,
      C_SCK_RATIO => C_SCK_RATIO,
      C_NUM_SS_BITS => C_NUM_SS_BITS,
      C_NUM_TRANSFER_BITS => C_NUM_TRANSFER_BITS, 
      C_SPI_MODE => C_SPI_MODE,
      C_USE_STARTUP => C_USE_STARTUP,
      C_SPI_MEMORY => C_SPI_MEMORY,
      C_S_AXI_ADDR_WIDTH => C_S_AXI_ADDR_WIDTH,
      C_S_AXI_DATA_WIDTH => C_S_AXI_DATA_WIDTH,
      C_S_AXI4_ADDR_WIDTH => C_S_AXI4_ADDR_WIDTH,
      C_S_AXI4_DATA_WIDTH => C_S_AXI4_DATA_WIDTH,
      C_S_AXI4_ID_WIDTH => C_S_AXI4_ID_WIDTH,
      C_SHARED_STARTUP => C_SHARED_STARTUP,
      C_S_AXI4_BASEADDR => C_S_AXI4_BASEADDR,
      C_S_AXI4_HIGHADDR => C_S_AXI4_HIGHADDR,
      C_LSB_STUP => C_LSB_STUP ,
      C_DUAL_MODE => C_DUAL_QUAD_MODE,
      C_STARTUP_EXT => C_USE_STARTUP_EXT
    )
    PORT MAP (
      ext_spi_clk => ext_spi_clk,
      s_axi_aclk => s_axi_aclk,
      s_axi_aresetn => s_axi_aresetn,
      s_axi4_aclk => s_axi4_aclk,
      s_axi4_aresetn => s_axi4_aresetn,
      s_axi_awaddr => s_axi_awaddr,
      s_axi_awvalid => s_axi_awvalid,
      s_axi_awready => s_axi_awready,
      s_axi_wdata => s_axi_wdata,
      s_axi_wstrb => s_axi_wstrb,
      s_axi_wvalid => s_axi_wvalid,
      s_axi_wready => s_axi_wready,
      s_axi_bresp => s_axi_bresp,
      s_axi_bvalid => s_axi_bvalid,
      s_axi_bready => s_axi_bready,
      s_axi_araddr => s_axi_araddr,
      s_axi_arvalid => s_axi_arvalid,
      s_axi_arready => s_axi_arready,
      s_axi_rdata => s_axi_rdata,
      s_axi_rresp => s_axi_rresp,
      s_axi_rvalid => s_axi_rvalid,
      s_axi_rready => s_axi_rready,
      s_axi4_awid => s_axi4_awid,
      s_axi4_awaddr => s_axi4_awaddr,
      s_axi4_awlen => s_axi4_awlen,
      s_axi4_awsize => s_axi4_awsize,
      s_axi4_awburst => s_axi4_awburst,
      s_axi4_awlock => s_axi4_awlock,
      s_axi4_awcache => s_axi4_awcache,
      s_axi4_awprot => s_axi4_awprot,
      s_axi4_awvalid => s_axi4_awvalid,
      s_axi4_awready => s_axi4_awready,
      s_axi4_wdata => s_axi4_wdata,
      s_axi4_wstrb => s_axi4_wstrb,
      s_axi4_wlast => s_axi4_wlast,
      s_axi4_wvalid => s_axi4_wvalid,
      s_axi4_wready => s_axi4_wready,
      s_axi4_bid => s_axi4_bid,
      s_axi4_bresp => s_axi4_bresp,
      s_axi4_bvalid => s_axi4_bvalid,
      s_axi4_bready => s_axi4_bready,
      s_axi4_arid => s_axi4_arid,
      s_axi4_araddr => s_axi4_araddr,
      s_axi4_arlen => s_axi4_arlen,
      s_axi4_arsize => s_axi4_arsize,
      s_axi4_arburst => s_axi4_arburst,
      s_axi4_arlock => s_axi4_arlock,
      s_axi4_arcache => s_axi4_arcache,
      s_axi4_arprot => s_axi4_arprot,
      s_axi4_arvalid => s_axi4_arvalid,
      s_axi4_arready => s_axi4_arready,
      s_axi4_rid => s_axi4_rid,
      s_axi4_rdata => s_axi4_rdata,
      s_axi4_rresp => s_axi4_rresp,
      s_axi4_rlast => s_axi4_rlast,
      s_axi4_rvalid => s_axi4_rvalid,
      s_axi4_rready => s_axi4_rready,
      io0_i => io0_i,
      io0_o => io0_o,
      io0_t => io0_t,
      io1_i => io1_i,
      io1_o => io1_o,
      io1_t => io1_t,
      io2_i => io2_i,
      io2_o => io2_o,
      io2_t => io2_t,
      io3_i => io3_i,
      io3_o => io3_o,
      io3_t => io3_t,
      spisel => spisel,
      sck_i => sck_i,
      sck_o => sck_o,
      sck_t => sck_t,
      ss_i => ss_i,
      ss_o => ss_o,
      ss_t => ss_t,
      cfgclk => cfgclk,
      cfgmclk => cfgmclk,
      eos => eos,
      preq => preq,
      clk => clk,
      gsr => gsr,
      gts => gts,
      keyclearb => keyclearb,
      usrcclkts => usrcclkts,
      usrdoneo => usrdoneo,
      usrdonets => usrdonets,
      pack => pack,
      ip2intc_irpt => ip2intc_irpt
    );


end generate NO_DUAL_QUAD_MODE;



DUAL_QUAD_MODE: if (C_DUAL_QUAD_MODE = 1) generate

signal io0_i_int : std_logic;
signal io0_o_int : std_logic;
signal io0_t_int : std_logic;
signal io1_i_int : std_logic;
signal io1_o_int : std_logic;
signal io1_t_int : std_logic;
signal io2_i_int : std_logic;
signal io2_o_int : std_logic;
signal io2_t_int : std_logic;
signal io3_i_int : std_logic;
signal io3_o_int : std_logic;
signal io3_t_int : std_logic;

signal dual_o_int : std_logic_vector (3 downto 0); 
signal dual_t_int : std_logic_vector (3 downto 0); 
signal dual_i_int : std_logic_vector (3 downto 0); 

signal ss_o_int : std_logic_vector (C_NUM_SS_BITS-1 downto C_LSB_STUP);
signal ss_t_int : std_logic;

signal sck_o_int : std_logic;
signal sck_t_int : std_logic;

signal to_spi_1_do : std_logic_vector (3 downto 0); 
signal to_spi_1_dt : std_logic_vector (3 downto 0); 
signal from_spi_1_di  : std_logic_vector (3 downto 0); 
signal to_spi_1_ss : std_logic;
signal to_spi_1_ss_t : std_logic;

signal to_gnd : std_logic;
signal to_gnd2 : std_logic_vector (1 downto 0);

begin

to_gnd <= '0';
to_gnd2 <= "00";



QSPI_DUAL_QUAD : entity axi_quad_spi_v3_2_9.axi_quad_spi_top
    GENERIC MAP (
      Async_Clk => Async_Clk,
      C_FAMILY => C_FAMILY, 
      C_SELECT_XPM => C_SELECT_XPM,
      C_SUB_FAMILY => C_SUB_FAMILY,
      C_INSTANCE => C_INSTANCE,
      C_SPI_MEM_ADDR_BITS => C_SPI_MEM_ADDR_BITS,
      C_TYPE_OF_AXI4_INTERFACE => C_TYPE_OF_AXI4_INTERFACE,
      C_XIP_MODE => C_XIP_MODE,
      C_UC_FAMILY => C_UC_FAMILY,
      C_FIFO_DEPTH => C_FIFO_DEPTH,
      C_SCK_RATIO => C_SCK_RATIO,
--      C_DUAL_QUAD_MODE =>, 
      C_NUM_SS_BITS => C_NUM_SS_BITS,
      C_NUM_TRANSFER_BITS => C_NUM_TRANSFER_BITS, 
      C_SPI_MODE => C_SPI_MODE,
      C_USE_STARTUP => 0, --C_USE_STARTUP,
      C_SPI_MEMORY => C_SPI_MEMORY,
      C_S_AXI_ADDR_WIDTH => C_S_AXI_ADDR_WIDTH,
      C_S_AXI_DATA_WIDTH => C_S_AXI_DATA_WIDTH,
      C_S_AXI4_ADDR_WIDTH => C_S_AXI4_ADDR_WIDTH,
      C_S_AXI4_DATA_WIDTH => C_S_AXI4_DATA_WIDTH,
      C_S_AXI4_ID_WIDTH => C_S_AXI4_ID_WIDTH,
      C_SHARED_STARTUP => C_SHARED_STARTUP,
      C_S_AXI4_BASEADDR => C_S_AXI4_BASEADDR,
      C_S_AXI4_HIGHADDR => C_S_AXI4_HIGHADDR,
      C_LSB_STUP => C_LSB_STUP,
      C_DUAL_MODE => C_DUAL_QUAD_MODE,
      C_STARTUP_EXT => C_USE_STARTUP_EXT
    )
    PORT MAP (
      ext_spi_clk => ext_spi_clk,
      s_axi_aclk => s_axi_aclk,
      s_axi_aresetn => s_axi_aresetn,
      s_axi4_aclk => s_axi4_aclk,
      s_axi4_aresetn => s_axi4_aresetn,
      s_axi_awaddr => s_axi_awaddr,
      s_axi_awvalid => s_axi_awvalid,
      s_axi_awready => s_axi_awready,
      s_axi_wdata => s_axi_wdata,
      s_axi_wstrb => s_axi_wstrb,
      s_axi_wvalid => s_axi_wvalid,
      s_axi_wready => s_axi_wready,
      s_axi_bresp => s_axi_bresp,
      s_axi_bvalid => s_axi_bvalid,
      s_axi_bready => s_axi_bready,
      s_axi_araddr => s_axi_araddr,
      s_axi_arvalid => s_axi_arvalid,
      s_axi_arready => s_axi_arready,
      s_axi_rdata => s_axi_rdata,
      s_axi_rresp => s_axi_rresp,
      s_axi_rvalid => s_axi_rvalid,
      s_axi_rready => s_axi_rready,
      s_axi4_awid => s_axi4_awid,
      s_axi4_awaddr => s_axi4_awaddr,
      s_axi4_awlen => s_axi4_awlen,
      s_axi4_awsize => s_axi4_awsize,
      s_axi4_awburst => s_axi4_awburst,
      s_axi4_awlock => s_axi4_awlock,
      s_axi4_awcache => s_axi4_awcache,
      s_axi4_awprot => s_axi4_awprot,
      s_axi4_awvalid => s_axi4_awvalid,
      s_axi4_awready => s_axi4_awready,
      s_axi4_wdata => s_axi4_wdata,
      s_axi4_wstrb => s_axi4_wstrb,
      s_axi4_wlast => s_axi4_wlast,
      s_axi4_wvalid => s_axi4_wvalid,
      s_axi4_wready => s_axi4_wready,
      s_axi4_bid => s_axi4_bid,
      s_axi4_bresp => s_axi4_bresp,
      s_axi4_bvalid => s_axi4_bvalid,
      s_axi4_bready => s_axi4_bready,
      s_axi4_arid => s_axi4_arid,
      s_axi4_araddr => s_axi4_araddr,
      s_axi4_arlen => s_axi4_arlen,
      s_axi4_arsize => s_axi4_arsize,
      s_axi4_arburst => s_axi4_arburst,
      s_axi4_arlock => s_axi4_arlock,
      s_axi4_arcache => s_axi4_arcache,
      s_axi4_arprot => s_axi4_arprot,
      s_axi4_arvalid => s_axi4_arvalid,
      s_axi4_arready => s_axi4_arready,
      s_axi4_rid => s_axi4_rid,
      s_axi4_rdata => s_axi4_rdata,
      s_axi4_rresp => s_axi4_rresp,
      s_axi4_rlast => s_axi4_rlast,
      s_axi4_rvalid => s_axi4_rvalid,
      s_axi4_rready => s_axi4_rready,
      io0_i => io0_i_int,
      io0_o => io0_o_int,
      io0_t => io0_t_int,
      io1_i => io1_i_int,
      io1_o => io1_o_int,
      io1_t => io1_t_int,
      io2_i => io2_i_int,
      io2_o => io2_o_int,
      io2_t => io2_t_int,
      io3_i => io3_i_int,
      io3_o => io3_o_int,
      io3_t => io3_t_int,
      spisel => spisel,
      sck_i => sck_i,
      sck_o => sck_o_int,
      sck_t => sck_t_int,
      ss_i => to_gnd2, --ss_i,
      ss_o => ss_o_int,
      ss_t => ss_t_int,
-- to be driven from muxing block
      cfgclk => open,
      cfgmclk => open,
      eos => open,
      preq => open,
      clk => to_gnd,
      gsr => to_gnd,
      gts => to_gnd,
      keyclearb => to_gnd,
      usrcclkts => to_gnd,
      usrdoneo => to_gnd,
      usrdonets => to_gnd,
      pack => to_gnd,
------
      ip2intc_irpt => ip2intc_irpt
    );


STARTUP_DUAL_QUAD_MODE: if (C_USE_STARTUP = 1) generate
begin

dual_o_int <= io3_o_int & io2_o_int & io1_o_int & io0_o_int;
dual_t_int <= io3_t_int & io2_t_int & io1_t_int & io0_t_int;
--dual_i_int <= io3_i_int & io2_i_int & io1_i_int & io0_i_int;

io3_i_int <= dual_i_int(3);
io2_i_int <= dual_i_int(2);
io1_i_int <= dual_i_int(1);
io0_i_int <= dual_i_int(0);

io0_1_o <= to_spi_1_do(0);
io1_1_o <= to_spi_1_do(1);
io2_1_o <= to_spi_1_do(2);
io3_1_o <= to_spi_1_do(3);

io0_1_t <= to_spi_1_dt(0);
io1_1_t <= to_spi_1_dt(1);
io2_1_t <= to_spi_1_dt(2);
io3_1_t <= to_spi_1_dt(3);

from_spi_1_di(0) <= io0_1_i;
from_spi_1_di(1) <= io1_1_i;
from_spi_1_di(2) <= io2_1_i;
from_spi_1_di(3) <= io3_1_i;

ss_1_o <= to_spi_1_ss;
ss_1_t <= to_spi_1_ss_t;


     MUX_DEMUX_LOGIC : entity axi_quad_spi_v3_2_9.qspi_dual_quad_mode
     generic map(
                C_SUB_FAMILY             => C_FAMILY,
                ---------------------
                C_USE_STARTUP            => 1,
                ---------------------
                C_SHARED_STARTUP         => 1,
                ---------------------
                C_SPI_MODE               => C_SPI_MODE
                ---------------------
        )
        port map
        (
                Bus2IP_Clk     => s_axi_aclk,      
                reset2ip_reset => s_axi_aresetn,
                DI             => dual_i_int,                 -- output of mux going to logic
                DO             => dual_o_int,      -- logic outputs to be muxed to SPI_1 and startup
                DT             => dual_t_int,      -- logic outputs to be muxed to SPI_1 and startup
                SS             => ss_o_int,
                SS_T           => ss_t_int,
                SCK            => sck_o_int,
                SCK_T          => sck_t_int,
-- SPI_1 interface
                spi_1_do       => to_spi_1_do,   -- to spi_1
                spi_1_dt       => to_spi_1_dt,   -- to spi_1
                spi_1_di       => from_spi_1_di, -- from spi_1
                spi_1_ss       => to_spi_1_ss,   -- to spi_1
                spi_1_ss_t     => to_spi_1_ss_t, -- to spi_1
           ------------------------
           -- STARTUP INTERFACE
           ------------------------
                cfgclk         => cfgclk,
                cfgmclk        => cfgmclk,
                eos            => eos,
                preq           => preq,
                clk            => clk,
                gsr            => gsr,
                gts            => gts,
                keyclearb      => keyclearb,
                usrcclkts      => usrcclkts,
                usrdoneo       => usrdoneo,
                usrdonets      => usrdonets
);
end generate STARTUP_DUAL_QUAD_MODE;


NO_STARTUP_DUAL_QUAD_MODE: if (C_USE_STARTUP = 0) generate
signal to_spi_1_o : std_logic_vector (3 downto 0); 
signal to_spi_1_t : std_logic_vector (3 downto 0); 
signal to_spi_0_o : std_logic_vector (3 downto 0); 
signal to_spi_0_t : std_logic_vector (3 downto 0); 

begin
dual_o_int <= io3_o_int & io2_o_int & io1_o_int & io0_o_int;
dual_t_int <= io3_t_int & io2_t_int & io1_t_int & io0_t_int;

to_spi_1_o <= dual_o_int when (ss_o_int = "01") else "0000";
to_spi_1_t <= dual_t_int when (ss_o_int = "01") else "0000";

io0_1_o <= to_spi_1_o(0);
io1_1_o <= to_spi_1_o(1);
io2_1_o <= to_spi_1_o(2);
io3_1_o <= to_spi_1_o(3);

io0_1_t <= to_spi_1_t(0);
io1_1_t <= to_spi_1_t(1);
io2_1_t <= to_spi_1_t(2);
io3_1_t <= to_spi_1_t(3);

to_spi_0_o <= dual_o_int when (ss_o_int = "10") else "0000";
to_spi_0_t <= dual_t_int when (ss_o_int = "10") else "0000";

io0_o <= to_spi_0_o(0);
io1_o <= to_spi_0_o(1);
io2_o <= to_spi_0_o(2);
io3_o <= to_spi_0_o(3);

io0_t <= to_spi_0_t(0);
io1_t <= to_spi_0_t(1);
io2_t <= to_spi_0_t(2);
io3_t <= to_spi_0_t(3);

io0_i_int <= io0_1_i when (ss_o_int = "01") else io0_i;
io1_i_int <= io1_1_i when (ss_o_int = "01") else io1_i;
io2_i_int <= io2_1_i when (ss_o_int = "01") else io2_i;
io3_i_int <= io3_1_i when (ss_o_int = "01") else io3_i;

ss_1_o <= ss_o_int (1);
ss_1_t <= ss_t_int;

ss_o (0) <= ss_o_int (0);
ss_t <= ss_t_int;

sck_o <= sck_o_int;
sck_t <= sck_t_int;

end generate NO_STARTUP_DUAL_QUAD_MODE;

end generate DUAL_QUAD_MODE;




------------------------------------------------------------------------------
end architecture imp;
------------------------------------------------------------------------------


